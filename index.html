<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>My GitHub HTML Projects</title>
<style>
  :root { color-scheme: light; }
  body { font-family: Arial, sans-serif; padding: 28px; background:#f7f7f7; }
  h1 { margin: 0 0 8px; }
  p  { margin: 0 0 18px; color:#333; }
  .panel { background:#fff; border-radius:12px; padding:18px 18px 10px; box-shadow: 0 4px 14px rgba(0,0,0,.06); }
  details { margin: 10px 0; border: 1px solid #eee; border-radius: 10px; background:#fafafa; }
  summary { cursor:pointer; padding: 10px 12px; font-weight: 700; user-select:none; list-style:none; }
  summary::-webkit-details-marker { display:none; }
  summary::before { content:"â–¸"; display:inline-block; width: 18px; color:#666; }
  details[open] summary::before { content:"â–¾"; }
  ul { list-style:none; padding: 0 0 10px 0; margin: 0; }
  li { padding: 6px 12px; }
  a { text-decoration:none; color:#0066cc; }
  a:hover { text-decoration:underline; }
  .muted { color:#777; font-weight:400; margin-left:6px; font-size: 0.9em; }
  .icon { display:inline-block; width: 22px; }
  .path { color:#777; font-weight:400; margin-left:8px; font-size: 0.85em; }
</style>
</head>
<body>
  <h1>GitHub HTML Pages</h1>
  <p>Auto-generated list of HTML files in this repository (grouped & sorted).</p>

  <div class="panel">
    <div id="status" class="muted">Loadingâ€¦</div>
    <div id="groups"></div>
  </div>

<script>
(() => {
  const OWNER = "jwesters";
  const REPO  = "website";
  const SITE_URL = `https://${OWNER}.github.io/${REPO}`;
  const API_BASE = `https://api.github.com/repos/${OWNER}/${REPO}/contents`;

  // âœ… Options
  const HIDE_ROOT_INDEX_HTML = true;   // hides "/index.html" only
  const HIDE_ALL_INDEX_HTML  = false;  // if you want to hide every ".../index.html", set true

  // âœ… Hide files whose *filename* starts with "NSFW"
  const HIDE_NSFw_PREFIX = true; // (case-insensitive) NSFW*.html won't be listed

  // --- Icon mapping (folder/file keywords -> emoji)
  const ICON_RULES = [
    { re: /(tetris)/i, icon: "ðŸ§±" },
    { re: /(hangman)/i, icon: "ðŸª“" },
    { re: /(maze)/i, icon: "ðŸ§©" },
    { re: /(qr|qrcode)/i, icon: "ðŸ”³" },
    { re: /(wordle|numdle|dle)/i, icon: "ðŸŸ©" },
    { re: /(card|deck)/i, icon: "ðŸƒ" },
    { re: /(clock|time)/i, icon: "â°" },
    { re: /(math|quiz)/i, icon: "âž—" },
    { re: /(game|play)/i, icon: "ðŸŽ®" },
    { re: /(index)/i, icon: "ðŸ " },
  ];
  const DEFAULT_FOLDER_ICON = "ðŸ“";
  const DEFAULT_FILE_ICON   = "ðŸ“„";

  const statusEl = document.getElementById("status");
  const groupsEl = document.getElementById("groups");

  function iconFor(name, isDir) {
    const hit = ICON_RULES.find(r => r.re.test(name));
    if (hit) return hit.icon;
    return isDir ? DEFAULT_FOLDER_ICON : DEFAULT_FILE_ICON;
  }

  // Group key = TOP-LEVEL folder only ("" for root)
  // e.g. "DLE_Games/hockeystats/file.html" -> group "DLE_Games"
  const groups = new Map(); // topFolder -> array of { path, name, relFolder }

  function topLevelFolderFor(filePath) {
    const parts = filePath.split("/").filter(Boolean);
    if (parts.length <= 1) return ""; // root file like "foo.html"
    return parts[0];                  // top-level folder
  }

  function relativeFolderWithinTop(filePath) {
    // For displaying where inside the top-level folder it lives (optional)
    // "DLE_Games/hockeystats/file.html" -> "hockeystats"
    const parts = filePath.split("/").filter(Boolean);
    if (parts.length <= 2) return ""; // directly inside top-level folder
    return parts.slice(1, -1).join("/");
  }

  function addToGroup(filePath) {
    const parts = filePath.split("/").filter(Boolean);
    const name = parts[parts.length - 1];
    const top = topLevelFolderFor(filePath); // "" or top folder name
    const relFolder = relativeFolderWithinTop(filePath);

    if (!groups.has(top)) groups.set(top, []);
    groups.get(top).push({ path: filePath, name, relFolder });
  }

  function isNSFWName(filename) {
    // starts with NSFW (case-insensitive) and optionally separator, e.g. NSFW_, NSFW-, NSFW space
    // "NSFWsomething.html", "NSFW_something.html", "nsfw-something.html"
    return /^nsfw([_\-\s]|$)/i.test(filename);
  }

  function shouldHide(filePath) {
    const lower = filePath.toLowerCase();
    const filename = filePath.split("/").pop() || "";

    if (HIDE_ALL_INDEX_HTML && lower.endsWith("/index.html")) return true;
    if (HIDE_ROOT_INDEX_HTML && lower === "index.html") return true;

    if (HIDE_NSFw_PREFIX && isNSFWName(filename)) return true;

    return false;
  }

  // Recursively walk the repo using the Contents API
  async function fetchFiles(path = "") {
    const url = path ? `${API_BASE}/${encodeURIComponent(path)}` : API_BASE;
    const res = await fetch(url);
    if (!res.ok) throw new Error(`GitHub API error: ${res.status} ${res.statusText}`);
    const items = await res.json();

    for (const item of items) {
      if (item.type === "dir") {
        await fetchFiles(item.path);
      } else if (item.type === "file" && item.name.toLowerCase().endsWith(".html")) {
        if (!shouldHide(item.path)) addToGroup(item.path);
      }
    }
  }

  function sortAlpha(a, b) {
    return a.localeCompare(b, undefined, { sensitivity: "base" });
  }

  function buildUI() {
    statusEl.textContent = "";

    // Sort group names alphabetically; root first
    const groupNames = Array.from(groups.keys())
      .sort((a, b) => {
        if (a === "" && b !== "") return -1;
        if (b === "" && a !== "") return 1;
        return sortAlpha(a, b);
      });

    for (const group of groupNames) {
      const files = groups.get(group) || [];

      // Sort files alphabetically by name
      files.sort((a, b) => sortAlpha(a.name, b.name));

      const isRoot = group === "";
      const label = isRoot ? "Root" : group;

      const details = document.createElement("details");
      details.open = isRoot; // open root by default

      const summary = document.createElement("summary");
      summary.innerHTML = `<span class="icon">${iconFor(label, true)}</span>${label} <span class="muted">(${files.length})</span>`;
      details.appendChild(summary);

      const ul = document.createElement("ul");

      for (const f of files) {
        const li = document.createElement("li");
        const a = document.createElement("a");
        a.href = `${SITE_URL}/${f.path}`;
        a.target = "_blank";
        a.rel = "noopener noreferrer";

        // Show file name, and (optionally) the subfolder path within the top-level group
        const subPathHint = (group !== "" && f.relFolder) ? ` <span class="path">(${f.relFolder})</span>` : "";
        a.innerHTML = `<span class="icon">${iconFor(f.path, false)}</span>${f.name}${subPathHint}`;

        li.appendChild(a);
        ul.appendChild(li);
      }

      details.appendChild(ul);
      groupsEl.appendChild(details);
    }

    if (groupNames.length === 0) {
      statusEl.textContent = "No HTML files found.";
    }
  }

  (async () => {
    try {
      statusEl.textContent = "Loadingâ€¦";
      await fetchFiles("");
      buildUI();
    } catch (err) {
      console.error(err);
      statusEl.textContent = "Failed to load files. Check the browser console for details.";
    }
  })();
})();
</script>

</body>
</html>
