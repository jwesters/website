<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris (Arrow Keys Only) + Word Unlock + Difficulty</title>
  <style>
    :root{
      --bg:#0b0f14;
      --ink:#e8eef7;
      --muted:#9fb0c4;
      --border:#233247;
      --panel:rgba(0,0,0,0.18);
      --btn:#1f6feb;
      --warn:#fb7185;
      --ok:#34d399;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:radial-gradient(1200px 800px at 30% 10%, #132034 0%, var(--bg) 55%, #070a0f 100%);
      color:var(--ink);
      display:flex;
      min-height:100vh;
      align-items:center;
      justify-content:center;
      padding:18px;
    }

    /* LAYOUT: left panel + game + right panel */
    .wrap{
      display:grid;
      grid-template-columns: 300px auto 260px;
      gap:16px;
      align-items:start;
      max-width: 980px;
      width:100%;
    }

    .card{
      background:linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
      border:1px solid var(--border);
      border-radius:14px;
      box-shadow:0 10px 30px rgba(0,0,0,0.35);
      overflow:hidden;
    }

    .panel{
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .title{
      font-weight:900;
      letter-spacing:0.3px;
      font-size:16px;
      margin:0 0 6px 0;
    }

    .stat{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      background:var(--panel);
      border:1px solid rgba(255,255,255,0.08);
      border-radius:12px;
      font-size:14px;
    }
    .stat span:last-child{color:var(--muted)}

    .controls{
      padding:10px 12px;
      background:var(--panel);
      border:1px solid rgba(255,255,255,0.08);
      border-radius:12px;
      font-size:13px;
      color:var(--muted);
      line-height:1.35;
    }

    .row{ display:flex; gap:10px; flex-wrap:wrap; }
    button{
      appearance:none;
      border:none;
      background:var(--btn);
      color:white;
      padding:10px 12px;
      border-radius:12px;
      font-weight:900;
      cursor:pointer;
      flex:1;
      min-width:110px;
    }
    button.secondary{
      background:rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.12);
      color:var(--ink);
      font-weight:800;
    }
    button:disabled{opacity:0.55; cursor:not-allowed}
    button:active{transform:translateY(1px)}
    .hint{ font-size:12px; color:var(--muted); margin:0; }

    /* Game card */
    .main{
      padding:14px;
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }
    canvas{
      display:block;
      background:rgba(0,0,0,0.25);
      border:1px solid rgba(255,255,255,0.10);
      border-radius:10px;
      image-rendering:pixelated;
    }
    .footer{
      text-align:center;
      padding:10px 14px;
      border-top:1px solid rgba(255,255,255,0.08);
      color:var(--muted);
      font-size:12px;
    }

    /* Unlock box */
    .box{
      padding:10px 12px;
      background:var(--panel);
      border:1px solid rgba(255,255,255,0.08);
      border-radius:12px;
    }
    .unlockTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .pill{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(255,255,255,0.06);
      font-size:12px;
      font-weight:900;
      white-space:nowrap;
    }
    .pill.locked{ border-color: rgba(251,113,133,0.45); background: rgba(251,113,133,0.10); }
    .pill.unlocked{ border-color: rgba(52,211,153,0.45); background: rgba(52,211,153,0.10); }

    .pattern{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:18px;
      letter-spacing:2px;
      font-weight:950;
      margin:0 0 8px 0;
    }
    label{
      display:block;
      font-size:12px;
      color:var(--muted);
      margin-bottom:6px;
    }
    select, input[type="text"]{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.12);
      background:rgba(0,0,0,0.20);
      color:var(--ink);
      outline:none;
      font-weight:850;
    }
    input[type="text"]::placeholder{color:rgba(159,176,196,0.7)}
    .small{
      font-size:12px;
      color:var(--muted);
      margin:0;
      line-height:1.35;
    }
    .shake{
      animation: shake 220ms linear;
    }
    @keyframes shake {
      0%{ transform:translateX(0) }
      25%{ transform:translateX(-5px) }
      50%{ transform:translateX(5px) }
      75%{ transform:translateX(-4px) }
      100%{ transform:translateX(0) }
    }

    /* Right panel Next preview */
    .previewWrap{
      padding:10px 12px;
      background:var(--panel);
      border:1px solid rgba(255,255,255,0.08);
      border-radius:12px;
    }

    @media (max-width: 980px){
      .wrap{ grid-template-columns: 1fr; max-width: 520px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- LEFT PANEL: Unlock + Score/Lines/Level -->
    <div class="card">
      <div class="panel">
        <div class="box" id="unlockBox">
          <div class="unlockTop">
            <span style="font-weight:950;">Unlock word</span>
            <span class="pill locked" id="lockPill">LOCKED</span>
          </div>
          <p class="pattern" id="pattern">—</p>
          <input id="wordInput" type="text" inputmode="text" autocomplete="off" autocapitalize="none" spellcheck="false" placeholder="Type the word to unlock controls" />
          <p class="small" id="unlockHint">Controls are disabled until you type the word correctly. If you make a mistake, retype the whole word.</p>
          <p class="small" id="wordStatus" style="margin-top:8px;">Word file: loading…</p>
        </div>

        <div class="stat"><span>Score</span><span id="score">0</span></div>
        <div class="stat"><span>Lines</span><span id="lines">0</span></div>
        <div class="stat"><span>Level</span><span id="level">1</span></div>

        <div class="row">
          <button id="startBtn">Start</button>
          <button id="pauseBtn" class="secondary" disabled>Pause</button>
        </div>

        <p class="hint">Tip: keep typing in the box to unlock each piece.</p>
      </div>
    </div>

    <!-- CENTER: GAME -->
    <div class="card">
      <div class="main">
        <canvas id="game" width="240" height="480" aria-label="Tetris board"></canvas>
      </div>
      <div class="footer">Arrow keys only • Up rotate • Down = soft drop</div>
    </div>

    <!-- RIGHT PANEL: Everything else -->
    <div class="card">
      <div class="panel">
        <div>
          <p class="title">Next</p>
          <div class="previewWrap">
            <canvas id="next" width="120" height="120" aria-label="Next piece preview"></canvas>
          </div>
        </div>

        <div>
          <label for="difficulty">Difficulty</label>
          <select id="difficulty">
            <option value="easy">Easy</option>
            <option value="medium" selected>Medium</option>
            <option value="hard">Hard</option>
          </select>
          <p class="hint" style="margin-top:8px;">Difficulty changes speed + which words are chosen.</p>
        </div>

        <div class="controls">
          <strong style="color:var(--ink)">Controls</strong><br>
          ↑ Rotate<br>
          ← Move left<br>
          → Move right<br>
          ↓ Soft drop (faster)
        </div>

        <p class="hint">Tip: click the game area once if arrow keys don’t respond.</p>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Board settings =====
  const COLS = 10, ROWS = 20;
  const BLOCK = 24;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const nextCanvas = document.getElementById('next');
  const nctx = nextCanvas.getContext('2d');

  const scoreEl = document.getElementById('score');
  const linesEl = document.getElementById('lines');
  const levelEl = document.getElementById('level');

  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const difficultySel = document.getElementById('difficulty');

  const unlockBox = document.getElementById('unlockBox');
  const lockPill = document.getElementById('lockPill');
  const patternEl = document.getElementById('pattern');
  const wordInput = document.getElementById('wordInput');
  const wordStatusEl = document.getElementById('wordStatus');

  // ===== Colors =====
  const COLORS = {
    I: '#60a5fa',
    O: '#fbbf24',
    T: '#a78bfa',
    S: '#34d399',
    Z: '#fb7185',
    J: '#38bdf8',
    L: '#f97316',
  };

  // ===== Tetromino shapes =====
  const SHAPES = {
    I: [
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0],
      [0,0,0,0],
    ],
    O: [
      [1,1],
      [1,1],
    ],
    T: [
      [0,1,0],
      [1,1,1],
      [0,0,0],
    ],
    S: [
      [0,1,1],
      [1,1,0],
      [0,0,0],
    ],
    Z: [
      [1,1,0],
      [0,1,1],
      [0,0,0],
    ],
    J: [
      [1,0,0],
      [1,1,1],
      [0,0,0],
    ],
    L: [
      [0,0,1],
      [1,1,1],
      [0,0,0],
    ],
  };
  const TYPES = Object.keys(SHAPES);

  function createBoard() {
    return Array.from({length: ROWS}, () => Array(COLS).fill(null));
  }
  function cloneMatrix(m) { return m.map(r => r.slice()); }

  function rotateMatrixCW(matrix) {
    const h = matrix.length;
    const w = matrix[0].length;
    const out = Array.from({length: w}, () => Array(h).fill(0));
    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        out[x][h-1-y] = matrix[y][x];
      }
    }
    return out;
  }

  function randType() {
    if (!randType.bag || randType.bag.length === 0) {
      randType.bag = TYPES.slice();
      for (let i = randType.bag.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [randType.bag[i], randType.bag[j]] = [randType.bag[j], randType.bag[i]];
      }
    }
    return randType.bag.pop();
  }

  function newPiece(type) {
    const shape = cloneMatrix(SHAPES[type]);
    const x = ((COLS / 2) | 0) - ((shape[0].length / 2) | 0);
    const y = -1;
    return { type, shape, x, y };
  }

  function collides(board, piece, offX=0, offY=0, shapeOverride=null) {
    const shape = shapeOverride || piece.shape;
    for (let y=0; y<shape.length; y++){
      for (let x=0; x<shape[y].length; x++){
        if (!shape[y][x]) continue;
        const bx = piece.x + x + offX;
        const by = piece.y + y + offY;

        if (bx < 0 || bx >= COLS || by >= ROWS) return true;
        if (by >= 0 && board[by][bx]) return true;
      }
    }
    return false;
  }

  function merge(board, piece) {
    const {shape, type} = piece;
    for (let y=0; y<shape.length; y++){
      for (let x=0; x<shape[y].length; x++){
        if (!shape[y][x]) continue;
        const by = piece.y + y;
        const bx = piece.x + x;
        if (by >= 0 && by < ROWS && bx >= 0 && bx < COLS) {
          board[by][bx] = type;
        }
      }
    }
  }

  function clearLines(board) {
    let cleared = 0;
    outer: for (let y = ROWS - 1; y >= 0; y--) {
      for (let x = 0; x < COLS; x++) {
        if (!board[y][x]) continue outer;
      }
      board.splice(y, 1);
      board.unshift(Array(COLS).fill(null));
      cleared++;
      y++;
    }
    return cleared;
  }

  function drawCell(g, x, y, size, color) {
    g.fillStyle = color;
    g.fillRect(x*size, y*size, size, size);
    g.strokeStyle = 'rgba(255,255,255,0.08)';
    g.strokeRect(x*size + 0.5, y*size + 0.5, size-1, size-1);
  }

  function drawBoard() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    for (let y=0; y<ROWS; y++){
      for (let x=0; x<COLS; x++){
        const t = board[y][x];
        if (!t) continue;
        drawCell(ctx, x, y, BLOCK, COLORS[t]);
      }
    }

    if (current) {
      const {shape, type} = current;
      for (let y=0; y<shape.length; y++){
        for (let x=0; x<shape[y].length; x++){
          if (!shape[y][x]) continue;
          const bx = current.x + x;
          const by = current.y + y;
          if (by < 0) continue;
          drawCell(ctx, bx, by, BLOCK, COLORS[type]);
        }
      }
    }

    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.strokeRect(0.5,0.5,canvas.width-1,canvas.height-1);

    if (gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.65)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#ffffff';
      ctx.font = '900 24px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', canvas.width/2, canvas.height/2 - 8);
      ctx.font = '14px system-ui, sans-serif';
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.fillText('Press Start to play again', canvas.width/2, canvas.height/2 + 18);
    } else if (paused) {
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#ffffff';
      ctx.font = '900 22px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Paused', canvas.width/2, canvas.height/2);
    }
  }

  function drawNext() {
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    nctx.fillStyle = 'rgba(0,0,0,0.15)';
    nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);

    if (!next) return;

    const size = 24;
    const shape = next.shape;
    const type = next.type;

    let minX=99,minY=99,maxX=-1,maxY=-1;
    for (let y=0; y<shape.length; y++){
      for (let x=0; x<shape[y].length; x++){
        if (!shape[y][x]) continue;
        minX = Math.min(minX,x); minY=Math.min(minY,y);
        maxX = Math.max(maxX,x); maxY=Math.max(maxY,y);
      }
    }
    const w = maxX - minX + 1;
    const h = maxY - minY + 1;
    const offsetX = (((nextCanvas.width / size) | 0) - w) / 2;
    const offsetY = (((nextCanvas.height / size) | 0) - h) / 2;

    for (let y=0; y<shape.length; y++){
      for (let x=0; x<shape[y].length; x++){
        if (!shape[y][x]) continue;
        const px = (x - minX + offsetX);
        const py = (y - minY + offsetY);
        drawCell(nctx, px, py, size, COLORS[type]);
      }
    }
    nctx.strokeStyle = 'rgba(255,255,255,0.12)';
    nctx.strokeRect(0.5,0.5,nextCanvas.width-1,nextCanvas.height-1);
  }

  // ===== Words (file) =====
  const WORD_FILE = 'words.txt';
  const fallbackWords = [
    "cat","dog","tree","house","school","pencil","paper","planet","window","orange",
    "music","tiger","mouse","green","blue","yellow","purple","rocket","zebra","guitar"
  ];
  let pools = { easy: [], medium: [], hard: [] };

  function sanitizeWord(w){
    return (w || '').trim().toLowerCase().replace(/[^a-z]/g,'');
  }

  function buildPoolsFromOrder(words){
    const clean = words.map(sanitizeWord).filter(w => w.length >= 2);
    const unique = [];
    const seen = new Set();
    for (const w of clean){
      if (seen.has(w)) continue;
      seen.add(w);
      unique.push(w);
    }
    const easyEnd = Math.min(2000, unique.length);
    const medEnd  = Math.min(easyEnd + 3000, unique.length);
    pools.easy   = unique.slice(0, easyEnd);
    pools.medium = unique.slice(easyEnd, medEnd);
    pools.hard   = unique.slice(medEnd);
    return unique.length;
  }

  async function loadWords(){
    try{
      wordStatusEl.textContent = 'Word file: loading…';
      const res = await fetch(WORD_FILE, { cache: 'no-store' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const text = await res.text();
      const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      const total = buildPoolsFromOrder(lines);
      wordStatusEl.textContent = `Word file: loaded (${total} unique)`;
    } catch (e) {
      console.warn('Word file load failed, using fallback list.', e);
      buildPoolsFromOrder(fallbackWords);
      wordStatusEl.textContent = `Word file: not found (using fallback words)`;
    }
  }

  function pickWordForMode(mode){
    const list = pools[mode] || [];
    if (!list.length) return "word";
    const idx = (Math.random() * list.length) | 0;
    return list[idx];
  }

  // ===== Difficulty speeds =====
  const DIFF = {
    easy:   { base: 820, levelStep: 45, floor: 170 },
    medium: { base: 700, levelStep: 55, floor: 120 },
    hard:   { base: 560, levelStep: 65, floor: 85  },
  };

  // ===== Game state =====
  let board = createBoard();
  let current = null;
  let next = null;

  let score = 0;
  let lines = 0;
  let level = 1;

  let baseDropMs = 700;
  let lastTime = 0;
  let accumulator = 0;

  let running = false;
  let paused = false;
  let gameOver = false;

  // Unlock/typing state
  let locked = true;
  let unlockWord = "";
  let typed = "";

  // Soft drop state
  const held = { down:false };

  function updateHUD(){
    scoreEl.textContent = String(score);
    linesEl.textContent = String(lines);
    levelEl.textContent = String(level);
  }

  function applyDifficultySpeed(){
    const mode = difficultySel.value;
    const cfg = DIFF[mode] || DIFF.medium;
    baseDropMs = Math.max(cfg.floor, cfg.base - (level - 1) * cfg.levelStep);
  }

  function scoreForClears(n) {
    const base = [0, 100, 300, 500, 800][n] || 0;
    return base * level;
  }

  function bumpLevelIfNeeded(){
    const newLevel = 1 + Math.floor(lines / 10);
    if (newLevel !== level){
      level = newLevel;
      applyDifficultySpeed();
    }
  }

  function setLocked(isLocked){
    locked = isLocked;
    lockPill.textContent = locked ? 'LOCKED' : 'UNLOCKED';
    lockPill.classList.toggle('locked', locked);
    lockPill.classList.toggle('unlocked', !locked);

    if (locked){
      wordInput.disabled = false;
      wordInput.value = '';
      typed = '';
      renderPattern();
      setTimeout(() => wordInput.focus({preventScroll:true}), 0);
    } else {
      wordInput.value = '';
      wordInput.blur();
    }
  }

  function renderPattern(){
    if (!unlockWord){
      patternEl.textContent = '—';
      return;
    }
    const shown = unlockWord.split('').map((ch, i) => (i < typed.length ? ch.toUpperCase() : '_')).join(' ');
    patternEl.textContent = shown;
  }

  function newUnlockWord(){
    const mode = difficultySel.value;
    unlockWord = pickWordForMode(mode);
    typed = '';
    renderPattern();
    setLocked(true);
  }

  function resetGame(){
    board = createBoard();
    score = 0;
    lines = 0;
    level = 1;
    applyDifficultySpeed();

    lastTime = 0;
    accumulator = 0;

    gameOver = false;
    paused = false;

    current = newPiece(randType());
    next = newPiece(randType());
    drawNext();
    updateHUD();

    held.down = false;

    newUnlockWord();

    if (collides(board, current, 0, 0)) {
      gameOver = true;
      running = false;
      pauseBtn.disabled = true;
    }
    drawBoard();
  }

  function spawnNext(){
    current = next;
    current.x = ((COLS / 2) | 0) - ((current.shape[0].length / 2) | 0);
    current.y = -1;
    next = newPiece(randType());
    drawNext();

    newUnlockWord();

    if (collides(board, current, 0, 0)) {
      gameOver = true;
      running = false;
      pauseBtn.disabled = true;
    }
  }

  function lockPieceAndContinue(){
    merge(board, current);
    const cleared = clearLines(board);
    if (cleared){
      lines += cleared;
      score += scoreForClears(cleared);
      bumpLevelIfNeeded();
    }
    updateHUD();
    spawnNext();
  }

  function stepDownOnce(){
    if (!current || gameOver) return;
    if (!collides(board, current, 0, 1)) {
      current.y += 1;
    } else {
      lockPieceAndContinue();
    }
    drawBoard();
  }

  function tryMove(dx){
    if (!current || paused || gameOver) return;
    if (collides(board, current, dx, 0)) return;
    current.x += dx;
    drawBoard();
  }

  function tryRotate(){
    if (!current || paused || gameOver) return;
    const rotated = rotateMatrixCW(current.shape);
    const kicks = [0, -1, 1, -2, 2];
    for (const k of kicks){
      if (!collides(board, current, k, 0, rotated)){
        current.shape = rotated;
        current.x += k;
        drawBoard();
        return;
      }
    }
  }

  function loop(time=0){
    if (!running){
      drawBoard();
      return;
    }

    const dt = time - lastTime;
    lastTime = time;

    if (!paused && !gameOver){
      const multiplier = held.down ? 10 : 1;
      const effMult = locked ? 1 : multiplier;

      accumulator += dt * effMult;

      while (accumulator >= baseDropMs) {
        accumulator -= baseDropMs;
        stepDownOnce();
        if (gameOver) break;
      }
    }

    requestAnimationFrame(loop);
  }

  // ===== Input handling =====
  window.addEventListener('keydown', (e) => {
    if (e.target === wordInput) return; // allow typing

    const k = e.key;
    const isArrow = (k === 'ArrowUp' || k === 'ArrowDown' || k === 'ArrowLeft' || k === 'ArrowRight');
    if (!isArrow) return;

    e.preventDefault();

    if (!running || paused || gameOver) return;
    if (locked) return; // controls disabled while locked

    if (k === 'ArrowLeft') tryMove(-1);
    if (k === 'ArrowRight') tryMove(1);
    if (k === 'ArrowUp') tryRotate();
    if (k === 'ArrowDown') held.down = true; // soft drop engaged
  }, { passive:false });

  window.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowDown') held.down = false;
  });

  window.addEventListener('blur', () => {
    held.down = false;
  });

  // ===== Typing (unlock) =====
  wordInput.addEventListener('input', () => {
    if (!locked) return;

    let v = wordInput.value.toLowerCase().replace(/[^a-z]/g,'');
    if (v.length > unlockWord.length) v = v.slice(0, unlockWord.length);

    typed = v;
    wordInput.value = v;
    renderPattern();

    const targetPrefix = unlockWord.slice(0, typed.length);
    if (typed !== targetPrefix) {
      typed = '';
      wordInput.value = '';
      renderPattern();

      unlockBox.classList.remove('shake');
      void unlockBox.offsetWidth;
      unlockBox.classList.add('shake');
      return;
    }

    if (typed.length === unlockWord.length) {
      setLocked(false);
    }
  });

  // ===== Buttons =====
  startBtn.addEventListener('click', () => {
    resetGame();
    running = true;
    pauseBtn.disabled = false;
    pauseBtn.textContent = 'Pause';
    requestAnimationFrame(loop);
  });

  pauseBtn.addEventListener('click', () => {
    if (!running || gameOver) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    if (!paused && locked) {
      setTimeout(() => wordInput.focus({preventScroll:true}), 0);
    }
    drawBoard();
  });

  difficultySel.addEventListener('change', () => {
    applyDifficultySpeed();
    if (running && !gameOver) newUnlockWord();
  });

  // ===== Init =====
  function init(){
    buildPoolsFromOrder(fallbackWords);
    loadWords().then(() => {
      if (!running) {
        unlockWord = pickWordForMode(difficultySel.value);
        typed = '';
        renderPattern();
        setLocked(true);
      }
    });

    resetGame();
    drawBoard();
  }
  init();
})();
</script>
</body>
</html>
