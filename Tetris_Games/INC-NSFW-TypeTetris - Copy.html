<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris</title>
  <style>
    :root { --bg:#0b0f14; --panel:#0f1720; --text:#e7eef7; --muted:#9fb0c3; }
    html,body{height:100%;}
    body{
      margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 800px at 30% 20%, #132235 0%, var(--bg) 60%);
      color:var(--text); display:flex; align-items:center; justify-content:center;
    }

    /* Layout: Left panel, game, right panel */
    .wrap{
      display:grid;
      grid-template-columns: 190px auto 260px;
      gap:16px;
      padding:18px;
      background:rgba(15,23,32,.55);
      border:1px solid rgba(255,255,255,.08);
      border-radius:18px;
      box-shadow:0 12px 40px rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
      align-items:start;
    }

    canvas{
      background: linear-gradient(180deg, #071018 0%, #071018 100%);
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      image-rendering: pixelated;
      display:block;
    }

    .side{ display:flex; flex-direction:column; gap:12px; }
    .leftSide{ display:flex; flex-direction:column; gap:12px; align-items:stretch; }

    .card{
      background:rgba(8,12,18,.55);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:12px;
    }
    .title{ font-weight:800; letter-spacing:.2px; font-size:14px; }
    .kpi{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px; }
    .kpi .box{
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.06);
      border-radius:12px; padding:10px;
    }
    .label{ color:var(--muted); font-size:12px; }
    .value{ font-size:18px; font-weight:800; margin-top:2px; }

    .controls{
      font-size:12px; color:var(--muted); line-height:1.5;
      display:grid; grid-template-columns:auto 1fr; gap:6px 10px; margin-top:10px;
    }
    .kbd{
      color:var(--text); font-weight:700; background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10); padding:2px 8px; border-radius:8px;
      display:inline-block; width:max-content;
    }
    .small{ font-size:12px; color:var(--muted); margin-top:8px; line-height:1.45; }

    /* Next preview */
    .miniLabel{ color:var(--muted); font-size:12px; margin-bottom:8px; }
    #nextCanvas{
      width:120px; height:120px;
      border-radius:12px; border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.15);
      display:block;
      margin:0 auto;
    }

    /* Unlocked box */
    .unlockRow{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.06);
    }
    .unlockRow .uLabel{
      color:var(--muted); font-size:12px; font-weight:800; letter-spacing:.2px;
    }
    .unlockRow .uIcon{
      font-weight:900; font-size:16px; line-height:1;
      width:26px; height:26px; display:grid; place-items:center;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.15);
    }
    .uIcon.ok{ color:#6eea7a; border-color:rgba(110,234,122,.35); background:rgba(110,234,122,.12); }
    .uIcon.no{ color:#ff6b6b; border-color:rgba(255,107,107,.35); background:rgba(255,107,107,.10); }

    /* Word + input */
    .wordBox{ margin-top:10px; }
    .wordPrompt{ color:var(--muted); font-size:12px; margin-bottom:8px; line-height:1.35; }
    .progress{
      font-weight:900;
      font-size:18px;
      letter-spacing:2px;
      text-align:center;
      padding:10px 8px;
      border-radius:12px;
      background:rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      user-select:none;
      margin-bottom:10px;
      text-transform:uppercase;
    }
    .typeInput{
      width:100%;
      box-sizing:border-box;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:var(--text);
      outline:none;
      font-weight:800;
      letter-spacing:.6px;
      text-transform:uppercase;
    }
    .typeInput::placeholder{ color:rgba(159,176,195,.7); }
    .typeInput:focus{
      border-color:rgba(61,130,255,.55);
      box-shadow: 0 0 0 3px rgba(61,130,255,.18);
    }
    .hintLine{
      margin-top:8px;
      font-size:12px;
      color:var(--muted);
      line-height:1.35;
    }

    /* Game container & pause overlay */
    .gameHost{
      position:relative;
      width:fit-content;
      height:fit-content;
    }
    .blurred canvas{
      filter: blur(7px);
    }
    .pauseOverlay{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      border-radius:14px;
    }
    .pauseOverlay.show{
      display:flex;
    }
    .pauseOverlay::before{
      content:"";
      position:absolute;
      inset:0;
      border-radius:14px;
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    .menu{
      position:relative;
      width:min(320px, 88%);
      background: rgba(15,23,32,.72);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 18px 60px rgba(0,0,0,.45);
      text-align:center;
    }
    .menu h2{
      margin: 6px 0 12px;
      font-size: 18px;
      letter-spacing: .2px;
    }
    .menu p{
      margin: 0 0 14px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.4;
    }
    .btnRow{
      display:flex;
      gap:10px;
      justify-content:center;
      margin-top:10px;
    }
    .btn{
      appearance:none;
      border:none;
      cursor:pointer;
      padding:10px 14px;
      border-radius:12px;
      font-weight:900;
      letter-spacing:.2px;
      color: var(--text);
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
    }
    .btn:hover{ background: rgba(255,255,255,.12); }
    .btn.primary{
      background: rgba(61,130,255,.22);
      border-color: rgba(61,130,255,.35);
    }
    .btn.primary:hover{ background: rgba(61,130,255,.28); }

    @media (max-width: 980px){
      .wrap{ grid-template-columns: 190px auto; grid-template-rows:auto auto; }
      .side{ grid-column: 1 / -1; }
    }
  </style>
</head>
<body>
  <div class="wrap" id="wrap">
    <!-- LEFT: Next + Unlock -->
    <div class="leftSide">
      <div class="card">
        <div class="title">Next</div>
        <div class="miniLabel">Upcoming piece</div>
        <canvas id="nextCanvas" width="120" height="120"></canvas>

        <div class="unlockRow" aria-live="polite">
          <div class="uLabel">Unlocked</div>
          <div class="uIcon no" id="unlockIcon" title="Locked">✕</div>
        </div>

        <div class="wordBox">
          <div class="wordPrompt">Type the word to unlock controls for this piece:</div>
          <div class="progress" id="wordTarget">WORD</div>
          <div class="progress" id="wordProgress">_ _ _</div>
          <input id="wordInput" class="typeInput" type="text" inputmode="text" autocomplete="off" autocapitalize="off" spellcheck="false" placeholder="Type here…" />
          <div class="hintLine" id="wordHint">Controls are locked until you type it correctly. Press <b>1</b> for the menu.</div>
        </div>
      </div>
    </div>

    <!-- MIDDLE: Game + overlay -->
    <div class="gameHost" id="gameHost">
      <canvas id="game" aria-label="Tetris"></canvas>

      <div class="pauseOverlay" id="pauseOverlay" aria-hidden="true">
        <div class="menu" role="dialog" aria-modal="true" aria-label="Pause menu">
          <h2>Paused</h2>
          <p>Press <b>1</b> again to close this menu.</p>
          <div class="btnRow">
            <button class="btn primary" id="btnResume" type="button">Resume</button>
            <button class="btn" id="btnRestart" type="button">Restart</button>
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT: Stats/controls -->
    <div class="side">
      <div class="card">
        <div class="title">Tetris</div>

        <div class="kpi">
          <div class="box">
            <div class="label">Score</div>
            <div class="value" id="score">0</div>
          </div>
          <div class="box">
            <div class="label">Lines</div>
            <div class="value" id="lines">0</div>
          </div>
          <div class="box">
            <div class="label">Level</div>
            <div class="value" id="level">1</div>
          </div>
          <div class="box">
            <div class="label">State</div>
            <div class="value" id="state">Playing</div>
          </div>
        </div>

        <div class="small">
          <b>↓</b> = soft drop (faster).<br/>
          <b>↑</b> = rotate.<br/>
          <b>Space</b> = hard drop.<br/>
          <b>1</b> = pause menu.<br/>
          <b>Unlock:</b> type the word shown.
        </div>
      </div>

      <div class="card">
        <div class="title">Controls</div>
        <div class="controls">
          <span class="kbd">←</span><span>Move left (unlocked)</span>
          <span class="kbd">→</span><span>Move right (unlocked)</span>
          <span class="kbd">↓</span><span>Soft drop (unlocked)</span>
          <span class="kbd">↑</span><span>Rotate (unlocked)</span>
          <span class="kbd">Space</span><span>Hard drop (unlocked)</span>
          <span class="kbd">1</span><span>Pause menu</span>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const nextCanvas = document.getElementById('nextCanvas');
  const nctx = nextCanvas.getContext('2d');

  const gameHost = document.getElementById('gameHost');
  const pauseOverlay = document.getElementById('pauseOverlay');
  const btnResume = document.getElementById('btnResume');
  const btnRestart = document.getElementById('btnRestart');

  // Unlock UI
  const unlockIcon = document.getElementById('unlockIcon');
  const wordTargetEl = document.getElementById('wordTarget');
  const wordProgressEl = document.getElementById('wordProgress');
  const wordInput = document.getElementById('wordInput');

  const COLS = 10, ROWS = 20;
  const BLOCK = 36;
  const W = COLS * BLOCK, H = ROWS * BLOCK;
  canvas.width = W; canvas.height = H;

  const ui = {
    score: document.getElementById('score'),
    lines: document.getElementById('lines'),
    level: document.getElementById('level'),
    state: document.getElementById('state'),
  };

  let board, current, next;
  let score = 0, lines = 0, level = 1;
  let running = true, paused = false, gameOver = false;
  let pauseMenuOpen = false;

  let dropIntervalMs = 650;
  let lastTime = 0, acc = 0;

  const SOFT_DROP_MS = 60;
  let softDropActive = false;
  let softAcc = 0;

  // ===== Unlock mechanic =====
  const WORDS = [
    "able","acid","also","area","army","away","baby","back","ball","bank",
    "base","bath","bear","beat","been","beer","bell","belt","best","bike",
    "bill","bird","blow","blue","boat","body","bone","book","born","boss",
    "both","bowl","busy","call","calm","came","camp","card","care","case",
    "cash","cell","chat","chip","city","club","coal","coat","code","cold",
    "come","cook","cool","copy","cost","crew","crop","dark","data","date",
    "deal","dear","deep","desk","dial","dirt","dish","dive","does","done",
    "door","down","draw","drop","each","earn","easy","edge","else","even",
    "ever","fact","fade","fair","fall","farm","fast","feed","feel","file",
    "fill","film","find","fire","fish","five","flat","flip","flow","food",
    "frog","game","gold","grab","gray","grow","hang","hard","have","help",
    "hope","idea","into","iron","join","jump","just","keep","kick","kind"
  ];

  let controlsUnlocked = false;
  let targetWord = "";
  let typedIndex = 0;

  function pickRandomWord() {
    return WORDS[(Math.random() * WORDS.length) | 0].toUpperCase();
  }

  function setUnlockedState(unlocked) {
    controlsUnlocked = unlocked;
    unlockIcon.classList.toggle('ok', unlocked);
    unlockIcon.classList.toggle('no', !unlocked);
    unlockIcon.textContent = unlocked ? '✓' : '✕';
    unlockIcon.title = unlocked ? 'Unlocked' : 'Locked';
  }

  function renderProgress() {
    if (!targetWord) {
      wordProgressEl.textContent = "_ _ _";
      return;
    }
    const chars = [];
    for (let i = 0; i < targetWord.length; i++) {
      chars.push(i < typedIndex ? targetWord[i] : "_");
    }
    wordProgressEl.textContent = chars.join(" ");
  }

  function focusWordInput() {
    if (pauseMenuOpen) return;
    setTimeout(() => wordInput && wordInput.focus(), 0);
  }

  function resetTypingSameWord() {
    typedIndex = 0;
    wordInput.value = "";
    renderProgress();
    setUnlockedState(false);
    focusWordInput();
  }

  function newWordForPiece() {
    targetWord = pickRandomWord();
    typedIndex = 0;
    wordInput.value = "";
    if (wordTargetEl) wordTargetEl.textContent = targetWord;
    renderProgress();
    setUnlockedState(false);
    focusWordInput();
  }
  // ==========================

  const PIECES = [
    { id: 1, color: '#58d9ff', m: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]] },
    { id: 2, color: '#ffd34d', m: [[1,1],[1,1]] },
    { id: 3, color: '#b889ff', m: [[0,1,0],[1,1,1],[0,0,0]] },
    { id: 4, color: '#6eea7a', m: [[0,1,1],[1,1,0],[0,0,0]] },
    { id: 5, color: '#ff6b6b', m: [[1,1,0],[0,1,1],[0,0,0]] },
    { id: 6, color: '#5aa7ff', m: [[1,0,0],[1,1,1],[0,0,0]] },
    { id: 7, color: '#ffa24d', m: [[0,0,1],[1,1,1],[0,0,0]] },
  ];

  const COLORS = {
    0: '#00000000',
    1: PIECES[0].color, 2: PIECES[1].color, 3: PIECES[2].color, 4: PIECES[3].color,
    5: PIECES[4].color, 6: PIECES[5].color, 7: PIECES[6].color,
  };

  const createBoard = () => Array.from({length: ROWS}, () => Array(COLS).fill(0));
  const cloneMatrix = (m) => m.map(r => r.slice());

  function topOccupiedRow(m) {
    for (let y = 0; y < m.length; y++) {
      for (let x = 0; x < m[y].length; x++) {
        if (m[y][x]) return y;
      }
    }
    return 0;
  }

  function randomPiece() {
    const p = PIECES[(Math.random() * PIECES.length) | 0];
    const m = cloneMatrix(p.m);
    const top = topOccupiedRow(m);
    const spawnY = -top;

    return {
      id: p.id,
      m,
      x: ((COLS / 2) | 0) - ((m[0].length / 2) | 0),
      y: spawnY,
    };
  }

  function collides(piece, offX = 0, offY = 0, testMatrix = piece.m) {
    for (let y = 0; y < testMatrix.length; y++) {
      for (let x = 0; x < testMatrix[y].length; x++) {
        if (!testMatrix[y][x]) continue;
        const bx = piece.x + x + offX;
        const by = piece.y + y + offY;

        if (bx < 0 || bx >= COLS || by >= ROWS) return true;
        if (by >= 0 && board[by][bx]) return true;
      }
    }
    return false;
  }

  function merge(piece) {
    for (let y = 0; y < piece.m.length; y++) {
      for (let x = 0; x < piece.m[y].length; x++) {
        if (!piece.m[y][x]) continue;
        const by = piece.y + y, bx = piece.x + x;
        if (by >= 0 && by < ROWS && bx >= 0 && bx < COLS) board[by][bx] = piece.id;
      }
    }
  }

  function clearLines() {
    let cleared = 0;
    for (let y = ROWS - 1; y >= 0; y--) {
      let full = true;
      for (let x = 0; x < COLS; x++) { if (!board[y][x]) { full = false; break; } }
      if (full) {
        cleared++;
        board.splice(y, 1);
        board.unshift(Array(COLS).fill(0));
        y++;
      }
    }

    if (cleared) {
      const table = [0,100,300,500,800];
      score += (table[cleared] || cleared * 200) * level;
      lines += cleared;

      const newLevel = 1 + ((lines / 10) | 0);
      if (newLevel !== level) {
        level = newLevel;
        dropIntervalMs = Math.max(120, 650 - (level - 1) * 45);
      }
      updateUI();
    }
  }

  function rotateMatrixCW(m) {
    const h = m.length, w = m[0].length;
    const out = Array.from({length: w}, () => Array(h).fill(0));
    for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) out[x][h - 1 - y] = m[y][x];
    return out;
  }

  function tryRotate() {
    if (!controlsUnlocked) return;
    const rotated = rotateMatrixCW(current.m);
    const kicks = [0, -1, 1, -2, 2];
    for (const k of kicks) {
      if (!collides(current, k, 0, rotated)) {
        current.m = rotated;
        current.x += k;
        return;
      }
    }
  }

  function move(dx) {
    if (!running || paused || gameOver) return;
    if (!controlsUnlocked) return;
    if (!collides(current, dx, 0)) current.x += dx;
  }

  function spawnNext() {
    current = next || randomPiece();
    next = randomPiece();
    drawNext();

    // New word per piece
    newWordForPiece();

    if (collides(current, 0, 0)) {
      running = false;
      gameOver = true;
      ui.state.textContent = 'Game Over';
      updateUI();
    }
  }

  function stepDown() {
    if (collides(current, 0, 1)) {
      merge(current);
      clearLines();
      spawnNext();
      return false;
    } else {
      current.y += 1;
      return true;
    }
  }

  function hardDrop() {
    if (!running || paused || gameOver) return;
    if (!controlsUnlocked) return;
    while (stepDown()) {}
  }

  function getGhostPiece() {
    if (!current) return null;
    const g = { id: current.id, m: current.m, x: current.x, y: current.y };
    while (!collides(g, 0, 1, g.m)) g.y += 1;
    return g;
  }

  function drawCell(x, y, id, alpha = 1) {
    if (!id) return;
    const pad = Math.max(2, Math.floor(BLOCK * 0.07));
    const px = x * BLOCK, py = y * BLOCK;

    ctx.globalAlpha = alpha;
    ctx.fillStyle = COLORS[id];
    ctx.fillRect(px + pad, py + pad, BLOCK - pad*2, BLOCK - pad*2);

    if (alpha >= 0.9) {
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(px + pad + 2, py + pad + 2, BLOCK - pad*2 - 6, Math.max(3, (BLOCK - pad*2) * 0.22));
    }
    ctx.globalAlpha = 1;
  }

  function drawGrid() {
    ctx.clearRect(0, 0, W, H);

    for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) drawCell(x, y, board[y][x]);

    const ghost = getGhostPiece();
    if (ghost) {
      for (let y = 0; y < ghost.m.length; y++) {
        for (let x = 0; x < ghost.m[y].length; x++) {
          if (!ghost.m[y][x]) continue;
          const bx = ghost.x + x, by = ghost.y + y;
          if (by < 0 || by >= ROWS || bx < 0 || bx >= COLS) continue;
          drawCell(bx, by, ghost.id, 0.18);
          ctx.globalAlpha = 0.45;
          ctx.strokeStyle = COLORS[ghost.id];
          ctx.lineWidth = 2;
          ctx.strokeRect(bx * BLOCK + 4, by * BLOCK + 4, BLOCK - 8, BLOCK - 8);
          ctx.globalAlpha = 1;
        }
      }
    }

    if (current) {
      for (let y = 0; y < current.m.length; y++) {
        for (let x = 0; x < current.m[y].length; x++) {
          if (!current.m[y][x]) continue;
          const bx = current.x + x, by = current.y + y;
          if (by < 0 || by >= ROWS || bx < 0 || bx >= COLS) continue;
          drawCell(bx, by, current.id, 1);
        }
      }
    }

    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = '#ffffff';
    for (let x = 1; x < COLS; x++) {
      ctx.beginPath(); ctx.moveTo(x * BLOCK, 0); ctx.lineTo(x * BLOCK, H); ctx.stroke();
    }
    for (let y = 1; y < ROWS; y++) {
      ctx.beginPath(); ctx.moveTo(0, y * BLOCK); ctx.lineTo(W, y * BLOCK); ctx.stroke();
    }
    ctx.globalAlpha = 1;

    if (gameOver) {
      ctx.globalAlpha = 0.62;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);
      ctx.globalAlpha = 1;

      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      ctx.fillStyle = '#ffffff';
      ctx.font = `900 ${Math.floor(BLOCK*0.95)}px system-ui`;
      ctx.fillText('GAME OVER', W/2, H/2 - BLOCK*0.3);

      ctx.globalAlpha = 0.9;
      ctx.font = `700 ${Math.floor(BLOCK*0.45)}px system-ui`;
      ctx.fillText('Press 1 for menu', W/2, H/2 + BLOCK*0.65);
      ctx.globalAlpha = 1;
    }
  }

  function updateUI() {
    ui.score.textContent = String(score);
    ui.lines.textContent = String(lines);
    ui.level.textContent = String(level);
    if (gameOver) ui.state.textContent = 'Game Over';
    else if (!running) ui.state.textContent = 'Ready';
    else if (paused) ui.state.textContent = 'Paused';
    else ui.state.textContent = 'Playing';
  }

  function drawNext() {
    nctx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
    if (!next) return;

    const m = next.m;
    const size = Math.max(m.length, m[0].length);

    const pad = 10;
    const usable = Math.min(nextCanvas.width, nextCanvas.height) - pad * 2;
    const cell = Math.floor(usable / size);

    const drawW = cell * m[0].length;
    const drawH = cell * m.length;
    const offsetX = Math.floor((nextCanvas.width - drawW) / 2);
    const offsetY = Math.floor((nextCanvas.height - drawH) / 2);

    for (let y = 0; y < m.length; y++) {
      for (let x = 0; x < m[y].length; x++) {
        if (!m[y][x]) continue;

        const px = offsetX + x * cell;
        const py = offsetY + y * cell;

        nctx.fillStyle = COLORS[next.id];
        nctx.fillRect(px + 1, py + 1, cell - 2, cell - 2);

        nctx.globalAlpha = 0.18;
        nctx.fillStyle = '#ffffff';
        nctx.fillRect(px + 3, py + 3, Math.max(2, cell - 8), Math.max(2, (cell - 2) * 0.22));
        nctx.globalAlpha = 1;
      }
    }
  }

  function setPauseMenu(open) {
    pauseMenuOpen = open;
    paused = open;
    pauseOverlay.classList.toggle('show', open);
    gameHost.classList.toggle('blurred', open);
    pauseOverlay.setAttribute('aria-hidden', open ? 'false' : 'true');
    updateUI();

    if (open) {
      softDropActive = false;
      softAcc = 0;
      btnResume.focus();
    } else {
      focusWordInput();
    }
  }

  function loop(t) {
    const dt = t - lastTime;
    lastTime = t;

    if (running && !paused && !gameOver) {
      acc += dt;
      while (acc >= dropIntervalMs) {
        acc -= dropIntervalMs;
        stepDown();
        if (gameOver) break;
      }

      if (controlsUnlocked && softDropActive) {
        softAcc += dt;
        while (softAcc >= SOFT_DROP_MS) {
          softAcc -= SOFT_DROP_MS;
          stepDown();
          if (gameOver) break;
        }
      } else {
        softAcc = 0;
      }
    }

    drawGrid();
    requestAnimationFrame(loop);
  }

  // Dedicated input: accept typing + handle lock/unlock
  wordInput.addEventListener('keydown', (e) => {
    if (pauseMenuOpen) return;

    if (e.key === 'Backspace') {
      e.preventDefault();
      resetTypingSameWord();
      return;
    }

    if (e.key.length !== 1) return;
    const ch = e.key.toUpperCase();

    if (!/[A-Z]/.test(ch)) {
      e.preventDefault();
      return;
    }

    e.preventDefault();

    if (controlsUnlocked) return;

    const expected = targetWord[typedIndex];
    if (ch === expected) {
      typedIndex++;
      renderProgress();
      if (typedIndex >= targetWord.length) {
        setUnlockedState(true);
      }
    } else {
      resetTypingSameWord();
    }
  });

  wordInput.addEventListener('blur', () => {
    if (!pauseMenuOpen) focusWordInput();
  });

  window.addEventListener('keydown', (e) => {
    const k = e.key;

    if (k === '1') {
      e.preventDefault();
      setPauseMenu(!pauseMenuOpen);
      return;
    }

    if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown',' '].includes(k)) e.preventDefault();

    if (pauseMenuOpen) return;

    if (!controlsUnlocked) {
      focusWordInput();
      return;
    }

    if (!running || paused || gameOver) return;

    if (k === 'ArrowLeft') move(-1);
    else if (k === 'ArrowRight') move(1);
    else if (k === 'ArrowDown') {
      softDropActive = true;
      stepDown();
    }
    else if (k === 'ArrowUp') {
      if (e.repeat) return;
      tryRotate();
    }
    else if (k === ' ') hardDrop();
  }, { passive: false });

  window.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowDown') {
      softDropActive = false;
      softAcc = 0;
    }
  });

  btnResume.addEventListener('click', () => setPauseMenu(false));
  btnRestart.addEventListener('click', () => {
    restart();
    setPauseMenu(false);
  });

  pauseOverlay.addEventListener('click', (e) => {
    e.stopPropagation();
  });

  function restart() {
    board = createBoard();
    score = 0; lines = 0; level = 1;
    dropIntervalMs = 650;

    running = true;
    paused = false;
    gameOver = false;

    softDropActive = false;
    softAcc = 0;

    next = randomPiece();
    spawnNext();
    acc = 0;
    updateUI();
  }

  function init() {
    restart();
    drawNext();
    requestAnimationFrame(loop);
  }

  init();
})();
</script>
</body>
</html>
