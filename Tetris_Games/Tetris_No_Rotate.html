<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>No-Rotate Tetris (7-Bag + Random Orientation + Skip)</title>
  <style>
    :root{
      --bg:#0f1220;--text:#e9ecff;--muted:#aab1dd;--line:rgba(255,255,255,.08);
      --shadow:0 10px 30px rgba(0,0,0,.35);--radius:16px
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:radial-gradient(1200px 600px at 20% 10%, #1d2450 0%, var(--bg) 55%, #070913 100%);
      color:var(--text);
      min-height:100vh;
      display:grid;
      place-items:center;
      padding:14px;
    }
    .wrap{display:grid;gap:14px;width:min(980px,100%)}

    /* Zoom-out / fit fix */
    .scale{
      width:100%;
      transform-origin: top center;
      transform: scale(var(--ui-scale, 1));
    }

    .top{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    h1{margin:0;font-size:18px;font-weight:700;letter-spacing:.2px}
    .hint{color:var(--muted);font-size:13px;line-height:1.25}
    .layout{display:grid;grid-template-columns:1fr;gap:14px}
    @media (min-width: 820px){.layout{grid-template-columns:1fr 300px}}

    .card{
      background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.015));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }

    /* GAME AREA: add a left mini column beside the board */
    .game{
      padding:14px;
      display:grid;
      grid-template-columns: 160px 1fr;
      gap:12px;
      align-items:start;
    }
    @media (max-width: 560px){
      .game{
        grid-template-columns: 1fr;
      }
    }

    canvas#c{
      width:100%;
      height:auto;
      max-width:520px;
      aspect-ratio:10/20;
      background:#070a14;
      border-radius:14px;
      border:1px solid var(--line);
      display:block;
      margin-inline:auto;
    }

    .side{padding:14px;display:grid;gap:12px}

    .stat{
      background:rgba(0,0,0,.18);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
    }
    .stat h2{
      margin:0 0 6px;
      font-size:12px;
      color:var(--muted);
      font-weight:600;
      letter-spacing:.3px;
      text-transform:uppercase;
    }
    .stat .val{font-size:22px;font-weight:800;letter-spacing:.4px}
    .mini{display:grid;grid-template-columns:1fr 1fr;gap:12px}

    .btns{display:flex;gap:10px;flex-wrap:wrap}
    button{
      appearance:none;border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;border-radius:12px;
      font-weight:700;cursor:pointer;
      transition:transform .05s ease,background .2s ease;
      user-select:none;
    }
    button:hover{background:rgba(255,255,255,.09)}
    button:active{transform:translateY(1px)}
    button:disabled{opacity:.55;cursor:not-allowed}

    .badge{
      display:inline-block;padding:4px 10px;border-radius:999px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
      color:var(--muted);
      font-size:12px;font-weight:600;
    }
    .footer{color:var(--muted);font-size:12px;line-height:1.35;padding:0 2px}
    .kbd{
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
      font-size:12px;padding:2px 6px;border-radius:6px;
      border:1px solid var(--line);background:rgba(0,0,0,.2);color:var(--text);
    }

    /* LEFT SKIP INDICATOR */
    .leftHud{
      display:grid;
      gap:12px;
      align-content:start;
      justify-items:stretch;
    }
    .skipBig{
      border-radius:14px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
      padding:12px;
      box-shadow: 0 8px 18px rgba(0,0,0,.25);
    }
    .skipBigTitle{
      font-size:12px;
      color:var(--muted);
      font-weight:800;
      letter-spacing:.35px;
      text-transform:uppercase;
      margin:0 0 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .skipBigKey{
      font-size:12px;
      font-weight:800;
      color:rgba(255,255,255,.85);
      border:1px solid var(--line);
      padding:2px 8px;
      border-radius:999px;
      background:rgba(255,255,255,.04);
    }
    .skipBigBox{
      width:100%;
      aspect-ratio: 1 / 1;
      border-radius:14px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      display:grid;
      place-items:center;
    }
    .skipBigMark{
      font-size:72px;
      line-height:1;
      font-weight:900;
      user-select:none;
      filter: drop-shadow(0 6px 12px rgba(0,0,0,.35));
    }
    .skipBigSub{
      margin-top:10px;
      color:var(--muted);
      font-size:12px;
      line-height:1.25;
    }
    .mark-ok{ color: #35ff83; }
    .mark-no{ color: #ff4a4a; }
  </style>
</head>
<body>
  <div class="wrap scale" id="scaleWrap">
    <div class="top">
      <div>
        <h1>No-Rotate Tetris (7-Bag + Random Orientation + Skip)</h1>
        <div class="hint">
          Move: <span class="kbd">‚Üê</span>/<span class="kbd">‚Üí</span> ‚Ä¢ Soft drop: <span class="kbd">‚Üì</span> ‚Ä¢ Hard drop: <span class="kbd">Space</span> ‚Ä¢ Pause: <span class="kbd">P</span> ‚Ä¢ Restart: <span class="kbd">R</span> ‚Ä¢ Skip: <span class="kbd">S</span><br>
          <span class="badge">Rotation disabled</span> ‚Ä¢ <span class="badge">7-bag randomizer</span> ‚Ä¢ <span class="badge">Skip once every 3 turns</span>
        </div>
      </div>
      <div class="btns">
        <button id="btnPause" type="button">Pause (P)</button>
        <button id="btnRestart" type="button">Restart (R)</button>
        <button id="btnSkip" type="button">Skip (S)</button>
      </div>
    </div>

    <div class="layout">
      <div class="card game">
        <!-- LEFT SIDE HUD -->
        <div class="leftHud">
          <div class="skipBig" aria-label="Skip indicator">
            <div class="skipBigTitle">
              <span>Skip</span>
              <span class="skipBigKey">S</span>
            </div>
            <div class="skipBigBox">
              <div id="skipBigMark" class="skipBigMark mark-ok">‚úì</div>
            </div>
            <div id="skipBigSub" class="skipBigSub">Ready</div>
          </div>

          <div class="footer" style="padding:0">
            Skip rule: after skipping, you must lock <b>3 pieces</b> before you can skip again.
          </div>
        </div>

        <!-- BOARD -->
        <div>
          <canvas id="c" width="300" height="600" aria-label="Tetris game board"></canvas>
          <div class="footer">
            Tip: Since you can‚Äôt rotate, try ‚Äúplanning‚Äù around whatever orientation you‚Äôre given. üôÇ
          </div>
        </div>
      </div>

      <div class="card side">
        <div class="stat">
          <h2>Next</h2>
          <canvas id="next" width="160" height="160" style="aspect-ratio:1/1; max-width: 220px;"></canvas>
          <div class="hint">Next is drawn from the same shuffled 7-bag (with random orientation).</div>
        </div>

        <div class="mini">
          <div class="stat">
            <h2>Score</h2>
            <div class="val" id="score">0</div>
          </div>
          <div class="stat">
            <h2>Lines</h2>
            <div class="val" id="lines">0</div>
          </div>
        </div>

        <div class="stat">
          <h2>Level</h2>
          <div class="val" id="level">1</div>
          <div class="hint">Speed increases every 10 lines.</div>
        </div>

        <div class="stat">
          <h2>Skip</h2>
          <div class="val" id="skipStatus">Ready</div>
          <div class="hint" id="skipHint">You may skip now. Then wait 3 locked pieces.</div>
        </div>

        <div class="stat">
          <h2>Rules</h2>
          <div class="hint">
            - No piece rotation (ever).<br>
            - 7-bag randomizer (fair distribution).<br>
            - Each spawned piece gets a random orientation.<br>
            - Press <span class="kbd">S</span> to skip (cooldown: 3 turns).
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ====== Config ======
  const COLS = 10;
  const ROWS = 20;
  const CELL = 30;
  const PREVIEW_CELL = 20;

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const nextCanvas = document.getElementById('next');
  const nctx = nextCanvas.getContext('2d');

  const scoreEl = document.getElementById('score');
  const linesEl = document.getElementById('lines');
  const levelEl = document.getElementById('level');

  const btnPause = document.getElementById('btnPause');
  const btnRestart = document.getElementById('btnRestart');
  const btnSkip = document.getElementById('btnSkip');

  const skipStatusEl = document.getElementById('skipStatus');
  const skipHintEl = document.getElementById('skipHint');

  // Big left indicator elements
  const skipBigMarkEl = document.getElementById('skipBigMark');
  const skipBigSubEl  = document.getElementById('skipBigSub');

  const COLORS = {
    I: '#3bd6ff',
    O: '#ffd85a',
    T: '#b58bff',
    S: '#5dff9b',
    Z: '#ff5d7a',
    J: '#5a7bff',
    L: '#ffb35a',
    line: 'rgba(255,255,255,0.10)',
  };

  const SHAPES = {
    I: [
      [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
      [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]],
    ],
    O: [
      [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
    ],
    T: [
      [[0,1,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
      [[0,1,0,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]],
      [[0,0,0,0],[1,1,1,0],[0,1,0,0],[0,0,0,0]],
      [[0,1,0,0],[1,1,0,0],[0,1,0,0],[0,0,0,0]],
    ],
    S: [
      [[0,1,1,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]],
      [[0,1,0,0],[0,1,1,0],[0,0,1,0],[0,0,0,0]],
    ],
    Z: [
      [[1,1,0,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
      [[0,0,1,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]],
    ],
    J: [
      [[1,0,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
      [[0,1,1,0],[0,1,0,0],[0,1,0,0],[0,0,0,0]],
      [[0,0,0,0],[1,1,1,0],[0,0,1,0],[0,0,0,0]],
      [[0,1,0,0],[0,1,0,0],[1,1,0,0],[0,0,0,0]],
    ],
    L: [
      [[0,0,1,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
      [[0,1,0,0],[0,1,0,0],[0,1,1,0],[0,0,0,0]],
      [[0,0,0,0],[1,1,1,0],[1,0,0,0],[0,0,0,0]],
      [[1,1,0,0],[0,1,0,0],[0,1,0,0],[0,0,0,0]],
    ],
  };

  const PIECE_KEYS = Object.keys(SHAPES);

  // ====== 7-Bag Randomizer ======
  let bag = [];
  function shuffleInPlace(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
  function refillBagIfNeeded() { if (bag.length === 0) bag = shuffleInPlace(PIECE_KEYS.slice()); }
  function drawFromBag() { refillBagIfNeeded(); return bag.pop(); }

  // ====== Helpers ======
  const randInt = (n) => Math.floor(Math.random() * n);
  const cloneMatrix = (m) => m.map(row => row.slice());
  const makeEmptyBoard = () => Array.from({ length: ROWS }, () => Array(COLS).fill(null));

  function forEachCell(mat, fn) {
    for (let y = 0; y < mat.length; y++) {
      for (let x = 0; x < mat[y].length; x++) {
        if (mat[y][x]) fn(x, y);
      }
    }
  }

  function getBounds(mat) {
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    forEachCell(mat, (x,y) => {
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
    });
    if (!isFinite(minX)) return { minX:0, minY:0, w:0, h:0 };
    return { minX, minY, w: (maxX-minX+1), h: (maxY-minY+1) };
  }

  function createPieceFromType(type) {
    const orientations = SHAPES[type];
    const oIndex = randInt(orientations.length);
    const shape = cloneMatrix(orientations[oIndex]);
    const b = getBounds(shape);
    const x = Math.floor((COLS - b.w) / 2) - b.minX;
    const y = -b.minY;
    return { type, shape, x, y };
  }

  function createNextPiece() {
    const type = drawFromBag();
    return createPieceFromType(type);
  }

  function canPlace(board, piece, dx=0, dy=0) {
    const nx = piece.x + dx;
    const ny = piece.y + dy;
    let ok = true;
    forEachCell(piece.shape, (cx, cy) => {
      const x = nx + cx;
      const y = ny + cy;
      if (x < 0 || x >= COLS || y >= ROWS) { ok = false; return; }
      if (y < 0) return;
      if (board[y][x]) { ok = false; return; }
    });
    return ok;
  }

  function lockPiece(board, piece) {
    forEachCell(piece.shape, (cx, cy) => {
      const x = piece.x + cx;
      const y = piece.y + cy;
      if (y >= 0 && y < ROWS && x >= 0 && x < COLS) board[y][x] = piece.type;
    });
  }

  function clearLines(board) {
    let cleared = 0;
    for (let y = ROWS - 1; y >= 0; y--) {
      if (board[y].every(cell => cell)) {
        board.splice(y, 1);
        board.unshift(Array(COLS).fill(null));
        cleared++;
        y++;
      }
    }
    return cleared;
  }

  function calcScore(linesCleared, level) {
    const table = [0, 100, 300, 500, 800];
    return (table[linesCleared] || 0) * level;
  }

  function dropIntervalMs(level) { return Math.max(90, 700 - (level - 1) * 60); }

  function drawCell(context, x, y, size, color) {
    context.fillStyle = color;
    context.fillRect(x, y, size, size);

    context.strokeStyle = 'rgba(255,255,255,0.18)';
    context.lineWidth = 1;
    context.strokeRect(x + 0.5, y + 0.5, size - 1, size - 1);

    context.strokeStyle = 'rgba(0,0,0,0.35)';
    context.beginPath();
    context.moveTo(x + 0.5, y + size - 0.5);
    context.lineTo(x + size - 0.5, y + size - 0.5);
    context.lineTo(x + size - 0.5, y + 0.5);
    context.stroke();
  }

  function overlay(text) {
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#ffffff';
    ctx.font = '800 34px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, canvas.width/2, canvas.height/2);
    ctx.font = '600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.fillText('Press R to restart', canvas.width/2, canvas.height/2 + 36);
  }

  function drawBoard() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#070a14';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.strokeStyle = COLORS.line;
    ctx.lineWidth = 1;
    for (let x = 0; x <= COLS; x++) {
      ctx.beginPath();
      ctx.moveTo(x*CELL + 0.5, 0);
      ctx.lineTo(x*CELL + 0.5, ROWS*CELL);
      ctx.stroke();
    }
    for (let y = 0; y <= ROWS; y++) {
      ctx.beginPath();
      ctx.moveTo(0, y*CELL + 0.5);
      ctx.lineTo(COLS*CELL, y*CELL + 0.5);
      ctx.stroke();
    }

    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const t = board[y][x];
        if (t) drawCell(ctx, x*CELL, y*CELL, CELL, COLORS[t]);
      }
    }

    if (!gameOver && current) {
      const ghost = { ...current };
      while (canPlace(board, ghost, 0, 1)) ghost.y += 1;
      ctx.globalAlpha = 0.25;
      forEachCell(ghost.shape, (cx, cy) => {
        const gx = ghost.x + cx;
        const gy = ghost.y + cy;
        if (gy >= 0) drawCell(ctx, gx*CELL, gy*CELL, CELL, COLORS[ghost.type]);
      });
      ctx.globalAlpha = 1;
    }

    if (!gameOver && current) {
      forEachCell(current.shape, (cx, cy) => {
        const x = current.x + cx;
        const y = current.y + cy;
        if (y >= 0) drawCell(ctx, x*CELL, y*CELL, CELL, COLORS[current.type]);
      });
    }

    if (paused) overlay("Paused");
    if (gameOver) overlay("Game Over");
  }

  function drawNext() {
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    nctx.fillStyle = 'rgba(0,0,0,0.20)';
    nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);

    nctx.strokeStyle = 'rgba(255,255,255,0.08)';
    for (let i=0;i<=8;i++){
      nctx.beginPath();
      nctx.moveTo(i*PREVIEW_CELL + 0.5, 0);
      nctx.lineTo(i*PREVIEW_CELL + 0.5, 8*PREVIEW_CELL);
      nctx.stroke();
      nctx.beginPath();
      nctx.moveTo(0, i*PREVIEW_CELL + 0.5);
      nctx.lineTo(8*PREVIEW_CELL, i*PREVIEW_CELL + 0.5);
      nctx.stroke();
    }

    if (!nextPiece) return;

    const b = getBounds(nextPiece.shape);
    const offsetX = Math.floor((8 - b.w)/2) - b.minX;
    const offsetY = Math.floor((8 - b.h)/2) - b.minY;

    forEachCell(nextPiece.shape, (cx, cy) => {
      const x = (offsetX + cx) * PREVIEW_CELL;
      const y = (offsetY + cy) * PREVIEW_CELL;
      drawCell(nctx, x, y, PREVIEW_CELL, COLORS[nextPiece.type]);
    });
  }

  // ====== Skip System ======
  let skipCooldown = 0; // 0 = ready, else turns remaining (locked pieces) until ready

  function updateSkipUI() {
    const ready = (skipCooldown === 0);

    // Right-side text
    if (ready) {
      skipStatusEl.textContent = "Ready";
      skipHintEl.textContent = "You may skip now. Then wait 3 locked pieces.";
      btnSkip.disabled = false;
    } else {
      skipStatusEl.textContent = `${skipCooldown} turn${skipCooldown===1?"":"s"} left`;
      skipHintEl.textContent = "Cooldown decreases when you lock a piece (place it).";
      btnSkip.disabled = true;
    }

    // Left big indicator
    skipBigMarkEl.textContent = ready ? "‚úì" : "‚úó";
    skipBigMarkEl.classList.toggle("mark-ok", ready);
    skipBigMarkEl.classList.toggle("mark-no", !ready);
    skipBigSubEl.textContent = ready ? "Ready" : `Wait: ${skipCooldown}`;
  }

  function onPieceLocked() {
    if (skipCooldown > 0) skipCooldown -= 1;
    updateSkipUI();
  }

  function skipPiece() {
    if (paused || gameOver) return;
    if (skipCooldown !== 0) return;

    skipCooldown = 3;   // must lock 3 pieces before ready again
    spawnNext();
    updateSkipUI();
  }

  // ====== Game state ======
  let board, current, nextPiece;
  let score = 0;
  let lines = 0;
  let level = 1;
  let dropTimer = 0;
  let lastTime = 0;
  let paused = false;
  let gameOver = false;

  function updateHUD() {
    scoreEl.textContent = String(score);
    linesEl.textContent = String(lines);
    levelEl.textContent = String(level);
    updateSkipUI();
  }

  function resetGame() {
    bag = [];
    board = makeEmptyBoard();
    score = 0;
    lines = 0;
    level = 1;
    paused = false;
    gameOver = false;

    skipCooldown = 0;

    current = createNextPiece();
    nextPiece = createNextPiece();

    if (!canPlace(board, current, 0, 0)) gameOver = true;

    dropTimer = 0;
    lastTime = performance.now();

    btnPause.textContent = "Pause (P)";
    drawNext();
    updateHUD();
    drawBoard();
  }

  function spawnNext() {
    current = nextPiece;
    nextPiece = createNextPiece();
    drawNext();
    if (!canPlace(board, current, 0, 0)) gameOver = true;
  }

  function lockAndAdvance() {
    lockPiece(board, current);
    onPieceLocked();

    const cleared = clearLines(board);
    if (cleared) {
      score += calcScore(cleared, level);
      lines += cleared;
      const newLevel = Math.floor(lines / 10) + 1;
      if (newLevel !== level) level = newLevel;
    }

    updateHUD();
    spawnNext();
  }

  function stepDown() {
    if (paused || gameOver) return;
    if (canPlace(board, current, 0, 1)) current.y += 1;
    else lockAndAdvance();
  }

  function hardDrop() {
    if (paused || gameOver) return;
    let moved = 0;
    while (canPlace(board, current, 0, 1)) { current.y += 1; moved++; }
    score += moved * 2;
    updateHUD();
    lockAndAdvance();
  }

  // ====== Input ======
  const keys = new Set();
  let moveRepeatDelay = 120;
  let moveRepeatTimer = 0;
  let lastMoveDir = 0;

  function onKeyDown(e) {
    if (["ArrowLeft","ArrowRight","ArrowDown","Space"].includes(e.code)) e.preventDefault();

    if (e.code === "KeyP") { togglePause(); return; }
    if (e.code === "KeyR") { resetGame(); return; }
    if (e.code === "KeyS") { skipPiece(); return; }

    // Rotation disabled
    if (["ArrowUp","KeyX","KeyZ"].includes(e.code)) return;

    keys.add(e.code);
    if (paused || gameOver) return;

    if (e.code === "ArrowLeft") tryMove(-1);
    else if (e.code === "ArrowRight") tryMove(1);
    else if (e.code === "ArrowDown") {
      if (canPlace(board, current, 0, 1)) {
        current.y += 1;
        score += 1;
        updateHUD();
      }
    } else if (e.code === "Space") {
      hardDrop();
    }
  }

  function onKeyUp(e) {
    keys.delete(e.code);
    if (e.code === "ArrowLeft" && lastMoveDir === -1) lastMoveDir = 0;
    if (e.code === "ArrowRight" && lastMoveDir === 1) lastMoveDir = 0;
  }

  function tryMove(dir) {
    if (canPlace(board, current, dir, 0)) {
      current.x += dir;
      lastMoveDir = dir;
      moveRepeatTimer = 0;
    }
  }

  function togglePause() {
    if (gameOver) return;
    paused = !paused;
    btnPause.textContent = paused ? "Resume (P)" : "Pause (P)";
    drawBoard();
  }

  btnPause.addEventListener('click', togglePause);
  btnRestart.addEventListener('click', resetGame);
  btnSkip.addEventListener('click', skipPiece);

  window.addEventListener('keydown', onKeyDown, { passive:false });
  window.addEventListener('keyup', onKeyUp);

  // ====== Fit / Zoom-out Logic ======
  function applyScaleToFit() {
    const wrap = document.getElementById('scaleWrap');
    wrap.style.setProperty('--ui-scale', 1);
    const rect = wrap.getBoundingClientRect();
    const pad = 14;
    const availableH = window.innerHeight - pad * 2;

    if (rect.height <= availableH) {
      wrap.style.setProperty('--ui-scale', 1);
      return;
    }
    const s = Math.max(0.75, Math.min(1, availableH / rect.height));
    wrap.style.setProperty('--ui-scale', s.toFixed(3));
  }
  window.addEventListener('resize', applyScaleToFit);

  // ====== Main loop ======
  function loop(time) {
    const dt = time - lastTime;
    lastTime = time;

    if (!paused && !gameOver) {
      dropTimer += dt;
      const interval = dropIntervalMs(level);
      if (dropTimer >= interval) {
        dropTimer = 0;
        stepDown();
      }

      moveRepeatTimer += dt;
      const leftHeld = keys.has("ArrowLeft");
      const rightHeld = keys.has("ArrowRight");
      const dir = leftHeld && !rightHeld ? -1 : rightHeld && !leftHeld ? 1 : 0;

      if (dir !== 0) {
        if (lastMoveDir !== dir) {
          tryMove(dir);
        } else if (moveRepeatTimer >= moveRepeatDelay) {
          moveRepeatTimer = 0;
          tryMove(dir);
        }
      }
    }

    drawBoard();
    requestAnimationFrame(loop);
  }

  // Start
  resetGame();
  applyScaleToFit();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
