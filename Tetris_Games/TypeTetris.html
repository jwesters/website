<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Basic Tetris</title>
  <style>
    :root{
      --bg:#0f1220; --panel:rgba(255,255,255,.05); --line:rgba(255,255,255,.10);
      --text:#eef0ff; --muted:#aab1dd; --radius:16px;
      --shadow:0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:radial-gradient(1200px 600px at 20% 10%, #1d2450 0%, var(--bg) 55%, #070913 100%);
      color:var(--text);
      min-height:100vh;
      display:grid;
      place-items:center;
      padding:14px;
    }
    .wrap{width:min(940px,100%);display:grid;gap:14px}
    .top{display:flex;align-items:flex-start;justify-content:space-between;gap:12px;flex-wrap:wrap}
    h1{margin:0;font-size:18px;font-weight:800;letter-spacing:.2px}
    .hint{color:var(--muted);font-size:13px;line-height:1.35}
    .kbd{
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
      font-size:12px;padding:2px 6px;border-radius:6px;
      border:1px solid var(--line);background:rgba(0,0,0,.25);color:var(--text);
      display:inline-block
    }
    .btns{display:flex;gap:10px;flex-wrap:wrap}
    button{
      appearance:none;border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;border-radius:12px;
      font-weight:800;cursor:pointer;
      transition:transform .05s ease,background .2s ease;
      user-select:none;
    }
    button:hover{background:rgba(255,255,255,.10)}
    button:active{transform:translateY(1px)}
    button:disabled{opacity:.55;cursor:not-allowed}

    .layout{display:grid;grid-template-columns:1fr;gap:14px}
    @media (min-width: 820px){.layout{grid-template-columns:1fr 300px}}

    .card{
      background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }

    .game{padding:14px}
    canvas#board{
      width:100%;
      height:auto;
      max-width:520px;
      aspect-ratio:10/20;
      background:#070a14;
      border-radius:14px;
      border:1px solid var(--line);
      display:block;
      margin-inline:auto;
    }
    .side{padding:14px;display:grid;gap:12px}
    .stat{
      background:rgba(0,0,0,.18);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
    }
    .stat h2{
      margin:0 0 6px;
      font-size:12px;
      color:var(--muted);
      font-weight:700;
      letter-spacing:.3px;
      text-transform:uppercase;
    }
    .stat .val{font-size:22px;font-weight:900;letter-spacing:.4px}
    .mini{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    #next{
      width:100%;
      max-width:220px;
      aspect-ratio:1/1;
      display:block;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.20);
    }
    .footer{color:var(--muted);font-size:12px;line-height:1.35}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div>
        <h1>Basic Tetris</h1>
        <div class="hint">
          Move: <span class="kbd">←</span>/<span class="kbd">→</span> • Soft drop: <span class="kbd">↓</span> • Rotate: <span class="kbd">↑</span> • Hard drop: <span class="kbd">Space</span><br>
          Pause: <span class="kbd">P</span> • Restart: <span class="kbd">R</span>
        </div>
      </div>
      <div class="btns">
        <button id="btnPause" type="button">Pause (P)</button>
        <button id="btnRestart" type="button">Restart (R)</button>
      </div>
    </div>

    <div class="layout">
      <div class="card game">
        <canvas id="board" width="300" height="600" aria-label="Tetris board"></canvas>
        <div class="footer" style="margin-top:10px;">
          Standard 7-bag pieces, rotation enabled (with basic wall-kicks). Ghost piece included.
        </div>
      </div>

      <div class="card side">
        <div class="stat">
          <h2>Next</h2>
          <canvas id="next" width="160" height="160" aria-label="Next piece"></canvas>
        </div>

        <div class="mini">
          <div class="stat">
            <h2>Score</h2>
            <div class="val" id="score">0</div>
          </div>
          <div class="stat">
            <h2>Lines</h2>
            <div class="val" id="lines">0</div>
          </div>
        </div>

        <div class="stat">
          <h2>Level</h2>
          <div class="val" id="level">1</div>
          <div class="hint">Level increases every 10 lines. Speed increases with level.</div>
        </div>

        <div class="stat">
          <h2>Controls</h2>
          <div class="hint">
            - Rotate: <span class="kbd">↑</span><br>
            - Hard drop: <span class="kbd">Space</span><br>
            - Pause: <span class="kbd">P</span> • Restart: <span class="kbd">R</span>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ====== Board config ======
  const COLS = 10, ROWS = 20;
  const CELL = 30;
  const PREVIEW_CELL = 20;

  const boardCanvas = document.getElementById('board');
  const ctx = boardCanvas.getContext('2d');

  const nextCanvas = document.getElementById('next');
  const nctx = nextCanvas.getContext('2d');

  const scoreEl = document.getElementById('score');
  const linesEl = document.getElementById('lines');
  const levelEl = document.getElementById('level');

  const btnPause = document.getElementById('btnPause');
  const btnRestart = document.getElementById('btnRestart');

  const COLORS = {
    I: '#3bd6ff',
    O: '#ffd85a',
    T: '#b58bff',
    S: '#5dff9b',
    Z: '#ff5d7a',
    J: '#5a7bff',
    L: '#ffb35a',
    grid: 'rgba(255,255,255,0.10)',
  };

  // ====== Tetrominoes (spawn orientation) ======
  // Using 4x4 matrices for all pieces for simpler rotation.
  const TETROS = {
    I: [
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0],
      [0,0,0,0],
    ],
    O: [
      [0,1,1,0],
      [0,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    T: [
      [0,1,0,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    S: [
      [0,1,1,0],
      [1,1,0,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    Z: [
      [1,1,0,0],
      [0,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    J: [
      [1,0,0,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    L: [
      [0,0,1,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
  };

  const PIECES = Object.keys(TETROS);

  // ====== Utilities ======
  const makeBoard = () => Array.from({length: ROWS}, () => Array(COLS).fill(null));

  function cloneM(m){ return m.map(r => r.slice()); }

  function shuffleInPlace(arr){
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    return arr;
  }

  function forEachCell(mat, fn){
    for(let y=0;y<mat.length;y++){
      for(let x=0;x<mat[y].length;x++){
        if(mat[y][x]) fn(x,y);
      }
    }
  }

  function bounds(mat){
    let minX=1e9, minY=1e9, maxX=-1e9, maxY=-1e9;
    forEachCell(mat,(x,y)=>{
      minX = Math.min(minX,x); minY = Math.min(minY,y);
      maxX = Math.max(maxX,x); maxY = Math.max(maxY,y);
    });
    if(!isFinite(minX)) return {minX:0,minY:0,w:0,h:0};
    return {minX, minY, w:(maxX-minX+1), h:(maxY-minY+1)};
  }

  function rotateCW(mat){
    const N = mat.length;
    const out = Array.from({length:N}, ()=>Array(N).fill(0));
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        out[x][N-1-y] = mat[y][x];
      }
    }
    return out;
  }

  // Basic wall-kick attempts (not full SRS, but feels good):
  // Try x offsets: 0, -1, +1, -2, +2
  const KICKS = [0, -1, 1, -2, 2];

  function canPlace(board, piece, dx=0, dy=0, shapeOverride=null){
    const shape = shapeOverride || piece.shape;
    const nx = piece.x + dx;
    const ny = piece.y + dy;

    let ok = true;
    forEachCell(shape,(cx,cy)=>{
      const x = nx + cx;
      const y = ny + cy;
      if(x < 0 || x >= COLS || y >= ROWS) { ok = false; return; }
      if(y < 0) return; // allow above top
      if(board[y][x]) { ok = false; return; }
    });
    return ok;
  }

  function lock(board, piece){
    forEachCell(piece.shape,(cx,cy)=>{
      const x = piece.x + cx;
      const y = piece.y + cy;
      if(y >= 0 && y < ROWS && x >= 0 && x < COLS) board[y][x] = piece.type;
    });
  }

  function clearLines(board){
    let cleared = 0;
    for(let y=ROWS-1;y>=0;y--){
      if(board[y].every(Boolean)){
        board.splice(y,1);
        board.unshift(Array(COLS).fill(null));
        cleared++;
        y++;
      }
    }
    return cleared;
  }

  function dropInterval(level){
    return Math.max(90, 700 - (level-1)*60);
  }

  function scoreFor(linesCleared, level){
    const table = [0, 100, 300, 500, 800];
    return (table[linesCleared] || 0) * level;
  }

  function drawCell(context, x, y, size, color){
    context.fillStyle = color;
    context.fillRect(x,y,size,size);

    context.strokeStyle = 'rgba(255,255,255,0.18)';
    context.lineWidth = 1;
    context.strokeRect(x+0.5,y+0.5,size-1,size-1);

    context.strokeStyle = 'rgba(0,0,0,0.35)';
    context.beginPath();
    context.moveTo(x+0.5, y+size-0.5);
    context.lineTo(x+size-0.5, y+size-0.5);
    context.lineTo(x+size-0.5, y+0.5);
    context.stroke();
  }

  function overlay(text){
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fillRect(0,0,boardCanvas.width,boardCanvas.height);
    ctx.fillStyle = '#fff';
    ctx.font = '900 34px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, boardCanvas.width/2, boardCanvas.height/2);

    ctx.font = '700 14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.fillText('Press R to restart', boardCanvas.width/2, boardCanvas.height/2 + 36);
  }

  // ====== 7-bag randomizer ======
  let bag = [];
  function refillBag(){ if(bag.length===0) bag = shuffleInPlace(PIECES.slice()); }
  function nextFromBag(){ refillBag(); return bag.pop(); }

  function newPiece(type){
    const shape = cloneM(TETROS[type]);
    const b = bounds(shape);
    // center based on piece bounds
    const x = Math.floor((COLS - b.w)/2) - b.minX;
    const y = -b.minY;
    return { type, shape, x, y };
  }

  // ====== Game state ======
  let board, current, nextPiece;
  let score=0, lines=0, level=1;
  let paused=false, gameOver=false;

  let dropTimer=0, lastTime=0;
  const keys = new Set();
  let moveRepeatDelay = 120;
  let moveRepeatTimer = 0;
  let lastMoveDir = 0;

  function updateHUD(){
    scoreEl.textContent = String(score);
    linesEl.textContent = String(lines);
    levelEl.textContent = String(level);
  }

  function reset(){
    board = makeBoard();
    score = 0; lines = 0; level = 1;
    paused = false; gameOver = false;
    dropTimer = 0; lastTime = performance.now();
    bag = [];

    current = newPiece(nextFromBag());
    nextPiece = newPiece(nextFromBag());
    if(!canPlace(board, current, 0, 0)) gameOver = true;

    btnPause.textContent = "Pause (P)";
    updateHUD();
    drawNext();
    draw();
  }

  function spawn(){
    current = nextPiece;
    nextPiece = newPiece(nextFromBag());
    drawNext();
    if(!canPlace(board, current, 0, 0)) gameOver = true;
  }

  function rotateCurrent(){
    if(paused || gameOver) return;
    const rotated = rotateCW(current.shape);
    // try kicks
    for(const k of KICKS){
      if(canPlace(board, current, k, 0, rotated)){
        current.shape = rotated;
        current.x += k;
        return;
      }
    }
  }

  function tryMove(dir){
    if(canPlace(board, current, dir, 0)){
      current.x += dir;
      lastMoveDir = dir;
      moveRepeatTimer = 0;
    }
  }

  function stepDown(){
    if(paused || gameOver) return;
    if(canPlace(board, current, 0, 1)){
      current.y += 1;
    } else {
      lock(board, current);
      const cleared = clearLines(board);
      if(cleared){
        score += scoreFor(cleared, level);
        lines += cleared;
        const newLevel = Math.floor(lines/10)+1;
        if(newLevel !== level) level = newLevel;
      }
      updateHUD();
      spawn();
    }
  }

  function hardDrop(){
    if(paused || gameOver) return;
    let moved = 0;
    while(canPlace(board, current, 0, 1)){
      current.y += 1;
      moved++;
    }
    score += moved * 2;
    updateHUD();
    stepDown(); // will lock immediately
  }

  function softDropOne(){
    if(paused || gameOver) return;
    if(canPlace(board, current, 0, 1)){
      current.y += 1;
      score += 1;
      updateHUD();
    }
  }

  function togglePause(){
    if(gameOver) return;
    paused = !paused;
    btnPause.textContent = paused ? "Resume (P)" : "Pause (P)";
    draw();
  }

  // ====== Rendering ======
  function drawGrid(){
    ctx.strokeStyle = COLORS.grid;
    ctx.lineWidth = 1;
    for(let x=0;x<=COLS;x++){
      ctx.beginPath();
      ctx.moveTo(x*CELL + 0.5, 0);
      ctx.lineTo(x*CELL + 0.5, ROWS*CELL);
      ctx.stroke();
    }
    for(let y=0;y<=ROWS;y++){
      ctx.beginPath();
      ctx.moveTo(0, y*CELL + 0.5);
      ctx.lineTo(COLS*CELL, y*CELL + 0.5);
      ctx.stroke();
    }
  }

  function draw(){
    ctx.clearRect(0,0,boardCanvas.width,boardCanvas.height);
    ctx.fillStyle = '#070a14';
    ctx.fillRect(0,0,boardCanvas.width,boardCanvas.height);

    drawGrid();

    // locked blocks
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const t = board[y][x];
        if(t) drawCell(ctx, x*CELL, y*CELL, CELL, COLORS[t]);
      }
    }

    // ghost
    if(!paused && !gameOver && current){
      const ghost = { ...current, shape: current.shape };
      while(canPlace(board, ghost, 0, 1)) ghost.y += 1;
      ctx.globalAlpha = 0.25;
      forEachCell(ghost.shape, (cx,cy)=>{
        const gx = ghost.x + cx;
        const gy = ghost.y + cy;
        if(gy >= 0) drawCell(ctx, gx*CELL, gy*CELL, CELL, COLORS[ghost.type]);
      });
      ctx.globalAlpha = 1;
    }

    // current piece
    if(current && !gameOver){
      forEachCell(current.shape, (cx,cy)=>{
        const x = current.x + cx;
        const y = current.y + cy;
        if(y >= 0) drawCell(ctx, x*CELL, y*CELL, CELL, COLORS[current.type]);
      });
    }

    if(paused) overlay("Paused");
    if(gameOver) overlay("Game Over");
  }

  function drawNext(){
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    nctx.fillStyle = 'rgba(0,0,0,0.20)';
    nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);

    // small grid
    nctx.strokeStyle = 'rgba(255,255,255,0.08)';
    for(let i=0;i<=8;i++){
      nctx.beginPath();
      nctx.moveTo(i*PREVIEW_CELL + 0.5, 0);
      nctx.lineTo(i*PREVIEW_CELL + 0.5, 8*PREVIEW_CELL);
      nctx.stroke();
      nctx.beginPath();
      nctx.moveTo(0, i*PREVIEW_CELL + 0.5);
      nctx.lineTo(8*PREVIEW_CELL, i*PREVIEW_CELL + 0.5);
      nctx.stroke();
    }

    if(!nextPiece) return;

    const b = bounds(nextPiece.shape);
    const offsetX = Math.floor((8 - b.w)/2) - b.minX;
    const offsetY = Math.floor((8 - b.h)/2) - b.minY;

    forEachCell(nextPiece.shape, (cx,cy)=>{
      const x = (offsetX + cx)*PREVIEW_CELL;
      const y = (offsetY + cy)*PREVIEW_CELL;
      drawCell(nctx, x, y, PREVIEW_CELL, COLORS[nextPiece.type]);
    });
  }

  // ====== Input ======
  function onKeyDown(e){
    if(["ArrowLeft","ArrowRight","ArrowDown","ArrowUp","Space"].includes(e.code)) e.preventDefault();

    if(e.code === "KeyP"){ togglePause(); return; }
    if(e.code === "KeyR"){ reset(); return; }

    keys.add(e.code);
    if(paused || gameOver) return;

    if(e.code === "ArrowLeft") tryMove(-1);
    else if(e.code === "ArrowRight") tryMove(1);
    else if(e.code === "ArrowDown") softDropOne();
    else if(e.code === "ArrowUp") rotateCurrent();
    else if(e.code === "Space") hardDrop();
  }

  function onKeyUp(e){
    keys.delete(e.code);
    if(e.code === "ArrowLeft" && lastMoveDir === -1) lastMoveDir = 0;
    if(e.code === "ArrowRight" && lastMoveDir === 1) lastMoveDir = 0;
  }

  window.addEventListener('keydown', onKeyDown, { passive:false });
  window.addEventListener('keyup', onKeyUp);

  btnPause.addEventListener('click', togglePause);
  btnRestart.addEventListener('click', reset);

  // ====== Main loop ======
  function loop(time){
    const dt = time - lastTime;
    lastTime = time;

    if(!paused && !gameOver){
      // gravity
      dropTimer += dt;
      const interval = dropInterval(level);
      if(dropTimer >= interval){
        dropTimer = 0;
        stepDown();
      }

      // movement repeat (DAS-ish)
      moveRepeatTimer += dt;
      const leftHeld = keys.has("ArrowLeft");
      const rightHeld = keys.has("ArrowRight");
      const dir = (leftHeld && !rightHeld) ? -1 : (rightHeld && !leftHeld) ? 1 : 0;

      if(dir !== 0){
        if(lastMoveDir !== dir){
          tryMove(dir);
        } else if(moveRepeatTimer >= moveRepeatDelay){
          moveRepeatTimer = 0;
          tryMove(dir);
        }
      }
    }

    draw();
    requestAnimationFrame(loop);
  }

  // Start
  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
