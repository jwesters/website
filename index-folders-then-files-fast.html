<!DOCTYPE html>  
<html lang="en">     
<head>       
<meta charset="UTF-8" /> 
<meta name="viewport" content="width=device-width, initial-scale=1" /> 
<title>https://github.com/jwesters/ Website Repo</title>
<style>
  :root { color-scheme: light; }
  body { font-family: Arial, sans-serif; padding: 28px; background:#f7f7f7; }
  h1 { margin: 0 0 8px; font-size: 22px; }
  p  { margin: 0 0 18px; color:#333; }
  .panel { background:#fff; border-radius:12px; padding:18px 18px 10px; box-shadow: 0 4px 14px rgba(0,0,0,.06); }
  details { margin: 10px 0; border: 1px solid #eee; border-radius: 10px; background:#fafafa; }
  summary { cursor:pointer; padding: 10px 12px; font-weight: 700; user-select:none; list-style:none; }
  summary::-webkit-details-marker { display:none; }
  summary::before { content:"â–¸"; display:inline-block; width: 18px; color:#666; }
  details[open] summary::before { content:"â–¾"; }
  ul { list-style:none; padding: 0 0 10px 0; margin: 0; }
  li { padding: 6px 12px; }
  a { text-decoration:none; color:#0066cc; }
  a:hover { text-decoration:underline; }
  .muted { color:#777; font-weight:400; margin-left:6px; font-size: 0.9em; }
  .icon { display:inline-block; width: 22px; }
  .nested { padding-left: 14px; }
  .root-files { margin: 6px 0 14px; border: 1px solid #eee; border-radius: 10px; background:#fafafa; }
  .root-files ul { padding-bottom: 6px; }
  .footer { margin-top: 14px; font-size: 0.95em; color:#666; }
</style>
</head>
<body>
  <h1>
    <a href="https://github.com/jwesters/website" target="_blank" rel="noopener noreferrer">
      https://github.com/jwesters/ Website Repo
    </a>
  </h1>
  <p>Auto-generated list of HTML files in this repository (folder tree & sorted).</p>

  <div class="panel">
    <div id="status" class="muted">Loadingâ€¦</div>
    <div id="groups"></div>
    <div id="lastUpdated" class="footer"></div>
  </div>

<script>
(() => {
  const OWNER = "jwesters";
  const REPO  = "website";
  const SITE_URL = `https://${OWNER}.github.io/${REPO}`;
  const API_BASE = `https://api.github.com/repos/${OWNER}/${REPO}/contents`;

  // âœ… Options
  const HIDE_ROOT_INDEX_HTML = true;   // hides "/index.html" only
  const HIDE_ALL_INDEX_HTML  = false;  // hide every ".../index.html" if true

  // âœ… Hide any .html file if "NSFW" appears anywhere in the filename (case-insensitive)
  const HIDE_NSFw_ANYWHERE_IN_FILENAME = true;

  // --- Icon mapping (folder/file keywords -> emoji)
  const ICON_RULES = [
    { re: /(tetris)/i, icon: "ðŸ§±" },
    { re: /(hangman)/i, icon: "ðŸª“" },
    { re: /(maze)/i, icon: "ðŸ§©" },
    { re: /(qr|qrcode)/i, icon: "ðŸ”³" },
    { re: /(wordle|numdle|dle)/i, icon: "ðŸŸ©" },
    { re: /(card|deck)/i, icon: "ðŸƒ" },
    { re: /(clock|time)/i, icon: "â°" },
    { re: /(math|quiz)/i, icon: "âž—" },
    { re: /(game|play)/i, icon: "ðŸŽ®" },
    { re: /(index)/i, icon: "ðŸ " },
  ];
  const DEFAULT_FOLDER_ICON = "ðŸ“";
  const DEFAULT_FILE_ICON   = "ðŸ“„";

  const statusEl = document.getElementById("status");
  const groupsEl = document.getElementById("groups");
  const lastUpdatedEl = document.getElementById("lastUpdated");

  function iconFor(name, isDir) {
    const hit = ICON_RULES.find(r => r.re.test(name));
    if (hit) return hit.icon;
    return isDir ? DEFAULT_FOLDER_ICON : DEFAULT_FILE_ICON;
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
  }


  // --- Tree model
  // node = { name, path, files: [{name,path}], dirs: Map<string,node> }
  const tree = { name: "", path: "", files: [], dirs: new Map(), loaded: false };

  function getOrCreateDir(parent, dirName, fullPath) {
    if (!parent.dirs.has(dirName)) {
      parent.dirs.set(dirName, { name: dirName, path: fullPath, files: [], dirs: new Map(), loaded: false });
    }
    return parent.dirs.get(dirName);
  }

  function addFileToTree(filePath) {
    const parts = filePath.split("/").filter(Boolean);
    const fileName = parts.pop();
    let node = tree;
    let accum = "";
    for (const dir of parts) {
      accum = accum ? `${accum}/${dir}` : dir;
      node = getOrCreateDir(node, dir, accum);
    }
    node.files.push({ name: fileName, path: filePath });
  }

  function filenameContainsNSFW(filename) {
    return filename.toLowerCase().includes("nsfw");
  }

  function shouldHide(filePath) {
    const lowerPath = filePath.toLowerCase();
    const filename = (filePath.split("/").pop() || "").toLowerCase();

    if (HIDE_ALL_INDEX_HTML && lowerPath.endsWith("/index.html")) return true;
    if (HIDE_ROOT_INDEX_HTML && lowerPath === "index.html") return true;

    if (HIDE_NSFw_ANYWHERE_IN_FILENAME && filenameContainsNSFW(filename)) return true;

    return false;
  }

  async function loadDir(node) {
    // Load ONE directory listing from GitHub contents API and populate this node.
    // This is LAZY: we only load a folder when the user opens it.
    const url = node.path ? `${API_BASE}/${encodeURIComponent(node.path)}` : API_BASE;

    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) {
      const remaining = res.headers.get("x-ratelimit-remaining");
      const reset = res.headers.get("x-ratelimit-reset");
      if (res.status === 403 && remaining === "0" && reset) {
        const resetMs = Number(reset) * 1000;
        const mins = Math.max(1, Math.ceil((resetMs - Date.now()) / 60000));
        throw new Error(`GitHub API rate limit hit. Try again in about ${mins} minute(s), or open the page while logged into GitHub.`);
      }
      throw new Error(`GitHub API error: ${res.status} ${res.statusText}`);
    }

    const items = await res.json();

    // Clear & repopulate to keep it deterministic
    node.files = [];
    node.dirs = new Map();

    for (const item of items) {
      if (item.type === "dir") {
        const name = item.name;
        node.dirs.set(name, { name, path: item.path, files: [], dirs: new Map(), loaded: false });
      } else if (item.type === "file" && item.name.toLowerCase().endsWith(".html")) {
        if (!shouldHide(item.path)) node.files.push(item.path);
      }
    }

    node.files.sort(sortAlpha);
    node.loaded = true;
  }


  // Recursively walk the repo using the Contents API
  async function fetchFiles() {
    // Lazy-load root only. Subfolders load when opened.
    await loadDir(tree);
  } else if (item.type === "file" && item.name.toLowerCase().endsWith(".html")) {
        if (!shouldHide(item.path)) addFileToTree(item.path);
      }
    }
  }

  function sortAlpha(a, b) {
    return a.localeCompare(b, undefined, { sensitivity: "base" });
  }

  function countHtmlInSubtree(node) {
    let count = node.files.length;
    for (const child of node.dirs.values()) count += countHtmlInSubtree(child);
    return count;
  }

  function pruneEmptyDirs(node) {
    // Remove directories that contain no html files anywhere below them
    for (const [name, child] of Array.from(node.dirs.entries())) {
      pruneEmptyDirs(child);
      if (countHtmlInSubtree(child) === 0) node.dirs.delete(name);
    }
  }

  function buildFileList(files) {
    const ul = document.createElement("ul");
    files.sort((a, b) => sortAlpha(a.name, b.name));

    for (const f of files) {
      const li = document.createElement("li");
      const a = document.createElement("a");
      a.href = `${SITE_URL}/${f.path}`;
      a.target = "_blank";
      a.rel = "noopener noreferrer";
      a.innerHTML = `<span class="icon">${iconFor(f.path, false)}</span>${f.name}`;
      li.appendChild(a);
      ul.appendChild(li);
    }
    return ul;
  }

  function renderDir(node, openByDefault = false, depth = 0) {
    const details = document.createElement("details");
    details.open = openByDefault;

    const summary = document.createElement("summary");

    // Count is only reliable for what we've loaded so far; show "â€¦" until loaded.
    const countText = node.loaded ? `(${countHtmlInSubtree(node)})` : `(â€¦)`;
    summary.innerHTML = `<span class="icon">${iconFor(node.name, true)}</span>${node.name} <span class="muted">${countText}</span>`;
    details.appendChild(summary);

    const wrap = document.createElement("div");
    wrap.className = "nested";
    details.appendChild(wrap);

    function renderContents() {
      wrap.innerHTML = "";

      // Subfolders FIRST
      const subfolderNames = Array.from(node.dirs.keys()).sort(sortAlpha);
      for (const subName of subfolderNames) {
        const child = node.dirs.get(subName);
        wrap.appendChild(renderDir(child, false, depth + 1));
      }

      // Files AFTER subfolders
      if (node.files.length) {
        wrap.appendChild(buildFileList(node.files));
      }

      if (!node.files.length && node.dirs.size === 0) {
        const empty = document.createElement("div");
        empty.className = "muted";
        empty.style.padding = "6px 0 0 28px";
        empty.textContent = "No HTML files in this folder.";
        wrap.appendChild(empty);
      }
    }

    async function ensureLoadedAndRender() {
      if (node.loaded) {
        renderContents();
        // update summary count
        summary.innerHTML = `<span class="icon">${iconFor(node.name, true)}</span>${node.name} <span class="muted">(${countHtmlInSubtree(node)})</span>`;
        return;
      }
      wrap.innerHTML = `<div class="muted" style="padding:6px 0 0 28px;">Loadingâ€¦</div>`;
      await loadDir(node);
      renderContents();
      summary.innerHTML = `<span class="icon">${iconFor(node.name, true)}</span>${node.name} <span class="muted">(${countHtmlInSubtree(node)})</span>`;
    }

    details.addEventListener("toggle", () => {
      if (details.open) {
        ensureLoadedAndRender().catch(err => {
          wrap.innerHTML = `<div class="muted" style="padding:6px 0 0 28px;">Failed to load folder: ${escapeHtml(err && err.message ? err.message : String(err))}</div>`;
        });
      }
    });

    // If opened by default, load immediately
    if (openByDefault) {
      ensureLoadedAndRender().catch(() => {});
    }

    return details;
  }

    // Subfolders
    const subfolderNames = Array.from(node.dirs.keys()).sort(sortAlpha);
    for (const subName of subfolderNames) {
      const child = node.dirs.get(subName);
      wrap.appendChild(renderDir(child, false, depth + 1));
    }

    details.appendChild(wrap);
    return details;
  }

  function buildUI() {
    statusEl.textContent = "";
    groupsEl.innerHTML = "";

    // Root should already be loaded
    pruneEmptyDirs(tree);

    // Top-level folders FIRST
    const topFolders = Array.from(tree.dirs.keys()).sort(sortAlpha);
    for (const name of topFolders) {
      const node = tree.dirs.get(name);
      groupsEl.appendChild(renderDir(node, false, 0));
    }

    // Root files LAST
    if (tree.files.length) {
      const box = document.createElement("div");
      box.className = "root-files";
      box.appendChild(buildFileList(tree.files));
      groupsEl.appendChild(box);
    }

    const totalCount = tree.files.length + topFolders.reduce((sum, n) => sum + countHtmlInSubtree(tree.dirs.get(n)), 0);
    if (totalCount === 0) statusEl.textContent = "No HTML files found.";
  }

    // Top-level folders
    const topFolders = Array.from(tree.dirs.keys()).sort(sortAlpha);
    for (const name of topFolders) {
      const node = tree.dirs.get(name);
      // closed by default; you can change to true if you want first folder opened
      groupsEl.appendChild(renderDir(node, false, 0));
    }

    const totalCount = tree.files.length + topFolders.reduce((sum, n) => sum + countHtmlInSubtree(tree.dirs.get(n)), 0);
    if (totalCount === 0) {
      statusEl.textContent = "No HTML files found.";
    }
  }

  async function setLastUpdated() {
    // Show the last commit date that touched THIS index.html (matches â€œuploaded to GitHubâ€ best)
    const url = `https://api.github.com/repos/${OWNER}/${REPO}/commits?path=index.html&per_page=1`;
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`GitHub API error: ${res.status} ${res.statusText}`);
      const data = await res.json();
      const iso = data?.[0]?.commit?.committer?.date || data?.[0]?.commit?.author?.date;
      if (!iso) throw new Error("No commit date found.");

      const d = new Date(iso);
      const formatted = new Intl.DateTimeFormat("en-CA", { year: "numeric", month: "long", day: "numeric" }).format(d);
      lastUpdatedEl.textContent = `Last updated: ${formatted} `;
    } catch (e) {
      console.warn(e);
      lastUpdatedEl.textContent = "Last updated: (unavailable)";
    }
  }

  (async () => {
    try {
      statusEl.textContent = "Loadingâ€¦";
      await fetchFiles();
      buildUI();
      await setLastUpdated();
    } catch (err) {
      console.error(err);
      statusEl.textContent = "Failed to load files: " + (err && err.message ? err.message : String(err));;
      lastUpdatedEl.textContent = "";
    }
  })();
})();
</script>

</body>
</html>
