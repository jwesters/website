<!DOCTYPE html>  
<html lang="en">     
<head>       
<meta charset="UTF-8" /> 
<meta name="viewport" content="width=device-width, initial-scale=1" /> 
<title>https://github.com/jwesters/ Website Repo</title>
<style>
  :root { color-scheme: light; }
  body { font-family: Arial, sans-serif; padding: 28px; background:#f7f7f7; }
  h1 { margin: 0 0 8px; font-size: 22px; }
  p  { margin: 0 0 18px; color:#333; }
  .panel { background:#fff; border-radius:12px; padding:18px 18px 10px; box-shadow: 0 4px 14px rgba(0,0,0,.06); }
  details { margin: 10px 0; border: 1px solid #eee; border-radius: 10px; background:#fafafa; }
  summary { cursor:pointer; padding: 10px 12px; font-weight: 700; user-select:none; list-style:none; }
  summary::-webkit-details-marker { display:none; }
  summary::before { content:"â–¸"; display:inline-block; width: 18px; color:#666; }
  details[open] summary::before { content:"â–¾"; }
  ul { list-style:none; padding: 0 0 10px 0; margin: 0; }
  li { padding: 6px 12px; }
  a { text-decoration:none; color:#0066cc; }
  a:hover { text-decoration:underline; }
  .muted { color:#777; font-weight:400; margin-left:6px; font-size: 0.9em; }
  .icon { display:inline-block; width: 22px; }
  .nested { padding-left: 14px; }
  .root-files { margin: 6px 0 14px; border: 1px solid #eee; border-radius: 10px; background:#fafafa; }
  .root-files ul { padding-bottom: 6px; }
  .footer { margin-top: 14px; font-size: 0.95em; color:#666; }
</style>
</head>
<body>
  <h1>
    <a href="https://github.com/jwesters/website" target="_blank" rel="noopener noreferrer">
      https://github.com/jwesters/ Website Repo
    </a>
  </h1>
  <p>Auto-generated list of HTML files in this repository (folder tree & sorted).</p>

  <div class="panel">
    <div id="status" class="muted">Loadingâ€¦</div>
    <div id="groups"></div>
    <div id="lastUpdated" class="footer"></div>
  </div>

<script>
(() => {
  const OWNER = "jwesters";
  const REPO  = "website";
  const SITE_URL = `https://${OWNER}.github.io/${REPO}`;
  const API_BASE = `https://api.github.com/repos/${OWNER}/${REPO}/contents`;

  // âœ… Options
  const HIDE_ROOT_INDEX_HTML = true;   // hides "/index.html" only
  const HIDE_ALL_INDEX_HTML  = false;  // hide every ".../index.html" if true

  // âœ… Hide any .html file if "NSFW" appears anywhere in the filename (case-insensitive)
  const HIDE_NSFw_ANYWHERE_IN_FILENAME = true;

  // --- Icon mapping (folder/file keywords -> emoji)
  const ICON_RULES = [
    { re: /(tetris)/i, icon: "ðŸ§±" },
    { re: /(hangman)/i, icon: "ðŸª“" },
    { re: /(maze)/i, icon: "ðŸ§©" },
    { re: /(qr|qrcode)/i, icon: "ðŸ”³" },
    { re: /(wordle|numdle|dle)/i, icon: "ðŸŸ©" },
    { re: /(card|deck)/i, icon: "ðŸƒ" },
    { re: /(clock|time)/i, icon: "â°" },
    { re: /(math|quiz)/i, icon: "âž—" },
    { re: /(game|play)/i, icon: "ðŸŽ®" },
    { re: /(index)/i, icon: "ðŸ " },
  ];
  const DEFAULT_FOLDER_ICON = "ðŸ“";
  const DEFAULT_FILE_ICON   = "ðŸ“„";

  const statusEl = document.getElementById("status");
  const groupsEl = document.getElementById("groups");
  const lastUpdatedEl = document.getElementById("lastUpdated");

  function iconFor(name, isDir) {
    const hit = ICON_RULES.find(r => r.re.test(name));
    if (hit) return hit.icon;
    return isDir ? DEFAULT_FOLDER_ICON : DEFAULT_FILE_ICON;
  }

  // --- Tree model
  // node = { name, path, files: [{name,path}], dirs: Map<string,node> }
  const tree = { name: "", path: "", files: [], dirs: new Map() };

  function getOrCreateDir(parent, dirName, fullPath) {
    if (!parent.dirs.has(dirName)) {
      parent.dirs.set(dirName, { name: dirName, path: fullPath, files: [], dirs: new Map() });
    }
    return parent.dirs.get(dirName);
  }

  function addFileToTree(filePath) {
    const parts = filePath.split("/").filter(Boolean);
    const fileName = parts.pop();
    let node = tree;
    let accum = "";
    for (const dir of parts) {
      accum = accum ? `${accum}/${dir}` : dir;
      node = getOrCreateDir(node, dir, accum);
    }
    node.files.push({ name: fileName, path: filePath });
  }

  function filenameContainsNSFW(filename) {
    return filename.toLowerCase().includes("nsfw");
  }

  function shouldHide(filePath) {
    const lowerPath = filePath.toLowerCase();
    const filename = (filePath.split("/").pop() || "").toLowerCase();

    if (HIDE_ALL_INDEX_HTML && lowerPath.endsWith("/index.html")) return true;
    if (HIDE_ROOT_INDEX_HTML && lowerPath === "index.html") return true;

    if (HIDE_NSFw_ANYWHERE_IN_FILENAME && filenameContainsNSFW(filename)) return true;

    return false;
  }

  // Recursively walk the repo using the Contents API
  async function fetchFiles() {
    // Fast + reliable: resolve a branch to a tree SHA, then fetch the full tree in one go.
    // Robust behavior:
    // - If BRANCH is set but doesn't exist, we fall back to the repo's default_branch.
    // - We surface the actual error message on the page (not just in console).
    statusEl.textContent = "Loadingâ€¦";

    async function ghFetch(url) {
      const res = await fetch(url, {
        cache: "no-store",
        headers: { "Accept": "application/vnd.github+json" }
      });
      if (!res.ok) {
        const remaining = res.headers.get("x-ratelimit-remaining");
        const reset = res.headers.get("x-ratelimit-reset");
        if (res.status === 403 && remaining === "0" && reset) {
          const resetMs = Number(reset) * 1000;
          const mins = Math.max(1, Math.ceil((resetMs - Date.now()) / 60000));
          throw new Error(`GitHub API rate limit hit. Try again in about ${mins} minute(s), or open the page while logged into GitHub.`);
        }
        let msg = `GitHub API error: ${res.status} ${res.statusText}`;
        try {
          const j = await res.json();
          if (j && j.message) msg += ` â€” ${j.message}`;
        } catch (e) {}
        throw new Error(msg);
      }
      return res.json();
    }

    // 1) Get repo info (default branch)
    const repoInfo = await ghFetch(`https://api.github.com/repos/${OWNER}/${REPO}`);
    const defaultBranch = repoInfo.default_branch || "main";

    // Prefer BRANCH if set, otherwise default
    let branch = (typeof BRANCH === "string" && BRANCH.trim()) ? BRANCH.trim() : defaultBranch;

    // 2) Resolve branch -> commit SHA (if invalid, fall back to defaultBranch)
    async function resolveCommitSha(branchName) {
      const ref = await ghFetch(`https://api.github.com/repos/${OWNER}/${REPO}/git/refs/heads/${encodeURIComponent(branchName)}`);
      return ref && ref.object && ref.object.sha ? ref.object.sha : null;
    }

    let commitSha = null;
    try {
      commitSha = await resolveCommitSha(branch);
    } catch (e) {
      if (branch !== defaultBranch) {
        branch = defaultBranch;
        commitSha = await resolveCommitSha(branch);
      } else {
        throw e;
      }
    }

    // 3) Resolve commit SHA -> tree SHA
    const commit = await ghFetch(`https://api.github.com/repos/${OWNER}/${REPO}/git/commits/${commitSha}`);
    const treeSha = commit && commit.tree && commit.tree.sha ? commit.tree.sha : null;
    if (!treeSha) throw new Error("Could not resolve repository tree SHA.");

    // 4) Fetch the full tree
    const data = await ghFetch(`https://api.github.com/repos/${OWNER}/${REPO}/git/trees/${encodeURIComponent(treeSha)}?recursive=1`);
    if (!data || !Array.isArray(data.tree)) throw new Error("Unexpected GitHub API response.");

    let found = 0;
    for (const entry of data.tree) {
      if (entry.type === "blob" && typeof entry.path === "string" && entry.path.toLowerCase().endsWith(".html")) {
        if (!shouldHide(entry.path)) {
          addFileToTree(entry.path);
          found++;
          if (found % 400 === 0) statusEl.textContent = `Loadingâ€¦ (${found} files found)`;
        }
      }
    }

    if (data.truncated) {
      statusEl.textContent = `Loaded (${found} files). Repo is large; list may be incomplete.`;
    }
  }



  async function setLastUpdated() {
    // Show the last commit date that touched THIS index.html (matches â€œuploaded to GitHubâ€ best)
    const url = `https://api.github.com/repos/${OWNER}/${REPO}/commits?path=index.html&per_page=1`;
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`GitHub API error: ${res.status} ${res.statusText}`);
      const data = await res.json();
      const iso = data?.[0]?.commit?.committer?.date || data?.[0]?.commit?.author?.date;
      if (!iso) throw new Error("No commit date found.");

      const d = new Date(iso);
      const formatted = new Intl.DateTimeFormat("en-CA", { year: "numeric", month: "long", day: "numeric" }).format(d);
      lastUpdatedEl.textContent = `Last updated: ${formatted} `;
    } catch (e) {
      console.warn(e);
      lastUpdatedEl.textContent = "Last updated: (unavailable)";
    }
  }

  (async () => {
    try {
      statusEl.textContent = "Loadingâ€¦";
      await fetchFiles();
      buildUI();
      await setLastUpdated();
    } catch (err) {
      console.error(err);
      statusEl.textContent = "Failed to load files: " + (err && err.message ? err.message : String(err));
      lastUpdatedEl.textContent = "";
    }
  })();
})();
</script>

</body>
</html>
