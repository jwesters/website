<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tic Tac Toe 7x7 (4 in a Row)</title>

  <style>
    * { box-sizing: border-box; }
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }

    body{
      margin:0; min-height:100vh; display:grid; place-items:center;
      background:#f2f3f8; color:#111;
    }

    .wrap{
      width:min(94vw, 680px);
      background:#fff; padding:20px; border-radius:18px;
      box-shadow:0 12px 32px rgba(0,0,0,0.12);
      text-align:center;
    }

    h1{ margin:0 0 8px; font-size:22px; }
    .status{ margin-bottom:12px; font-size:16px; }

    .rules{
      margin:0 0 14px;
      font-size:12.5px;
      color:#555;
      line-height:1.35;
    }

    .board{
      width:min(92vw, 620px);
      aspect-ratio:1/1;
      display:grid;
      grid-template-columns:repeat(7, 1fr);
      grid-template-rows:repeat(7, 1fr);
      gap:10px;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
      margin:0 auto;
    }

    .cell{
      appearance:none; -webkit-appearance:none;
      border:3px solid #222;
      border-radius:14px;
      padding:0; margin:0;
      background:#fff;

      width:100%; height:100%;
      min-width:0; min-height:0;

      font-weight:900;
      font-size:clamp(28px, 6.2vw, 58px);
      line-height:1;

      display:grid;
      place-items:center;

      cursor:pointer;
      transition:background .15s ease, border-color .15s ease, opacity .15s ease, filter .15s ease;
    }

    .cell:hover{ background:#f5f6ff; }
    .cell:active{ background:#eef0ff; }

    .cell:focus{ outline:none; }
    .cell:focus-visible{ outline:4px solid rgba(0,0,0,0.15); outline-offset:3px; }

    .cell.x{ color:#c62828; }  /* red X */
    .cell.o{ color:#1565c0; }  /* blue O */

    .cell.win{
      background:#e6ffe9 !important;
      border-color:#2e7d32 !important;
    }

    /* Blanked out (unplayable) square — darker as requested */
    .cell.blanked{
      cursor:not-allowed;
      background:#cfd3dd !important;   /* darker grey */
      border-color:#4b4f5a !important; /* darker border */
      opacity:0.85;
      filter:saturate(0.85);
    }
    .cell.blanked:hover,
    .cell.blanked:active{ background:#cfd3dd !important; }

    /* Temporarily disabled square (for Player X's first move only) */
    .cell.tempDisabled{
      cursor:not-allowed;
      background:#d6d9e2 !important;
      border-color:#5a5f6b !important;
      opacity:0.9;
    }
    .cell.tempDisabled:hover,
    .cell.tempDisabled:active{ background:#d6d9e2 !important; }

    .controls{ display:flex; gap:12px; margin-top:16px; }

    button.action{
      flex:1;
      padding:12px;
      border:none;
      border-radius:12px;
      font-size:15px;
      font-weight:700;
      cursor:pointer;
      background:#111;
      color:#fff;
    }
    button.action.secondary{ background:#e0e0ef; color:#111; }

    .score{ margin-top:12px; font-size:13px; color:#444; }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Tic Tac Toe 7×7</h1>
    <div class="status" id="status">Player <strong>X</strong>'s turn</div>
    <div class="rules" id="rules">
      Win condition: <strong>4 in a row</strong>.<br>
      Rule 1: Player <strong>X</strong> cannot choose the <strong>center</strong> on their first move (it is greyed out). After X’s first move, the center becomes available for Player <strong>O</strong> (if still empty).<br>
      Rule 2: After the first two moves, <strong>three</strong> empty squares become <strong>blanked out</strong> (unplayable).
    </div>

    <div class="board" id="board" aria-label="7 by 7 board"></div>

    <div class="controls">
      <button class="action" id="newGame">New Game</button>
      <button class="action secondary" id="clearScore">Clear Score</button>
    </div>

    <div class="score" id="score">Score — X: 0 | O: 0 | Ties: 0</div>
  </div>

  <script>
    const N = 7;   // board size
    const K = 4;   // win length

    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const scoreEl = document.getElementById('score');

    const newGameBtn = document.getElementById('newGame');
    const clearScoreBtn = document.getElementById('clearScore');

    const CENTER_R = Math.floor(N / 2);
    const CENTER_C = Math.floor(N / 2);
    const CENTER_I = CENTER_R * N + CENTER_C;

    let board = Array(N * N).fill(null); // 'X', 'O', or null
    let blanked = new Set();             // 3 unplayable squares
    let currentPlayer = 'X';
    let gameOver = false;

    let moveCount = 0;                   // total placed moves (X/O only)
    let xHasMoved = false;               // track if X has taken their first move
    let score = { X: 0, O: 0, T: 0 };

    function idx(r, c) { return r * N + c; }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function createBoard() {
      boardEl.innerHTML = '';
      for (let i = 0; i < N * N; i++) {
        const cell = document.createElement('button');
        cell.type = 'button';
        cell.className = 'cell';
        cell.dataset.index = i;
        cell.setAttribute('aria-label', `Cell ${i + 1}`);
        cell.addEventListener('click', handleMove);
        boardEl.appendChild(cell);
      }
    }

    function isTempDisabled(index) {
      // Grey out + block the center square ONLY during Player X's first turn
      return (currentPlayer === 'X' && !xHasMoved && index === CENTER_I);
    }

    function handleMove(e) {
      if (gameOver) return;

      const index = Number(e.currentTarget.dataset.index);

      if (blanked.has(index)) return;       // cannot click blanked out
      if (board[index]) return;             // cannot click occupied
      if (isTempDisabled(index)) return;    // temporarily disabled for X's first move

      // Place move
      board[index] = currentPlayer;
      moveCount += 1;
      if (currentPlayer === 'X') xHasMoved = true;

      render();

      // Win/tie?
      const result = checkGame();
      if (result.winner) {
        gameOver = true;
        score[result.winner] += 1;
        highlightWin(result.line);
        statusEl.innerHTML = `Player <strong>${result.winner}</strong> wins!`;
        updateScore();
        return;
      }

      if (result.tie) {
        gameOver = true;
        score.T += 1;
        statusEl.innerHTML = `It's a <strong>tie</strong>!`;
        updateScore();
        return;
      }

      // Rule 2: After first two moves, blank out THREE random empty squares once
      if (moveCount === 2 && blanked.size === 0) {
        blankOutThree();
        render();

        const postBlank = checkGame();
        if (postBlank.tie) {
          gameOver = true;
          score.T += 1;
          statusEl.innerHTML = `It's a <strong>tie</strong>!`;
          updateScore();
          return;
        }
      }

      // Next player
      currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
      statusEl.innerHTML = `Player <strong>${currentPlayer}</strong>'s turn`;

      // Re-render so the center "temp disabled" visual updates correctly on turn changes
      render();
    }

    function blankOutThree() {
      const empties = [];
      for (let i = 0; i < board.length; i++) {
        if (board[i] !== null) continue;
        empties.push(i);
      }
      shuffle(empties);
      const take = Math.min(3, empties.length);
      for (let k = 0; k < take; k++) blanked.add(empties[k]);
    }

    // Check for any K-in-a-row on a NxN board
    function checkGame() {
      const dirs = [
        [0, 1],  // right
        [1, 0],  // down
        [1, 1],  // down-right
        [1,-1]   // down-left
      ];

      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          const start = board[idx(r, c)];
          if (!start) continue;

          for (const [dr, dc] of dirs) {
            const line = [idx(r, c)];
            let ok = true;

            for (let step = 1; step < K; step++) {
              const rr = r + dr * step;
              const cc = c + dc * step;
              if (rr < 0 || rr >= N || cc < 0 || cc >= N) { ok = false; break; }
              const id = idx(rr, cc);
              if (board[id] !== start) { ok = false; break; }
              line.push(id);
            }

            if (ok) return { winner: start, line };
          }
        }
      }

      // Tie if all playable squares are filled (blanked squares don't need filling)
      const filledPlayable = board.every((v, i) => v !== null || blanked.has(i));
      if (filledPlayable) return { tie: true };

      return {};
    }

    function render() {
      const cells = boardEl.querySelectorAll('.cell');
      cells.forEach((cell, i) => {
        cell.textContent = board[i] || '';
        cell.classList.remove('x', 'o', 'win', 'blanked', 'tempDisabled');

        if (blanked.has(i)) {
          cell.classList.add('blanked');
          cell.textContent = ''; // truly "blanked out"
          return;
        }

        if (isTempDisabled(i)) {
          cell.classList.add('tempDisabled');
          cell.textContent = '';
          return;
        }

        if (board[i] === 'X') cell.classList.add('x');
        if (board[i] === 'O') cell.classList.add('o');
      });
    }

    function highlightWin(line) {
      const cells = boardEl.querySelectorAll('.cell');
      line.forEach(i => {
        if (!blanked.has(i)) cells[i].classList.add('win');
      });
    }

    function updateScore() {
      scoreEl.textContent = `Score — X: ${score.X} | O: ${score.O} | Ties: ${score.T}`;
    }

    function resetGame() {
      board = Array(N * N).fill(null);
      blanked = new Set();
      currentPlayer = 'X';
      gameOver = false;

      moveCount = 0;
      xHasMoved = false;

      statusEl.innerHTML = `Player <strong>X</strong>'s turn`;
      createBoard();
      render();
    }

    newGameBtn.addEventListener('click', resetGame);

    clearScoreBtn.addEventListener('click', () => {
      score = { X: 0, O: 0, T: 0 };
      updateScore();
      resetGame();
    });

    createBoard();
    updateScore();
    render();
  </script>
</body>
</html>
