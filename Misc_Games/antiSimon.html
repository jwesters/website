<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ANTI-SIMON (Avoid the Pattern)</title>
  <style>
    :root{
      --bg:#0f1220;
      --panel:#151a2e;
      --text:#e9ecff;
      --muted:#aab1da;
      --good:#2ee59d;
      --bad:#ff4d6d;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background: radial-gradient(1200px 800px at 30% 20%, #1a2250 0%, var(--bg) 55%, #070912 100%);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    .wrap{
      width:min(980px, 94vw);
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:22px;
      align-items:stretch;
    }
    @media (max-width: 860px){
      .wrap{ grid-template-columns: 1fr; }
    }
    .card{
      background: color-mix(in srgb, var(--panel) 92%, black 8%);
      border: 1px solid rgba(255,255,255,.08);
      border-radius:16px;
      box-shadow: 0 18px 50px rgba(0,0,0,.35);
      padding:18px;
    }

    /* Board */
    .boardBox{
      display:flex;
      flex-direction:column;
      gap:14px;
      align-items:center;
      justify-content:center;
    }
    .board{
      position:relative;
      width:min(420px, 78vw);
      aspect-ratio:1/1;
      border-radius:50%;
      overflow:hidden;
      background:#000;
      border: 10px solid rgba(255,255,255,.06);
      box-shadow:
        inset 0 0 0 6px rgba(0,0,0,.35),
        0 18px 45px rgba(0,0,0,.40);
      user-select:none;
      touch-action: manipulation;
    }
    .quad{
      position:absolute;
      width:50%;
      height:50%;
      cursor:pointer;
      opacity:.95;
      transition: filter 120ms ease, transform 120ms ease, opacity 120ms ease;
      outline:none;
      border:0;
    }
    .quad:active{ transform: scale(0.985); }

    .red{ left:0; top:0; background:#e53935; border-right:6px solid rgba(0,0,0,.25); border-bottom:6px solid rgba(0,0,0,.25); }
    .green{ right:0; top:0; background:#43a047; border-left:6px solid rgba(0,0,0,.25); border-bottom:6px solid rgba(0,0,0,.25); }
    .yellow{ left:0; bottom:0; background:#f6c026; border-right:6px solid rgba(0,0,0,.25); border-top:6px solid rgba(0,0,0,.25); }
    .blue{ right:0; bottom:0; background:#1e88e5; border-left:6px solid rgba(0,0,0,.25); border-top:6px solid rgba(0,0,0,.25); }

    .center{
      position:absolute;
      inset: 50%;
      transform: translate(-50%, -50%);
      width:44%;
      height:44%;
      border-radius:50%;
      background: radial-gradient(circle at 35% 25%, #2a3160 0%, #121736 45%, #0a0d20 100%);
      border: 10px solid rgba(0,0,0,.38);
      box-shadow:
        0 10px 30px rgba(0,0,0,.45),
        inset 0 0 0 2px rgba(255,255,255,.08);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:10px;
      gap:6px;
      pointer-events:none;
    }
    .title{
      font-weight:900;
      letter-spacing:.6px;
      font-size:16px;
      opacity:.98;
    }

    .flash{
      filter: brightness(1.55) saturate(1.25);
      opacity: 1;
    }
    .disabled{
      cursor:not-allowed;
      opacity:.6;
    }

    /* Side panel */
    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      margin-bottom:10px;
    }
    .stat{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .pill{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      border-radius:999px;
      padding:8px 12px;
      font-size:13px;
      display:flex;
      gap:8px;
      align-items:baseline;
    }
    .pill b{ font-size:14px; }

    .btns{ display:flex; gap:10px; flex-wrap:wrap; }
    button.ui{
      appearance:none;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      font-weight:800;
      cursor:pointer;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
    }
    button.ui:hover{
      background: rgba(255,255,255,.12);
      border-color: rgba(255,255,255,.22);
    }
    button.ui:active{ transform: translateY(1px); }
    button.ui.primary{
      background: rgba(46,229,157,.18);
      border-color: rgba(46,229,157,.35);
    }
    button.ui.danger{
      background: rgba(255,77,109,.14);
      border-color: rgba(255,77,109,.35);
    }

    .status{
      margin-top:10px;
      padding:12px;
      border-radius:12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      min-height:44px;
      font-size:14px;
      line-height:1.25;
    }
    .status.good{ border-color: rgba(46,229,157,.35); }
    .status.bad{ border-color: rgba(255,77,109,.35); }

    .hsTitle{
      margin:14px 0 8px;
      font-weight:900;
      letter-spacing:.2px;
      opacity:.95;
    }
    .hsList{
      list-style:none;
      padding:0;
      margin:0;
      border: 1px solid rgba(255,255,255,.10);
      border-radius:12px;
      overflow:hidden;
      background: rgba(0,0,0,.18);
    }
    .hsList li{
      display:flex;
      justify-content:space-between;
      padding:10px 12px;
      border-top: 1px solid rgba(255,255,255,.08);
      font-size:14px;
    }
    .hsList li:first-child{ border-top:none; }
    .hsList .rank{
      opacity:.7;
      width:28px;
      display:inline-block;
    }
    .hsList .date{
      opacity:.65;
      font-size:12px;
      margin-left:10px;
      white-space:nowrap;
    }

    .hint{
      margin-top:10px;
      color:var(--muted);
      font-size:12px;
      line-height:1.25;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px;
      padding:2px 6px;
      border-radius:7px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
    }

    /* Game Over Overlay */
    .overlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.72);
      backdrop-filter: blur(6px);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:9999;
    }
    .overlay.show{ display:flex; }
    .modal{
      width:min(560px, 94vw);
      background: rgba(20, 24, 50, .92);
      border: 1px solid rgba(255,255,255,.12);
      border-radius:18px;
      box-shadow: 0 30px 90px rgba(0,0,0,.55);
      padding:18px;
      text-align:center;
    }
    .modal h1{
      margin:8px 0 6px;
      font-size:38px;
      letter-spacing:1px;
    }
    .modal .sub{
      margin:0 0 14px;
      color:var(--muted);
      font-size:14px;
      line-height:1.3;
    }
    .modal .bigScore{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
      margin:12px 0 18px;
    }
    .modal .bigScore .chip{
      border-radius:999px;
      padding:10px 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.20);
      font-weight:900;
    }
    .modal .actions{
      display:flex;
      gap:12px;
      justify-content:center;
      flex-wrap:wrap;
      margin-top:6px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card boardBox" aria-label="Game board">
      <div class="board" id="board" role="application" aria-label="Anti-Simon board">
        <button class="quad red"    data-color="red"    aria-label="Red"></button>
        <button class="quad green"  data-color="green"  aria-label="Green"></button>
        <button class="quad yellow" data-color="yellow" aria-label="Yellow"></button>
        <button class="quad blue"   data-color="blue"   aria-label="Blue"></button>

        <div class="center" aria-hidden="true">
          <div class="title">ANTI-SIMON</div>
        </div>
      </div>
      <div class="hint">
        Watch the pattern, then click a color for each step — but you must <b>avoid</b> the shown color(s) on that step.
        <br/>Keys: <span class="kbd">Enter</span> start • <span class="kbd">M</span> mute • <span class="kbd">R</span> reset highscores
      </div>
    </div>

    <div class="card">
      <div class="row">
        <div class="stat">
          <div class="pill">Round: <b id="roundNow">0</b></div>
          <div class="pill">Correct (this run): <b id="correctNow">0</b></div>
          <div class="pill">Best: <b id="bestNow">0</b></div>
          <div class="pill">Sound: <b id="soundNow">On</b></div>
        </div>
        <div class="btns">
          <button class="ui primary" id="startBtn">Start</button>
          <button class="ui" id="restartBtn">Restart</button>
          <button class="ui" id="muteBtn">Mute</button>
          <button class="ui danger" id="clearBtn" title="Clears local high scores">Clear High Scores</button>
        </div>
      </div>

      <div id="status" class="status">
        Press <b>Start</b>. The game will show a pattern. On your turn, avoid the shown color(s) for each step.
      </div>

      <div class="hsTitle">High Scores (local)</div>
      <ol id="hsList" class="hsList"></ol>
    </div>
  </div>

  <!-- Big Game Over screen -->
  <div class="overlay" id="overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Game Over">
      <h1>GAME OVER</h1>
      <p class="sub" id="goReason">You matched the pattern.</p>
      <div class="bigScore">
        <div class="chip">Score: <span id="goScore">0</span></div>
        <div class="chip">Round: <span id="goRound">0</span></div>
        <div class="chip">Best: <span id="goBest">0</span></div>
      </div>
      <div class="actions">
        <button class="ui primary" id="goPlayAgain">Play Again</button>
        <button class="ui" id="goClose">Close</button>
      </div>
      <p class="sub" style="margin-top:12px;">Tip: at Round 6 the pattern starts showing <b>two</b> colors per step, and at Round 9 it shows <b>three</b>.</p>
    </div>
  </div>

  <script>
    (() => {
      const COLORS = ["red", "green", "blue", "yellow"];

      // Timing (dynamic): starts here and speeds up after round 3, then a bit each round
      const BASE_ON_MS = 520;
      const BASE_GAP_MS = 170;
      const MIN_ON_MS = 180;
      const MIN_GAP_MS = 60;

      const AFTER_SHOW_PAUSE_MS = 220;

      const pads = Array.from(document.querySelectorAll(".quad"));
      const statusEl = document.getElementById("status");
      const roundEl = document.getElementById("roundNow");
      const correctEl = document.getElementById("correctNow");
      const bestEl = document.getElementById("bestNow");
      const soundEl = document.getElementById("soundNow");
      const hsListEl = document.getElementById("hsList");

      const startBtn = document.getElementById("startBtn");
      const restartBtn = document.getElementById("restartBtn");
      const clearBtn = document.getElementById("clearBtn");
      const muteBtn = document.getElementById("muteBtn");

      const overlay = document.getElementById("overlay");
      const goReason = document.getElementById("goReason");
      const goScore = document.getElementById("goScore");
      const goRound = document.getElementById("goRound");
      const goBest = document.getElementById("goBest");
      const goPlayAgain = document.getElementById("goPlayAgain");
      const goClose = document.getElementById("goClose");

      const STORAGE_KEY = "anti_simon_highscores_v3";
      const MAX_SCORES = 10;

      // Pattern: each step is an array of forbidden colors (length 1, 2, or 3)
      let pattern = [];
      let round = 0;
      let correct = 0;
      let stepIndex = 0;

      let playing = false;
      let accepting = false;
      let showing = false;

      // Sound
      let audioCtx = null;
      let soundOn = true;

      // Frequencies per color (pleasant-ish)
      const FREQ = {
        red: 261.63,   // C4
        green: 329.63, // E4
        blue: 392.00,  // G4
        yellow: 493.88 // B4
      };

      function ensureAudio(){
        if(audioCtx) return;
        const AC = window.AudioContext || window.webkitAudioContext;
        if(!AC) return; // no audio support
        audioCtx = new AC();
      }

      function playTone(color, durationMs = 140){
        if(!soundOn) return;
        ensureAudio();
        if(!audioCtx) return;

        // iOS sometimes needs resume on user gesture
        if(audioCtx.state === "suspended"){
          audioCtx.resume().catch(()=>{});
        }

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = "sine";
        osc.frequency.value = FREQ[color] || 440;

        // quick envelope
        const now = audioCtx.currentTime;
        const dur = Math.max(0.05, durationMs / 1000);

        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.12, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        osc.start(now);
        osc.stop(now + dur + 0.02);
      }

      function playTones(colors, durationMs){
        // play “chord” by starting multiple oscillators
        colors.forEach(c => playTone(c, durationMs));
      }

      function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

      function padByColor(color){
        return pads.find(p => p.dataset.color === color);
      }

      function setPadsEnabled(on){
        pads.forEach(p => {
          p.disabled = !on;
          p.classList.toggle("disabled", !on);
        });
      }

      function setStatus(msg, kind){
        statusEl.classList.remove("good","bad");
        if(kind) statusEl.classList.add(kind);
        statusEl.innerHTML = msg;
      }

      function flashPads(colors, onMs){
        // flash all at once
        const els = colors.map(padByColor).filter(Boolean);
        els.forEach(el => el.classList.add("flash"));
        playTones(colors, Math.min(220, onMs)); // match-ish

        return sleep(onMs).then(() => {
          els.forEach(el => el.classList.remove("flash"));
        });
      }

      function nowStamp(){
        const d = new Date();
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth()+1).padStart(2,"0");
        const dd = String(d.getDate()).padStart(2,"0");
        const hh = String(d.getHours()).padStart(2,"0");
        const mi = String(d.getMinutes()).padStart(2,"0");
        return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
      }

      function getScores(){
        try{
          const raw = localStorage.getItem(STORAGE_KEY);
          const arr = raw ? JSON.parse(raw) : [];
          return Array.isArray(arr) ? arr : [];
        }catch{
          return [];
        }
      }
      function saveScores(arr){
        localStorage.setItem(STORAGE_KEY, JSON.stringify(arr));
      }
      function bestScore(){
        const arr = getScores();
        return arr.length ? Math.max(...arr.map(s => s.score)) : 0;
      }
      function renderScores(){
        const arr = getScores()
          .slice()
          .sort((a,b) => b.score - a.score)
          .slice(0, MAX_SCORES);

        hsListEl.innerHTML = "";
        if(arr.length === 0){
          const li = document.createElement("li");
          li.innerHTML = `<span><span class="rank">—</span>No scores yet</span><span class="date"></span>`;
          hsListEl.appendChild(li);
        }else{
          arr.forEach((s, idx) => {
            const li = document.createElement("li");
            li.innerHTML = `
              <span><span class="rank">${idx+1}.</span> ${s.score}</span>
              <span class="date">${s.when}</span>
            `;
            hsListEl.appendChild(li);
          });
        }
        bestEl.textContent = String(bestScore());
      }

      function openGameOver(reasonText){
        const best = bestScore();
        goReason.innerHTML = reasonText;
        goScore.textContent = String(correct);
        goRound.textContent = String(round);
        goBest.textContent = String(best);

        overlay.classList.add("show");
        overlay.setAttribute("aria-hidden", "false");
      }
      function closeGameOver(){
        overlay.classList.remove("show");
        overlay.setAttribute("aria-hidden", "true");
      }

      function uniqueRandomColors(k){
        const pool = COLORS.slice();
        for(let i = pool.length - 1; i > 0; i--){
          const j = Math.floor(Math.random() * (i + 1));
          [pool[i], pool[j]] = [pool[j], pool[i]];
        }
        return pool.slice(0, k);
      }

      function forbiddenCountForRound(r){
        if(r >= 9) return 3;
        if(r >= 6) return 2;
        return 1;
      }

      function timingForRound(r){
        // After 3 rounds, speed up by a noticeable chunk, then a little each round.
        // r is 1-based round number
        let on = BASE_ON_MS;
        let gap = BASE_GAP_MS;

        if(r >= 4){
          // big step at round 4
          on -= 140;
          gap -= 50;
          // continue reducing a bit each round beyond 4
          const extra = (r - 4);
          on -= extra * 28;
          gap -= extra * 10;
        }

        on = Math.max(MIN_ON_MS, on);
        gap = Math.max(MIN_GAP_MS, gap);
        return { on, gap };
      }

      async function showPattern(){
        showing = true;
        accepting = false;
        setPadsEnabled(false);

        const { on, gap } = timingForRound(round);

        setStatus(`Pattern length: <b>${pattern.length}</b>.`, null);

        await sleep(140);

        for(const forbiddens of pattern){
          await flashPads(forbiddens, on);
          await sleep(gap);
        }

        await sleep(AFTER_SHOW_PAUSE_MS);

        showing = false;
        accepting = true;
        setPadsEnabled(true);

        setStatus(`Your turn.`, null);
      }

      async function startNewRound(){
        round += 1;
        roundEl.textContent = String(round);

        const k = forbiddenCountForRound(round);
        pattern.push(uniqueRandomColors(k)); // step = array of forbidden colors
        stepIndex = 0;

        await showPattern();
      }

      function endGame(reasonHtml){
        playing = false;
        accepting = false;
        showing = false;
        setPadsEnabled(false);

        // Save score if > 0
        if(correct > 0){
          const arr = getScores();
          arr.push({ score: correct, when: nowStamp() });
          arr.sort((a,b) => b.score - a.score);
          saveScores(arr.slice(0, Math.max(MAX_SCORES * 3, 30)));
        }
        renderScores();

        setStatus(`<b>Game over.</b> Final score: <b>${correct}</b>.`, "bad");
        openGameOver(reasonHtml);
      }

      async function startGame(){
        closeGameOver();

        pattern = [];
        round = 0;
        correct = 0;
        stepIndex = 0;

        roundEl.textContent = "0";
        correctEl.textContent = "0";

        playing = true;
        setPadsEnabled(false);
        setStatus("Starting…", null);

        await startNewRound();
      }

      async function handlePick(color){
        if(!playing || !accepting || showing) return;

        // click feedback
        const el = padByColor(color);
        if(el){
          el.classList.add("flash");
          setTimeout(() => el.classList.remove("flash"), 110);
        }
        playTone(color, 120);

        const forbiddens = pattern[stepIndex]; // array

        // Lose condition: user clicks any forbidden color for this step
        if(forbiddens.includes(color)){
          const stepNum = stepIndex + 1;
          const shown = forbiddens.map(c => c.toUpperCase()).join(" + ");
          endGame(`You picked a shown color on step <b>${stepNum}</b> (<b>${shown}</b>).`);
          return;
        }

        // Successful step
        correct += 1;
        correctEl.textContent = String(correct);

        stepIndex += 1;

        // Finished entire pattern correctly → next round
        if(stepIndex >= pattern.length){
          accepting = false;
          setPadsEnabled(false);
          setStatus(`Round <b>${round}</b> cleared.`, "good");
          await sleep(420);
          await startNewRound();
        }
      }

      // UI events
      pads.forEach(p => p.addEventListener("click", () => handlePick(p.dataset.color)));

      startBtn.addEventListener("click", startGame);
      restartBtn.addEventListener("click", startGame);

      muteBtn.addEventListener("click", () => {
        soundOn = !soundOn;
        soundEl.textContent = soundOn ? "On" : "Off";
        muteBtn.textContent = soundOn ? "Mute" : "Unmute";
        // try to unlock audio context on toggle (some browsers)
        if(soundOn) ensureAudio();
      });

      clearBtn.addEventListener("click", () => {
        localStorage.removeItem(STORAGE_KEY);
        renderScores();
        bestEl.textContent = String(bestScore());
        setStatus("High scores cleared (local).", null);
      });

      goPlayAgain.addEventListener("click", startGame);
      goClose.addEventListener("click", closeGameOver);

      overlay.addEventListener("click", (e) => {
        if(e.target === overlay) closeGameOver();
      });

      window.addEventListener("keydown", (e) => {
        if(e.key === "Enter"){
          e.preventDefault();
          startGame();
        }
        if(e.key.toLowerCase() === "m"){
          soundOn = !soundOn;
          soundEl.textContent = soundOn ? "On" : "Off";
          muteBtn.textContent = soundOn ? "Mute" : "Unmute";
          if(soundOn) ensureAudio();
        }
        if(e.key.toLowerCase() === "r"){
          localStorage.removeItem(STORAGE_KEY);
          renderScores();
          bestEl.textContent = String(bestScore());
          setStatus("High scores cleared (local).", null);
        }
        if(e.key === "Escape"){
          closeGameOver();
        }
      });

      // Init
      setPadsEnabled(false);
      renderScores();
      bestEl.textContent = String(bestScore());
      soundEl.textContent = "On";
    })();
  </script>
</body>
</html>
