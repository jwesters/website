<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ataxx (2–4 Players)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111a33;
      --panel2:#0f1730;
      --text:#e8ecff;
      --muted:#b8c0e6;
      --line:rgba(255,255,255,.14);
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius: 18px;
      --cell: 46px;
      --gap: 6px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 900px at 15% 10%, #18265b 0%, transparent 55%),
                  radial-gradient(1000px 800px at 85% 20%, #2b1b54 0%, transparent 55%),
                  linear-gradient(180deg, #070a14 0%, #0b1020 60%, #070a14 100%);
      color:var(--text);
      min-height:100vh;
      display:flex;
      align-items:stretch;
      justify-content:center;
    }
    .wrap{
      width:min(1180px, 96vw);
      padding:18px 0 26px;
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:16px;
      margin:0 auto;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns: 1fr}
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card h2{
      margin:0;
      padding:16px 16px 10px;
      font-size: 16px;
      letter-spacing:.2px;
    }
    .card .content{ padding: 0 16px 16px; }
    .row{ display:flex; gap:10px; align-items:center; }
    .row + .row{ margin-top:10px; }
    .row label{
      flex: 1 0 140px;
      color: var(--muted);
      font-size: 13px;
    }
    select, button, input[type="checkbox"]{
      font: inherit;
    }
    select, .btn, .pill{
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(15,23,48,.65);
      color: var(--text);
      padding:10px 12px;
      outline:none;
      box-shadow: 0 6px 18px rgba(0,0,0,.22);
    }
    select{ width: 100%; }
    select:disabled, .btn:disabled{
      opacity:.6;
      cursor:not-allowed;
      filter:saturate(.85);
    }
    .btn{
      cursor:pointer;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
      user-select:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      font-weight: 650;
    }
    .btn:hover{ transform: translateY(-1px); border-color: rgba(255,255,255,.28); }
    .btn.primary{
      background: linear-gradient(180deg, rgba(124,92,255,.95), rgba(95,70,230,.95));
      border-color: rgba(124,92,255,.75);
    }
    .btn.ghost{
      background: rgba(15,23,48,.35);
    }
    .btn.small{ padding:8px 10px; border-radius: 10px; font-weight: 650; }
    .muted{ color: var(--muted); font-size: 13px; line-height: 1.3; }
    .tiny{ color: rgba(232,236,255,.78); font-size: 12px; }

    .divider{
      height:1px;
      background: rgba(255,255,255,.12);
      margin: 14px 0;
    }

    /* Board area */
    .boardCard{
      display:flex;
      flex-direction:column;
      min-height: 540px;
    }
    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
    }
    .titleBlock{
      display:flex;
      flex-direction:column;
      gap:4px;
      min-width: 240px;
    }
    .titleBlock .title{
      font-weight: 800;
      letter-spacing:.2px;
      font-size: 16px;
    }
    .turnLine{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .turnBadge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(15,23,48,.55);
      font-weight: 750;
      letter-spacing:.2px;
      box-shadow: 0 8px 20px rgba(0,0,0,.22);
    }
    .dot{
      width:12px; height:12px; border-radius:999px;
      background: #fff;
      box-shadow: 0 0 0 3px rgba(255,255,255,.12);
    }
    .scores{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .scorePill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(15,23,48,.35);
      font-weight: 700;
      font-size: 13px;
    }
    .scorePill .miniDot{ width:10px; height:10px; border-radius:999px; }
    .boardWrap{
      padding: 14px;
      display:flex;
      align-items:center;
      justify-content:center;
      flex: 1 1 auto;
    }
    .grid{
      display:grid;
      gap: var(--gap);
      padding: 12px;
      background: rgba(7,10,20,.55);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 18px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.05), 0 18px 50px rgba(0,0,0,.35);
      max-width: 100%;
      overflow: auto;
    }
    .cell{
      width: var(--cell);
      height: var(--cell);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      cursor:pointer;
      position:relative;
      outline:none;
      display:flex;
      align-items:center;
      justify-content:center;
      transition: transform .08s ease, border-color .15s ease, background .15s ease, box-shadow .15s ease;
      user-select:none;
    }
    .cell:hover{
      transform: translateY(-1px);
      border-color: rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
    }
    .piece{
      width: 78%;
      height: 78%;
      border-radius: 999px;
      box-shadow:
        0 10px 20px rgba(0,0,0,.25),
        inset 0 0 0 3px rgba(255,255,255,.18);
      position: relative;
    }
    .piece::after{
      content:"";
      position:absolute;
      inset: 18% 18% auto auto;
      width: 24%;
      height: 24%;
      border-radius:999px;
      background: rgba(255,255,255,.26);
      filter: blur(.1px);
    }

    .selected{
      outline: 3px solid rgba(255,255,255,.26);
      box-shadow: 0 0 0 6px rgba(124,92,255,.18);
      border-color: rgba(124,92,255,.55) !important;
    }
    .legalDest{
      border-color: rgba(120, 245, 210, .55) !important;
      box-shadow: 0 0 0 5px rgba(120,245,210,.12);
    }
    .legalDest::before{
      content:"";
      position:absolute;
      inset: 12px;
      border-radius: 10px;
      border: 2px dashed rgba(120,245,210,.55);
      opacity: .9;
      pointer-events:none;
    }

    .lastMove{
      box-shadow: 0 0 0 4px rgba(255,255,255,.08), 0 0 0 10px rgba(255,212,107,.14);
      border-color: rgba(255,212,107,.45) !important;
    }
    @keyframes pulse {
      0%{ transform: scale(1); }
      50%{ transform: scale(1.04); }
      100%{ transform: scale(1); }
    }
    .pulse .piece{
      animation: pulse 1.1s ease-in-out infinite;
    }

    /* Setup players */
    .playerBox{
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(15,23,48,.35);
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-top:10px;
    }
    .playerHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .playerName{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight: 800;
      letter-spacing:.2px;
      font-size: 13px;
    }
    .colorChip{
      width: 14px;
      height: 14px;
      border-radius: 999px;
      box-shadow: 0 0 0 3px rgba(255,255,255,.12);
    }

    .inline2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px;
    }

    .hint{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      color: rgba(232,236,255,.82);
      font-size: 12.5px;
      line-height: 1.35;
    }

    /* Modal */
    .modalBackdrop{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.62);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 50;
    }
    .modal{
      width:min(560px, 96vw);
      border-radius: 20px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(17,26,51,.98), rgba(12,18,38,.98));
      box-shadow: 0 22px 70px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .modalHeader{
      padding: 16px 16px 10px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
    }
    .modalHeader h3{ margin:0; font-size: 16px; }
    .modalBody{ padding: 12px 16px; }
    .modalActions{
      padding: 14px 16px 16px;
      display:flex;
      gap:10px;
      justify-content:flex-end;
      border-top: 1px solid rgba(255,255,255,.10);
    }

    .banner{
      display:none;
      margin-top:10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,212,107,.10);
      color: rgba(232,236,255,.95);
      font-size: 12.5px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" id="setupCard">
      <h2>Game Setup</h2>
      <div class="content">
        <div class="row">
          <label for="boardSize">Board size</label>
          <select id="boardSize">
            <option value="7">7 × 7</option>
            <option value="9">9 × 9</option>
            <option value="11">11 × 11</option>
          </select>
        </div>

        <div class="row">
          <label for="numPlayers">Players</label>
          <select id="numPlayers">
            <option value="2">2 players</option>
            <option value="3">3 players</option>
            <option value="4">4 players</option>
          </select>
        </div>

        <div class="row" style="align-items:center;">
          <label for="showHints">Show legal moves</label>
          <div style="display:flex; align-items:center; gap:10px; justify-content:flex-end; width: 100%;">
            <input type="checkbox" id="showHints" checked />
            <span class="tiny">Highlights destinations after selecting a piece</span>
          </div>
        </div>

        <div class="divider"></div>

        <div id="playersConfig"></div>

        <div class="divider"></div>

        <div class="row">
          <button class="btn primary" id="startBtn" style="width:100%;">Start Game</button>
        </div>

        <div class="hint">
          <b>How to play</b><br/>
          Select one of your pieces, then click an empty square within distance 1 (clone) or 2 (jump). After moving, all adjacent opponent tiles convert to your color.
          If you have no legal move, you automatically pass. Players with 0 tiles are eliminated. The game ends when the board is full, everyone passes in a row, or only one player has tiles.
        </div>
      </div>
    </div>

    <div class="card boardCard">
      <div class="topbar">
        <div class="titleBlock">
          <div class="title">Ataxx</div>
          <div class="turnLine">
            <div class="turnBadge" id="turnBadge">
              <span class="dot" id="turnDot"></span>
              <span id="turnText">Set up a game</span>
            </div>
            <button class="btn small ghost" id="newGameBtn" title="Return to setup">New Game</button>
          </div>
          <div class="banner" id="viewingBanner">Game over — viewing board. Start a new game to play again.</div>
        </div>
        <div class="scores" id="scores"></div>
      </div>

      <div class="boardWrap">
        <div class="grid" id="grid" aria-label="Ataxx board"></div>
      </div>
    </div>
  </div>

  <div class="modalBackdrop" id="modalBackdrop" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modalHeader">
        <div>
          <h3 id="modalTitle">Game Over</h3>
          <div class="muted" id="modalSubtitle"></div>
        </div>
      </div>
      <div class="modalBody">
        <div id="modalScores" class="muted"></div>
      </div>
      <div class="modalActions">
        <button class="btn ghost" id="viewBoardBtn">View Board</button>
        <button class="btn primary" id="restartBtn">New Game</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const COLORS = [
    { name: "Player 1", color: "#58a6ff" }, // blue
    { name: "Player 2", color: "#ff6b6b" }, // red
    { name: "Player 3", color: "#7ef0d7" }, // teal
    { name: "Player 4", color: "#c77dff" }  // purple
  ];

  const el = (id) => document.getElementById(id);
  const gridEl = el("grid");
  const boardSizeEl = el("boardSize");
  const numPlayersEl = el("numPlayers");
  const showHintsEl = el("showHints");
  const playersConfigEl = el("playersConfig");
  const startBtn = el("startBtn");
  const newGameBtn = el("newGameBtn");
  const scoresEl = el("scores");
  const turnDotEl = el("turnDot");
  const turnTextEl = el("turnText");
  const viewingBannerEl = el("viewingBanner");

  const modalBackdrop = el("modalBackdrop");
  const modalTitle = el("modalTitle");
  const modalSubtitle = el("modalSubtitle");
  const modalScores = el("modalScores");
  const viewBoardBtn = el("viewBoardBtn");
  const restartBtn = el("restartBtn");

  // Game state
  let N = 7;
  let P = 2;
  let players = []; // {type:'human'|'cpu', difficulty:'easy'|'medium'|'hard', eliminated:false}
  let board = []; // Int8Array length N*N. 0 empty, 1..P player id.
  let active = false;
  let current = 1;
  let selected = null; // {r,c}
  let legalDests = null; // Set index
  let lastMoveIdx = null;
  let viewingBoard = false;

  // pass tracking
  let consecutivePasses = 0;

  // CPU thinking
  let cpuBusy = false;

  function idx(r,c){ return r*N + c; }
  function rc(i){ return { r: Math.floor(i/N), c: i%N }; }
  function inb(r,c){ return r>=0 && r<N && c>=0 && c<N; }

  function clampCellSize(){
    const wrapWidth = Math.min((window.innerWidth*0.96), 1180);
    const available = wrapWidth - 360 - 16 - 80;
    const maxBoardPx = Math.max(320, available);
    const gap = (N>=11 ? 5 : 6);
    const padding = 24;
    const maxCell = Math.floor((maxBoardPx - padding - (N-1)*gap)/N);
    const cell = Math.max(34, Math.min(54, maxCell));
    document.documentElement.style.setProperty("--cell", cell + "px");
    document.documentElement.style.setProperty("--gap", gap + "px");
  }

  function renderPlayersConfig(){
    playersConfigEl.innerHTML = "";
    const p = parseInt(numPlayersEl.value, 10);

    for(let i=1;i<=p;i++){
      const box = document.createElement("div");
      box.className = "playerBox";
      const head = document.createElement("div");
      head.className = "playerHead";

      const name = document.createElement("div");
      name.className = "playerName";
      const chip = document.createElement("span");
      chip.className = "colorChip";
      chip.style.background = COLORS[i-1].color;
      name.appendChild(chip);
      name.appendChild(document.createTextNode(COLORS[i-1].name));

      head.appendChild(name);

      const tag = document.createElement("span");
      tag.className = "tiny";
      tag.textContent = (i===1) ? "Human (fixed)" : "Human or CPU";
      head.appendChild(tag);

      box.appendChild(head);

      if(i===1){
        const note = document.createElement("div");
        note.className = "muted";
        note.textContent = "Player 1 is always human.";
        box.appendChild(note);
      }else{
        const inline = document.createElement("div");
        inline.className = "inline2";

        const typeSel = document.createElement("select");
        typeSel.id = `ptype_${i}`;
        typeSel.innerHTML = `
          <option value="human">Human</option>
          <option value="cpu" selected>Computer</option>
        `;

        const diffSel = document.createElement("select");
        diffSel.id = `pdiff_${i}`;
        diffSel.innerHTML = `
          <option value="easy">Easy</option>
          <option value="medium" selected>Medium</option>
          <option value="hard">Hard</option>
        `;

        inline.appendChild(typeSel);
        inline.appendChild(diffSel);
        box.appendChild(inline);

        const hint = document.createElement("div");
        hint.className = "tiny";
        hint.textContent = "Difficulty applies only if set to Computer.";
        box.appendChild(hint);

        typeSel.addEventListener("change", () => {
          diffSel.disabled = (typeSel.value !== "cpu");
        });
        diffSel.disabled = (typeSel.value !== "cpu");
      }

      playersConfigEl.appendChild(box);
    }
  }

  function initSetup(){
    active = false;
    viewingBoard = false;
    viewingBannerEl.style.display = "none";
    cpuBusy = false;
    selected = null;
    legalDests = null;
    lastMoveIdx = null;
    consecutivePasses = 0;

    N = parseInt(boardSizeEl.value, 10);
    P = parseInt(numPlayersEl.value, 10);

    // Build players
    players = [];
    players.push({ type: "human", difficulty: "medium", eliminated:false });
    for(let i=2;i<=P;i++){
      const typeSel = el(`ptype_${i}`);
      const diffSel = el(`pdiff_${i}`);
      const type = typeSel ? typeSel.value : "cpu";
      const diff = diffSel ? diffSel.value : "medium";
      players.push({ type, difficulty: diff, eliminated:false });
    }

    // Init board and starting positions (Option A)
    board = new Int8Array(N*N);
    for(let i=0;i<board.length;i++) board[i]=0;
    placeStarts();

    current = 1;
    updateEliminations();
    renderBoard();
    renderScores();
    renderTurn();
    clampCellSize();
  }

  function placeStarts(){
    const corners = [
      { r:0, c:0 },                 // TL
      { r:0, c:N-1 },               // TR
      { r:N-1, c:0 },               // BL
      { r:N-1, c:N-1 }              // BR
    ];

    function put(pid, corner){
      const r = corner.r, c = corner.c;
      board[idx(r,c)] = pid;
      const dr = (r===0) ? 1 : -1;
      const dc = (c===0) ? 1 : -1;
      board[idx(r+dr, c+dc)] = pid;
    }

    if(P===2){
      put(1, corners[0]); // TL
      put(2, corners[3]); // BR
    }else if(P===3){
      put(1, corners[0]); // TL
      put(2, corners[1]); // TR
      put(3, corners[2]); // BL
      // BR empty
    }else{
      put(1, corners[0]); // TL
      put(2, corners[1]); // TR
      put(3, corners[2]); // BL
      put(4, corners[3]); // BR
    }
  }

  function renderBoard(){
    gridEl.innerHTML = "";
    gridEl.style.gridTemplateColumns = `repeat(${N}, var(--cell))`;

    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        const i = idx(r,c);
        const btn = document.createElement("button");
        btn.className = "cell";
        btn.type = "button";
        btn.setAttribute("data-i", String(i));
        btn.setAttribute("aria-label", `Cell ${r+1}, ${c+1}`);

        const v = board[i];
        if(v !== 0){
          const p = document.createElement("div");
          p.className = "piece";
          p.style.background = COLORS[v-1].color;
          btn.appendChild(p);
        }

        btn.addEventListener("click", () => onCellClick(i));
        gridEl.appendChild(btn);
      }
    }
    applyHighlights();
  }

  function applyHighlights(){
    const children = gridEl.children;
    for(let i=0;i<children.length;i++){
      const cell = children[i];
      cell.classList.remove("selected","legalDest","lastMove","pulse");
      const idxCell = parseInt(cell.getAttribute("data-i"),10);

      if(selected && idxCell === idx(selected.r, selected.c)) cell.classList.add("selected");
      if(showHintsEl.checked && legalDests && legalDests.has(idxCell)) cell.classList.add("legalDest");
      if(lastMoveIdx !== null && idxCell === lastMoveIdx) cell.classList.add("lastMove","pulse");
    }
  }

  function renderScores(){
    scoresEl.innerHTML = "";
    const counts = countPieces();

    for(let pid=1; pid<=P; pid++){
      const pill = document.createElement("div");
      pill.className = "scorePill";
      const dot = document.createElement("span");
      dot.className = "miniDot";
      dot.style.background = COLORS[pid-1].color;

      const label = document.createElement("span");
      const status = players[pid-1].eliminated ? " (out)" : "";
      label.textContent = `${COLORS[pid-1].name}: ${counts[pid]}${status}`;

      pill.appendChild(dot);
      pill.appendChild(label);
      scoresEl.appendChild(pill);
    }
  }

  function renderTurn(extra=""){
    if(!active){
      turnTextEl.textContent = "Set up a game";
      turnDotEl.style.background = "rgba(232,236,255,.75)";
      return;
    }
    turnTextEl.textContent = `${COLORS[current-1].name}'s turn${extra ? " — " + extra : ""}`;
    turnDotEl.style.background = COLORS[current-1].color;
  }

  function countPieces(){
    const counts = new Array(P+1).fill(0);
    for(let i=0;i<board.length;i++){
      const v = board[i];
      if(v>0) counts[v]++;
    }
    return counts;
  }

  function updateEliminations(){
    const counts = countPieces();
    for(let pid=1; pid<=P; pid++) players[pid-1].eliminated = (counts[pid] === 0);
  }

  function activePlayerIds(){
    const ids = [];
    for(let pid=1; pid<=P; pid++) if(!players[pid-1].eliminated) ids.push(pid);
    return ids;
  }

  function onlyOnePlayerLeft(){
    return activePlayerIds().length <= 1;
  }

  function boardFull(){
    for(let i=0;i<board.length;i++) if(board[i]===0) return false;
    return true;
  }

  function getLegalMoves(pid, b=board){
    const moves = [];
    if(!b) return moves;
    for(let i=0;i<b.length;i++){
      if(b[i]!==pid) continue;
      const pos = { r: Math.floor(i/N), c: i%N };
      for(let dr=-2; dr<=2; dr++){
        for(let dc=-2; dc<=2; dc++){
          if(dr===0 && dc===0) continue;
          const rr = pos.r+dr, cc = pos.c+dc;
          if(rr<0||rr>=N||cc<0||cc>=N) continue;
          const j = rr*N + cc;
          if(b[j]!==0) continue;
          const dist = Math.max(Math.abs(dr), Math.abs(dc));
          if(dist===1) moves.push({from:i,to:j,kind:"clone"});
          else if(dist===2) moves.push({from:i,to:j,kind:"jump"});
        }
      }
    }
    return moves;
  }

  function getLegalDestsFrom(pid, fromIdx){
    const pos = { r: Math.floor(fromIdx/N), c: fromIdx%N };
    const set = new Set();
    for(let dr=-2; dr<=2; dr++){
      for(let dc=-2; dc<=2; dc++){
        if(dr===0 && dc===0) continue;
        const rr = pos.r+dr, cc = pos.c+dc;
        if(rr<0||rr>=N||cc<0||cc>=N) continue;
        const j = rr*N + cc;
        if(board[j]!==0) continue;
        const dist = Math.max(Math.abs(dr), Math.abs(dc));
        if(dist===1 || dist===2) set.add(j);
      }
    }
    return set;
  }

  function applyMove(move, b){
    const nb = new Int8Array(b);
    const pid = nb[move.from];
    if(pid<=0) return nb;

    if(move.kind==="clone") nb[move.to] = pid;
    else { nb[move.to] = pid; nb[move.from] = 0; }

    const tr = Math.floor(move.to/N), tc = move.to%N;
    for(let dr=-1; dr<=1; dr++){
      for(let dc=-1; dc<=1; dc++){
        if(dr===0 && dc===0) continue;
        const rr = tr+dr, cc = tc+dc;
        if(rr<0||rr>=N||cc<0||cc>=N) continue;
        const k = rr*N + cc;
        if(nb[k]!==0 && nb[k]!==pid) nb[k]=pid;
      }
    }
    return nb;
  }

  function swingScore(pid, before, after){
    let b0=0, b1=0;
    for(let i=0;i<before.length;i++){
      if(before[i]===pid) b0++;
      if(after[i]===pid) b1++;
    }
    return b1-b0;
  }

  function mobility(pid, b){ return getLegalMoves(pid, b).length; }

  function heuristic(pid, b){
    const counts = new Array(P+1).fill(0);
    for(let i=0;i<b.length;i++){ const v=b[i]; if(v>0) counts[v]++; }
    const my = counts[pid];
    let othersMax=0, othersSum=0;
    for(let k=1;k<=P;k++){
      if(k===pid) continue;
      othersMax = Math.max(othersMax, counts[k]);
      othersSum += counts[k];
    }
    const mob = mobility(pid, b);
    return (my*10) - (othersMax*7) - (othersSum*1) + mob*0.6;
  }

  function nextLivingPlayer(pid){
    let tries=0, p=pid;
    while(tries<P){
      p = (p % P) + 1;
      if(!players[p-1].eliminated) return p;
      tries++;
    }
    return pid;
  }

  function computeBestMove(pid, diff){
    const moves = getLegalMoves(pid, board);
    if(moves.length===0) return null;

    if(diff==="easy"){
      return moves[Math.floor(Math.random()*moves.length)];
    }

    if(diff==="medium"){
      let best=null, bestScore=-Infinity;
      for(const m of moves){
        const nb = applyMove(m, board);
        const s = swingScore(pid, board, nb) + (m.kind==="clone" ? 0.15 : 0.0);
        if(s>bestScore){ bestScore=s; best=m; }
      }
      const near = moves.filter(m=>{
        const nb = applyMove(m, board);
        const s = swingScore(pid, board, nb) + (m.kind==="clone" ? 0.15 : 0.0);
        return s >= bestScore - 0.5;
      });
      return near[Math.floor(Math.random()*near.length)];
    }

    const depth = (N===11 ? 2 : 3);

    function nextPlayerSim(curPid, b){
      const counts = new Array(P+1).fill(0);
      for(let i=0;i<b.length;i++){ const v=b[i]; if(v>0) counts[v]++; }
      let tries=0, p=curPid;
      while(tries<P){
        p = (p % P) + 1;
        if(counts[p] > 0) return p;
        tries++;
      }
      return curPid;
    }

    function evalNode(b, curPid, d){
      if(d===0) return heuristic(pid, b);
      const curMoves = getLegalMoves(curPid, b);
      if(curMoves.length===0) return evalNode(b, nextPlayerSim(curPid, b), d-1);

      if(curPid === pid){
        let val=-Infinity;
        for(const m of curMoves){
          const nb = applyMove(m, b);
          val = Math.max(val, evalNode(nb, nextPlayerSim(curPid, nb), d-1));
        }
        return val;
      }else{
        let val=Infinity;
        for(const m of curMoves){
          const nb = applyMove(m, b);
          val = Math.min(val, evalNode(nb, nextPlayerSim(curPid, nb), d-1));
        }
        return val;
      }
    }

    const shuffled = moves.slice().sort(()=>Math.random()-0.5);
    let best=null, bestVal=-Infinity;
    for(const m of shuffled){
      const nb = applyMove(m, board);
      const val = evalNode(nb, nextPlayerSim(pid, nb), depth-1) + (m.kind==="clone" ? 0.05 : 0.0);
      if(val>bestVal){ bestVal=val; best=m; }
    }
    return best;
  }

  function isHumanTurn(){ return players[current-1].type === "human"; }

  function onCellClick(i){
    if(!active || viewingBoard || cpuBusy) return;
    if(!isHumanTurn()) return;

    const v = board[i];

    if(selected === null){
      if(v === current){
        selected = rc(i);
        legalDests = getLegalDestsFrom(current, i);
        applyHighlights();
      }
      return;
    }

    const fromI = idx(selected.r, selected.c);

    if(v === current){
      selected = rc(i);
      legalDests = getLegalDestsFrom(current, i);
      applyHighlights();
      return;
    }

    if(v === 0){
      if(!legalDests || !legalDests.has(i)) return;
      const tr = Math.floor(i/N), tc=i%N;
      const dist = Math.max(Math.abs(tr - selected.r), Math.abs(tc - selected.c));
      const kind = (dist===1) ? "clone" : "jump";
      makeMove({ from: fromI, to: i, kind });
      return;
    }
  }

  function hasLegalMove(pid){
    if(players[pid-1].eliminated) return false;
    return getLegalMoves(pid, board).length > 0;
  }

  function checkGameOver(includePasses=true){
    if(boardFull()) return true;
    if(onlyOnePlayerLeft()) return true;
    if(includePasses){
      const living = activePlayerIds().length;
      if(living>0 && consecutivePasses >= living) return true;
    }
    return false;
  }

  function endGame(){
    active = false;
    selected = null;
    legalDests = null;
    cpuBusy = false;

    renderBoard();
    renderScores();

    const counts = countPieces();
    const list = [];
    for(let pid=1; pid<=P; pid++) list.push({pid, count: counts[pid]});
    list.sort((a,b)=>b.count-a.count);
    const best = list[0].count;
    const winners = list.filter(x=>x.count===best).map(x=>COLORS[x.pid-1].name);

    modalTitle.textContent = (winners.length===1) ? `${winners[0]} wins!` : `It's a tie!`;
    modalSubtitle.textContent = (winners.length===1)
      ? `Final score: ${best} tiles`
      : `Winners: ${winners.join(", ")} — ${best} tiles each`;

    modalScores.textContent = list.map(x=>`${COLORS[x.pid-1].name}: ${x.count}`).join(" • ");

    modalBackdrop.style.display = "flex";
    turnTextEl.textContent = "Game over";
    turnDotEl.style.background = "rgba(232,236,255,.75)";
  }

  function makeMove(move){
    const pid = current;
    board = applyMove(move, board);
    lastMoveIdx = move.to;

    selected = null;
    legalDests = null;
    consecutivePasses = 0;

    updateEliminations();
    renderBoard();
    renderScores();

    if(checkGameOver()){
      endGame();
      return;
    }

    current = nextLivingPlayer(pid);
    renderTurn();
    maybeHandleAutoPassOrCpu();
  }

  function maybeHandleAutoPassOrCpu(){
    if(!active || viewingBoard) return;

    if(players[current-1].eliminated){
      current = nextLivingPlayer(current);
    }

    if(!hasLegalMove(current)){
      consecutivePasses++;
      const passedPlayer = current;

      updateEliminations();
      renderScores();

      if(checkGameOver(true)){
        endGame();
        return;
      }

      current = nextLivingPlayer(current);
      renderTurn(`${COLORS[passedPlayer-1].name} passed`);
      setTimeout(() => maybeHandleAutoPassOrCpu(), 200);
      return;
    }

    if(!isHumanTurn()){
      cpuBusy = true;
      renderTurn("Computer thinking…");
      const diff = players[current-1].difficulty || "medium";
      setTimeout(() => {
        const move = computeBestMove(current, diff);
        cpuBusy = false;
        if(!active || viewingBoard) return;
        if(move) makeMove(move);
        else {
          consecutivePasses++;
          current = nextLivingPlayer(current);
          renderTurn("Passed");
          maybeHandleAutoPassOrCpu();
        }
      }, 400);
    }else{
      renderTurn();
    }
  }

  function startGame(){
    initSetup();
    active = true;
    viewingBoard = false;
    viewingBannerEl.style.display = "none";
    consecutivePasses = 0;

    updateEliminations();
    renderScores();
    renderTurn();
    renderBoard();
    clampCellSize();

    maybeHandleAutoPassOrCpu();
  }

  function backToSetup(){
    modalBackdrop.style.display = "none";
    active = false;
    viewingBoard = false;
    viewingBannerEl.style.display = "none";
    cpuBusy = false;
    selected = null;
    legalDests = null;
    lastMoveIdx = null;
    consecutivePasses = 0;
    initSetup();
  }

  viewBoardBtn.addEventListener("click", () => {
    modalBackdrop.style.display = "none";
    viewingBoard = true;
    viewingBannerEl.style.display = "block";
    renderTurn();
  });

  restartBtn.addEventListener("click", () => backToSetup());

  numPlayersEl.addEventListener("change", () => { renderPlayersConfig(); initSetup(); });
  boardSizeEl.addEventListener("change", () => initSetup());
  showHintsEl.addEventListener("change", () => applyHighlights());
  startBtn.addEventListener("click", () => startGame());
  newGameBtn.addEventListener("click", () => backToSetup());
  window.addEventListener("resize", () => clampCellSize());

  renderPlayersConfig();
  initSetup();
})();
</script>
</body>
</html>
