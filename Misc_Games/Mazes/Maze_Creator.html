<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Maze Generator</title>
  <style>
    :root { --bg:#0b0f19; --panel:rgba(255,255,255,.08); --border:rgba(255,255,255,.14); --text:rgba(255,255,255,.92); --muted:rgba(255,255,255,.7); }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--text);padding:16px}
    .app{max-width:1100px;margin:0 auto;display:grid;grid-template-columns:1fr 340px;gap:12px}
    @media (max-width:980px){.app{grid-template-columns:1fr}}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:16px;overflow:hidden}
    .mazeWrap{padding:14px;display:grid;grid-template-rows:auto 1fr auto;gap:10px}
    h1{font-size:18px;margin:0}
    p{margin:6px 0 0 0;color:var(--muted);font-size:13px;line-height:1.35}
    .canvasShell{background:rgba(0,0,0,.25);border:1px solid var(--border);border-radius:14px;padding:10px;min-height:420px;display:grid;place-items:center}
    canvas{width:100%;height:auto;background:#fff;border-radius:10px;display:block;outline:1px solid rgba(0,0,0,.25)}
    .footer{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:space-between;color:var(--muted);font-size:12px}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:7px 10px;border-radius:999px;border:1px solid var(--border);background:rgba(0,0,0,.22)}
    .controls{padding:14px;display:flex;flex-direction:column;gap:12px}
    .group{background:rgba(255,255,255,.10);border:1px solid var(--border);border-radius:14px;padding:12px;display:grid;gap:10px}
    label{font-size:12px;color:var(--muted)}
    select,button{width:100%;padding:11px 12px;border-radius:12px;border:1px solid var(--border);background:rgba(0,0,0,.25);color:var(--text);font-size:14px;outline:none}
    button{cursor:pointer;background:rgba(255,255,255,.10)}
    button:hover{background:rgba(255,255,255,.14)}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .toggle{display:flex;align-items:center;gap:10px;color:var(--text);font-size:13px;user-select:none}
    #err{display:none;white-space:pre-wrap;color:#ffd3d3;background:rgba(255,0,0,.12);border:1px solid rgba(255,0,0,.35);border-radius:12px;padding:10px;font-size:12px}
  </style>
</head>
<body>
  <div class="app">
    <section class="card mazeWrap">
      <header>
        <h1>Random Maze Generator</h1>
        <p>Pick a difficulty (5 levels), generate a new maze, show solution, export to PDF.</p>
      </header>

      <div class="canvasShell">
        <canvas id="maze" aria-label="Maze canvas"></canvas>
      </div>

      <div class="footer">
        <span class="pill" id="mazeInfo">—</span>
        <span class="pill" id="seedInfo">Seed: —</span>
      </div>
    </section>

    <aside class="card controls">
      <div id="err"></div>

      <div class="group">
        <label>Difficulty</label>
        <select id="difficulty">
          <option value="0">1 — Very Easy</option>
          <option value="1">2 — Easy</option>
          <option value="2" selected>3 — Medium</option>
          <option value="3">4 — Hard</option>
          <option value="4">5 — Extreme</option>
        </select>

        <div class="row">
          <div>
            <label>Start</label>
            <select id="startPos">
              <option value="tl">Top-left</option>
              <option value="tr">Top-right</option>
              <option value="bl">Bottom-left</option>
              <option value="br" selected>Bottom-right</option>
            </select>
          </div>
          <div>
            <label>End</label>
            <select id="endPos">
              <option value="br">Bottom-right</option>
              <option value="bl">Bottom-left</option>
              <option value="tr" selected>Top-right</option>
              <option value="tl">Top-left</option>
            </select>
          </div>
        </div>

        <label class="toggle"><input id="showSolution" type="checkbox" /> Show solution</label>
        <label class="toggle"><input id="braidLoops" type="checkbox" checked /> Add a few loops</label>
      </div>

      <div class="group">
        <button id="newMaze">New maze</button>
        <button id="exportPdf">Export to PDF</button>
        <p style="margin:0;color:var(--muted);font-size:12px;line-height:1.35">
          If “Show solution” is on, PDF export adds a second page (solution overlay).
        </p>
      </div>
    </aside>
  </div>

<script>
(() => {
  const errBox = document.getElementById("err");
  function showErr(e){
    errBox.style.display = "block";
    errBox.textContent = "Error:\n" + (e && e.stack ? e.stack : String(e));
  }
  window.addEventListener("error", (e) => showErr(e.error || e.message));

  // ---- RNG (no optional chaining) ----
  function makeSeed() {
    try {
      if (window.crypto && crypto.getRandomValues) {
        const a = new Uint32Array(1);
        crypto.getRandomValues(a);
        return (a[0] ^ (Date.now() >>> 0)) >>> 0;
      }
    } catch {}
    return ((Math.random() * 0xFFFFFFFF) ^ (Date.now() >>> 0)) >>> 0;
  }
  function mulberry32(seed) {
    let t = seed >>> 0;
    return function() {
      t += 0x6D2B79F5;
      let x = Math.imul(t ^ (t >>> 15), 1 | t);
      x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
      return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
    };
  }

  const DIRS = [
    { name:"N", dx:0, dy:-1, opp:"S" },
    { name:"E", dx:1, dy:0,  opp:"W" },
    { name:"S", dx:0, dy:1,  opp:"N" },
    { name:"W", dx:-1,dy:0,  opp:"E" },
  ];
  const DIFFICULTIES = [
    { label:"Very Easy", size:15, braidChance:0.05, wall:6, margin:40 },
    { label:"Easy",      size:21, braidChance:0.06, wall:5, margin:36 },
    { label:"Medium",    size:31, braidChance:0.07, wall:4, margin:32 },
    { label:"Hard",      size:41, braidChance:0.08, wall:3, margin:28 },
    { label:"Extreme",   size:61, braidChance:0.09, wall:2, margin:24 },
  ];

  function inBounds(x,y,w,h){ return x>=0 && y>=0 && x<w && y<h; }
  function shuffle(a, rand){
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(rand()*(i+1));
      [a[i],a[j]] = [a[j],a[i]];
    }
    return a;
  }
  function createGrid(w,h){
    const g=[];
    for(let y=0;y<h;y++){
      const row=[];
      for(let x=0;x<w;x++){
        row.push({x,y, visited:false, walls:{N:true,E:true,S:true,W:true}});
      }
      g.push(row);
    }
    return g;
  }
  function generateMaze(w,h,rand){
    const g=createGrid(w,h);
    const stack=[g[0][0]];
    g[0][0].visited=true;
    while(stack.length){
      const cur=stack[stack.length-1];
      const dirs=shuffle(DIRS.slice(), rand);
      let carved=false;
      for(const d of dirs){
        const nx=cur.x+d.dx, ny=cur.y+d.dy;
        if(!inBounds(nx,ny,w,h)) continue;
        const nxt=g[ny][nx];
        if(nxt.visited) continue;
        cur.walls[d.name]=false;
        nxt.walls[d.opp]=false;
        nxt.visited=true;
        stack.push(nxt);
        carved=true;
        break;
      }
      if(!carved) stack.pop();
    }
    // clear visited
    for(let y=0;y<h;y++)for(let x=0;x<w;x++)g[y][x].visited=false;
    return g;
  }
  function isDeadEnd(cell){
    let open=0;
    for(const d of DIRS) if(!cell.walls[d.name]) open++;
    return open===1;
  }
  function braidMaze(grid, rand, chance){
    const h=grid.length, w=grid[0].length;
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const c=grid[y][x];
        if(!isDeadEnd(c) || rand()>chance) continue;
        const cand=[], prefer=[];
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(!inBounds(nx,ny,w,h)) continue;
          if(c.walls[d.name]===false) continue;
          const n=grid[ny][nx];
          cand.push({d,n});
          if(!isDeadEnd(n)) prefer.push({d,n});
        }
        const pickFrom = prefer.length ? prefer : cand;
        if(!pickFrom.length) continue;
        const ch = pickFrom[Math.floor(rand()*pickFrom.length)];
        c.walls[ch.d.name]=false;
        ch.n.walls[ch.d.opp]=false;
      }
    }
  }
  function posToCoord(pos,w,h){
    if(pos==="tl") return {x:0,y:0};
    if(pos==="tr") return {x:w-1,y:0};
    if(pos==="bl") return {x:0,y:h-1};
    return {x:w-1,y:h-1};
  }
  function solveMaze(grid, start, end){
    const h=grid.length, w=grid[0].length;
    const q=[start];
    const prev=Array.from({length:h},()=>Array(w).fill(null));
    const seen=Array.from({length:h},()=>Array(w).fill(false));
    seen[start.y][start.x]=true;

    while(q.length){
      const cur=q.shift();
      if(cur.x===end.x && cur.y===end.y) break;
      const cell=grid[cur.y][cur.x];
      for(const d of DIRS){
        if(cell.walls[d.name]) continue;
        const nx=cur.x+d.dx, ny=cur.y+d.dy;
        if(!inBounds(nx,ny,w,h) || seen[ny][nx]) continue;
        seen[ny][nx]=true;
        prev[ny][nx]=cur;
        q.push({x:nx,y:ny});
      }
    }
    if(!seen[end.y][end.x]) return [];
    const path=[];
    let cur=end;
    while(cur){
      path.push(cur);
      if(cur.x===start.x && cur.y===start.y) break;
      cur = prev[cur.y][cur.x];
    }
    path.reverse();
    return path;
  }

  // ---- Canvas sizing/drawing ----
  const canvas=document.getElementById("maze");
  const ctx=canvas.getContext("2d");

  function fitCanvas(){
    const shell = canvas.parentElement;
    const rect = shell.getBoundingClientRect();
    const size = Math.max(320, Math.floor(rect.width - 20));
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(size * dpr);
    canvas.height = Math.floor(size * dpr);
    canvas.style.width = size + "px";
    canvas.style.height = size + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return size;
  }

  function draw(state, opts){
    const {grid,w,h,start,end,path} = state;
    const size = fitCanvas();
    const margin = opts.margin;
    const wallPx = opts.wallPx;

    ctx.clearRect(0,0,size,size);
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,size,size);

    const usable = size - margin*2;
    const cell = usable / Math.max(w,h);
    const ox = (size - cell*w)/2;
    const oy = (size - cell*h)/2;

    ctx.strokeStyle="#000";
    ctx.lineWidth=wallPx;
    ctx.beginPath();
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const c=grid[y][x];
        const x1=ox+x*cell, y1=oy+y*cell;
        const x2=x1+cell, y2=y1+cell;
        if(c.walls.N){ctx.moveTo(x1,y1);ctx.lineTo(x2,y1);}
        if(c.walls.E){ctx.moveTo(x2,y1);ctx.lineTo(x2,y2);}
        if(c.walls.S){ctx.moveTo(x1,y2);ctx.lineTo(x2,y2);}
        if(c.walls.W){ctx.moveTo(x1,y1);ctx.lineTo(x1,y2);}
      }
    }
    ctx.stroke();

    function center(p){ return {cx: ox+(p.x+0.5)*cell, cy: oy+(p.y+0.5)*cell}; }
    const s=center(start), e=center(end);
    const r=Math.max(6, cell*0.18);

    ctx.fillStyle="rgba(20,160,80,.85)";
    ctx.beginPath(); ctx.arc(s.cx,s.cy,r,0,Math.PI*2); ctx.fill();

    ctx.fillStyle="rgba(200,40,40,.85)";
    ctx.beginPath(); ctx.arc(e.cx,e.cy,r,0,Math.PI*2); ctx.fill();

    if(opts.showSolution && path.length){
      ctx.strokeStyle="rgba(30,120,220,.85)";
      ctx.lineWidth=Math.max(4, cell*0.22);
      ctx.lineJoin="round"; ctx.lineCap="round";
      ctx.beginPath();
      for(let i=0;i<path.length;i++){
        const p=center(path[i]);
        if(i===0) ctx.moveTo(p.cx,p.cy);
        else ctx.lineTo(p.cx,p.cy);
      }
      ctx.stroke();
    }
  }

  const difficultyEl=document.getElementById("difficulty");
  const startPosEl=document.getElementById("startPos");
  const endPosEl=document.getElementById("endPos");
  const showSolutionEl=document.getElementById("showSolution");
  const braidLoopsEl=document.getElementById("braidLoops");
  const newMazeBtn=document.getElementById("newMaze");
  const exportPdfBtn=document.getElementById("exportPdf");
  const mazeInfoEl=document.getElementById("mazeInfo");
  const seedInfoEl=document.getElementById("seedInfo");

  let state=null;

  function regenerate(){
    try{
      errBox.style.display="none";
      const diff = DIFFICULTIES[Number(difficultyEl.value)] || DIFFICULTIES[2];
      const seed = makeSeed();
      const rand = mulberry32(seed);

      const w=diff.size, h=diff.size;
      let grid = generateMaze(w,h,rand);
      if(braidLoopsEl.checked) braidMaze(grid,rand,diff.braidChance);

      const start = posToCoord(startPosEl.value,w,h);
      const end = posToCoord(endPosEl.value,w,h);
      const path = solveMaze(grid,start,end);

      state = {seed, diff, grid, w, h, start, end, path};

      mazeInfoEl.textContent = `${diff.label} • ${w}×${h} cells`;
      seedInfoEl.textContent = `Seed: ${seed}`;

      draw(state, {margin: diff.margin, wallPx: diff.wall, showSolution: showSolutionEl.checked});
    } catch(e){
      showErr(e);
    }
  }

  showSolutionEl.addEventListener("change", () => {
    if(!state) return;
    draw(state, {margin: state.diff.margin, wallPx: state.diff.wall, showSolution: showSolutionEl.checked});
  });
  [difficultyEl,startPosEl,endPosEl,braidLoopsEl].forEach(el => el.addEventListener("change", regenerate));
  newMazeBtn.addEventListener("click", regenerate);

  // Load jsPDF only when exporting
  function loadJsPDF(){
    return new Promise((resolve,reject)=>{
      if(window.jspdf && window.jspdf.jsPDF) return resolve(window.jspdf.jsPDF);
      const s=document.createElement("script");
      s.src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js";
      s.onload=()=> (window.jspdf && window.jspdf.jsPDF) ? resolve(window.jspdf.jsPDF) : reject(new Error("jsPDF loaded but not found"));
      s.onerror=()=> reject(new Error("Failed to load jsPDF (network blocked?)"));
      document.head.appendChild(s);
    });
  }

  exportPdfBtn.addEventListener("click", async () => {
    try{
      if(!state) return;
      const jsPDF = await loadJsPDF();
      const pdf = new jsPDF({orientation:"portrait", unit:"pt", format:"letter"});
      const pageW = pdf.internal.pageSize.getWidth();
      const pageH = pdf.internal.pageSize.getHeight();

      // Render maze-only
      draw(state, {margin: state.diff.margin, wallPx: state.diff.wall, showSolution:false});
      const imgMaze = canvas.toDataURL("image/png", 1.0);

      // Render solution if needed
      let imgSol = null;
      if(showSolutionEl.checked){
        draw(state, {margin: state.diff.margin, wallPx: state.diff.wall, showSolution:true});
        imgSol = canvas.toDataURL("image/png", 1.0);
      }

      // Restore view
      draw(state, {margin: state.diff.margin, wallPx: state.diff.wall, showSolution: showSolutionEl.checked});

      const margin=36, top=52;
      const usableW = pageW - margin*2;
      const usableH = pageH - top - margin;
      const side = Math.min(usableW, usableH);
      const x = (pageW - side)/2;
      const y = top + (usableH - side)/2;

      pdf.setFont("helvetica","bold"); pdf.setFontSize(14);
      pdf.text("Maze", pageW/2, 28, {align:"center"});
      pdf.setFont("helvetica","normal"); pdf.setFontSize(10);
      pdf.text(`${state.diff.label} • ${state.w}×${state.h} • Seed ${state.seed}`, pageW/2, 44, {align:"center"});
      pdf.addImage(imgMaze, "PNG", x, y, side, side);

      if(imgSol){
        pdf.addPage();
        pdf.setFont("helvetica","bold"); pdf.setFontSize(14);
        pdf.text("Maze (Solution)", pageW/2, 28, {align:"center"});
        pdf.setFont("helvetica","normal"); pdf.setFontSize(10);
        pdf.text(`${state.diff.label} • ${state.w}×${state.h} • Seed ${state.seed}`, pageW/2, 44, {align:"center"});
        pdf.addImage(imgSol, "PNG", x, y, side, side);
      }

      pdf.save(`maze-${state.w}x${state.h}-seed-${state.seed}.pdf`);
    } catch(e){
      showErr(e);
    }
  });

  window.addEventListener("resize", () => {
    if(!state) return;
    draw(state, {margin: state.diff.margin, wallPx: state.diff.wall, showSolution: showSolutionEl.checked});
  });

  regenerate();
})();
</script>
</body>
</html>
