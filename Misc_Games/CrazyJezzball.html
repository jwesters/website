<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Crazy JezzBall Clone — Spinning Cursor Direction</title>
<style>
  :root { color-scheme: dark; }
  body{
    margin:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background:#0b0f14; color:#e8eef6;
    display:grid; place-items:center; height:100vh;
  }
  .wrap{ width:min(980px, 96vw); }
  .topbar{
    display:flex; gap:12px; align-items:center; justify-content:space-between;
    margin:8px 2px; flex-wrap:wrap;
  }
  .stats{ display:flex; gap:12px; flex-wrap:wrap; align-items:center; font-size:14px; opacity:.95; }
  .pill{
    background: rgba(255,255,255,0.08);
    border:1px solid rgba(255,255,255,0.12);
    border-radius:999px; padding:6px 10px;
    white-space:nowrap;
  }
  button{
    background: rgba(255,255,255,0.10);
    color:#e8eef6;
    border:1px solid rgba(255,255,255,0.16);
    border-radius:10px;
    padding:8px 12px;
    cursor:pointer;
  }
  button:hover{ background: rgba(255,255,255,0.14); }
  button.danger{
    border-color: rgba(255,120,140,0.35);
    background: rgba(255,120,140,0.12);
  }
  button.danger:hover{ background: rgba(255,120,140,0.18); }

  canvas{
    width:100%;
    height:auto;
    aspect-ratio: 16/10;
    background:#0a0f16;
    border:1px solid rgba(255,255,255,0.15);
    border-radius:16px;
    box-shadow:0 10px 30px rgba(0,0,0,0.35);
    display:block;
    cursor: none; /* we draw our own cursor */
  }
  .hint{
    margin:8px 2px 0;
    font-size:13px; opacity:.78; line-height:1.35;
  }
  .overlay{
    position:fixed; inset:0;
    display:none; place-items:center;
    background: rgba(0,0,0,0.55);
    backdrop-filter: blur(3px);
  }
  .card{
    width:min(620px, 92vw);
    background: rgba(18,24,34,0.92);
    border:1px solid rgba(255,255,255,0.14);
    border-radius:16px;
    padding:18px 18px 14px;
    box-shadow: 0 18px 50px rgba(0,0,0,0.55);
  }
  .card h2{ margin:0 0 8px; }
  .card p{ margin:0 0 12px; opacity:.9; }
  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

  .divider{
    height:1px;
    background: rgba(255,255,255,0.10);
    margin:12px 0;
    display:none;
  }
  .scoresBlock{
    display:none;
  }
  .scoresTitle{
    font-weight:700;
    margin:0 0 8px;
    opacity:.95;
  }
  .scoresBox{
    border:1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.05);
    border-radius:12px;
    padding:10px 10px;
    font-size:13px;
    line-height:1.3;
    font-variant-numeric: tabular-nums;
  }
  .scoresBox .rowLine{
    display:flex;
    justify-content:space-between;
    gap:10px;
  }
  .scoresBox .muted{ opacity:.72; }
</style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div class="stats">
      <div class="pill"><b>Level</b>: <span id="level">1</span></div>
      <div class="pill"><b>Lives</b>: <span id="lives">3</span></div>
      <div class="pill"><b>Captured</b>: <span id="captured">0.0%</span></div>
      <div class="pill"><b>Target</b>: <span id="target">75%</span></div>
      <div class="pill"><b>Balls</b>: <span id="balls">2</span></div>
      <div class="pill"><b>Aim</b>: Cursor spins — click to shoot wall direction</div>
    </div>
    <div class="row">
      <button id="restart">Restart</button>
      <button id="pause">Pause</button>
    </div>
  </div>

  <canvas id="c" width="960" height="600"></canvas>

  <div class="hint">
    <b>How it works:</b> Move your mouse anywhere in the playfield. A custom cursor arrow spins continuously.
    When you <b>click</b>, a wall starts at the click point and grows both ways along the arrow’s direction until it hits walls/border.
    If a ball touches the <b>growing wall</b>, you lose a life.
    Capture ≥ target to advance. <b>P</b> to pause.
  </div>
</div>

<div class="overlay" id="overlay">
  <div class="card">
    <h2 id="overlayTitle">Paused</h2>
    <p id="overlayText">Press Continue to continue.</p>

    <div class="divider" id="scoresDivider"></div>
    <div class="scoresBlock" id="scoresBlock">
      <div class="scoresTitle">Top 5 (Local)</div>
      <div class="scoresBox" id="scoresOverlay"></div>
    </div>

    <div class="divider" id="buttonsDivider"></div>

    <div class="row">
      <button id="continueBtn">Continue</button>
      <button id="overlayRestart">Restart</button>
      <button class="danger" id="overlayClearScores">Reset Scores</button>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const ui = {
    level: document.getElementById('level'),
    lives: document.getElementById('lives'),
    captured: document.getElementById('captured'),
    target: document.getElementById('target'),
    balls: document.getElementById('balls'),
    restart: document.getElementById('restart'),
    pause: document.getElementById('pause'),

    overlay: document.getElementById('overlay'),
    overlayTitle: document.getElementById('overlayTitle'),
    overlayText: document.getElementById('overlayText'),
    continueBtn: document.getElementById('continueBtn'),
    overlayRestart: document.getElementById('overlayRestart'),
    overlayClearScores: document.getElementById('overlayClearScores'),

    scoresBlock: document.getElementById('scoresBlock'),
    scoresOverlay: document.getElementById('scoresOverlay'),
    scoresDivider: document.getElementById('scoresDivider'),
    buttonsDivider: document.getElementById('buttonsDivider')
  };

  const W = canvas.width, H = canvas.height;

  // Wall grid (cells)
  const GRID = 8;
  const COLS = Math.floor(W / GRID);
  const ROWS = Math.floor(H / GRID);

  const COLORS = {
    bg: '#0a0f16',
    grid: 'rgba(255,255,255,0.03)',
    wall: 'rgba(232,238,246,0.80)',
    grow: '#f2c14e',
    ballA: '#5bc0eb',
    ballB: '#f45b69',
    danger: '#ff5c77',
    cursor: 'rgba(232,238,246,0.92)',
    cursorSoft: 'rgba(232,238,246,0.35)'
  };

  // ---------------------------
  // High Scores (localStorage)
  // ---------------------------
  const SCORE_KEY = 'crazyJezzball_top5_v1';

  function loadScores(){
    try {
      const raw = localStorage.getItem(SCORE_KEY);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr : [];
    } catch(e){
      return [];
    }
  }

  function saveScores(scores){
    try { localStorage.setItem(SCORE_KEY, JSON.stringify(scores)); }
    catch(e){ /* ignore */ }
  }

  // Sort: level desc, capturedPct desc, then timestamp desc (display stability)
  function sortScores(scores){
    scores.sort((a,b) => {
      if (b.level !== a.level) return b.level - a.level;
      if (b.capturedPct !== a.capturedPct) return b.capturedPct - a.capturedPct;
      return (b.ts || 0) - (a.ts || 0);
    });
    return scores;
  }

  function addScore(entry){
    const scores = loadScores();
    scores.push(entry); // duplicates/ties allowed
    sortScores(scores);
    const top5 = scores.slice(0,5);
    saveScores(top5);
  }

  function clearAllScores(){
    try { localStorage.removeItem(SCORE_KEY); } catch(e){}
  }

  function fmtPctInt(p){ return Math.max(0, Math.min(100, Math.round(p))) + '%'; }
  function fmtPct1(ratio){
    const pct = Math.max(0, Math.min(100, ratio * 100));
    return pct.toFixed(1) + '%';
  }

  function renderScoresOverlay(scores){
    if (!scores || scores.length === 0){
      ui.scoresOverlay.innerHTML = `<div class="muted">No scores yet.</div>`;
      return;
    }
    ui.scoresOverlay.innerHTML = scores.map((s, i) => {
      const when = s.when || '';
      return `
        <div class="rowLine">
          <span>${i+1}. <b>Level</b> ${s.level} — <b>Captured</b> ${fmtPctInt(s.capturedPct)}</span>
          <span class="muted">${when}</span>
        </div>
      `;
    }).join('');
  }

  function nowStamp(){
    const d = new Date();
    const pad = n => String(n).padStart(2,'0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  }

  // ---------------------------
  // Game state
  // ---------------------------
  let paused = false;
  let level = 1;
  let lives = 3;
  const MAX_LIVES = 9;

  let targetCapture = 0.75;
  let ballCount = 2;

  // 0 empty, 1 wall
  let grid = new Uint8Array(COLS * ROWS);
  let balls = [];

  // Builder: arbitrary-angle line growing both directions
  let builder = null;

  // Speeds & stability
  const GROW_SPEED_PX = 560;     // px/sec along the aim direction
  const BALL_SUBSTEPS = 2;       // reduces tunneling
  let dangerTimer = 0;

  // Spinning cursor state
  let mouseInside = false;
  const mouse = { x: W/2, y: H/2 };
  let aimAngle = 0;              // radians
  const AIM_SPIN_SPEED = 2.4;    // rad/sec

  // prevent double-saving on game over
  let gameEnded = false;

  function idx(cx, cy){ return cy * COLS + cx; }
  function inBounds(cx, cy){ return cx>=0 && cy>=0 && cx<COLS && cy<ROWS; }
  function isWallCell(cx, cy){
    if (!inBounds(cx,cy)) return true;
    return grid[idx(cx,cy)] === 1;
  }
  function pointToCell(x,y){ return { cx: Math.floor(x/GRID), cy: Math.floor(y/GRID) }; }

  function clearGrid(){
    grid.fill(0);
    for (let x=0;x<COLS;x++){ grid[idx(x,0)] = 1; grid[idx(x,ROWS-1)] = 1; }
    for (let y=0;y<ROWS;y++){ grid[idx(0,y)] = 1; grid[idx(COLS-1,y)] = 1; }
  }

  function rand(min,max){ return Math.random()*(max-min)+min; }

  function computeCaptureRatio(){
    let playable=0, filled=0;
    for (let y=1;y<ROWS-1;y++){
      for (let x=1;x<COLS-1;x++){
        playable++;
        if (grid[idx(x,y)]===1) filled++;
      }
    }
    return playable ? (filled/playable) : 0;
  }

  function updateUI(){
    ui.level.textContent = level;
    ui.lives.textContent = lives;
    ui.target.textContent = Math.round(targetCapture*100) + '%';
    ui.balls.textContent = ballCount;
    ui.captured.textContent = fmtPct1(computeCaptureRatio()); // Option A: show one decimal to avoid rounding confusion
  }

  function setScoresVisibility(show){
    ui.scoresBlock.style.display = show ? 'block' : 'none';
    ui.scoresDivider.style.display = show ? 'block' : 'none';
    ui.buttonsDivider.style.display = show ? 'block' : 'none';
    ui.overlayClearScores.style.display = show ? '' : 'none';
  }

  function showOverlay(title, text){
    ui.overlayTitle.textContent = title;
    ui.overlayText.innerHTML = text;
    ui.overlay.style.display = 'grid';

    const isGameOver = (title === 'Game Over');

    // Only show scores on Game Over (NOT between rounds)
    setScoresVisibility(isGameOver);

    // Between rounds: ONLY "Continue"
    ui.continueBtn.style.display = isGameOver ? 'none' : '';
    ui.overlayRestart.style.display = isGameOver ? '' : 'none';
    ui.overlayClearScores.style.display = isGameOver ? '' : 'none';

    if (isGameOver){
      renderScoresOverlay(loadScores());
    }
  }

  function hideOverlay(){ ui.overlay.style.display = 'none'; }

  function resetGame(full=true){
    if (full){ level=1; lives=3; }
    targetCapture = 0.75;
    ballCount = 2 + Math.floor((level-1)/2);
    clearGrid();
    spawnBalls(ballCount);
    builder = null;
    paused = false;
    gameEnded = false;
    hideOverlay();
    updateUI();
  }

  function nextLevel(){
    level++;
    ballCount = 2 + Math.floor((level-1)/2);
    clearGrid();
    spawnBalls(ballCount);
    builder = null;
    paused = false;
    gameEnded = false;
    hideOverlay();
    updateUI();
  }

  function gameOver(){
    if (gameEnded) return;
    gameEnded = true;

    const capturedPct = Math.round(computeCaptureRatio()*100);

    addScore({
      level,
      capturedPct,
      when: nowStamp(),
      ts: Date.now()
    });

    paused = true;
    showOverlay('Game Over', `You reached level ${level}. Captured ${capturedPct}%.`);
  }

  // --- Ball vs solid grid collision ---
  function circleHitsSolid(x,y,r){
    const {cx, cy} = pointToCell(x,y);
    const rad = Math.ceil((r+1)/GRID);
    for (let yy=cy-rad; yy<=cy+rad; yy++){
      for (let xx=cx-rad; xx<=cx+rad; xx++){
        if (!inBounds(xx,yy)) continue;
        if (grid[idx(xx,yy)] !== 1) continue;

        const rx = xx*GRID, ry = yy*GRID;
        const closestX = Math.max(rx, Math.min(x, rx+GRID));
        const closestY = Math.max(ry, Math.min(y, ry+GRID));
        const dx = x - closestX, dy = y - closestY;
        if (dx*dx + dy*dy < r*r) return true;
      }
    }
    return false;
  }

  function resolveBallVsWalls(ball){
    for (let iter=0; iter<6; iter++){
      const {cx, cy} = pointToCell(ball.x, ball.y);
      const rad = Math.ceil((ball.r+1)/GRID);
      let best = null;

      for (let yy=cy-rad; yy<=cy+rad; yy++){
        for (let xx=cx-rad; xx<=cx+rad; xx++){
          if (!inBounds(xx,yy)) continue;
          if (grid[idx(xx,yy)] !== 1) continue;

          const rx = xx*GRID, ry = yy*GRID;
          const closestX = Math.max(rx, Math.min(ball.x, rx+GRID));
          const closestY = Math.max(ry, Math.min(ball.y, ry+GRID));
          let dx = ball.x - closestX;
          let dy = ball.y - closestY;
          const d2 = dx*dx + dy*dy;

          if (d2 < ball.r*ball.r){
            let d = Math.sqrt(d2);
            if (d < 1e-6){
              if (Math.abs(ball.vx) > Math.abs(ball.vy)){
                dx = (ball.vx >= 0) ? 1 : -1; dy = 0;
              } else {
                dx = 0; dy = (ball.vy >= 0) ? 1 : -1;
              }
              d = 1;
            }
            const nx = dx/d, ny = dy/d;
            const pen = ball.r - d;
            if (!best || pen > best.pen) best = {nx,ny,pen};
          }
        }
      }

      if (!best) break;

      ball.x += best.nx * (best.pen + 0.35);
      ball.y += best.ny * (best.pen + 0.35);

      const vn = ball.vx*best.nx + ball.vy*best.ny;
      if (vn < 0){
        ball.vx -= 2*vn*best.nx;
        ball.vy -= 2*vn*best.ny;
      }
    }

    if (ball.x < ball.r){ ball.x = ball.r; ball.vx = Math.abs(ball.vx); }
    if (ball.x > W-ball.r){ ball.x = W-ball.r; ball.vx = -Math.abs(ball.vx); }
    if (ball.y < ball.r){ ball.y = ball.r; ball.vy = Math.abs(ball.vy); }
    if (ball.y > H-ball.r){ ball.y = H-ball.r; ball.vy = -Math.abs(ball.vy); }
  }

  function spawnBalls(n){
    balls = [];
    for (let i=0;i<n;i++){
      let tries=0;
      while (tries++<4000){
        const r = 10;
        const x = rand(90, W-90);
        const y = rand(90, H-90);
        if (!circleHitsSolid(x,y,r)){
          const speed = rand(180, 280) + level*12;
          const ang = rand(0, Math.PI*2);
          balls.push({
            x,y,r,
            vx: Math.cos(ang)*speed,
            vy: Math.sin(ang)*speed,
            color: (i%2===0)?COLORS.ballA:COLORS.ballB
          });
          break;
        }
      }
    }
  }

  // --- Geometry helpers ---
  function segmentIntersectsBall(seg, ball){
    const {x1,y1,x2,y2,t} = seg;
    const px = ball.x, py = ball.y;
    const vx = x2-x1, vy = y2-y1;
    const wx = px-x1, wy = py-y1;
    const c2 = vx*vx + vy*vy;
    let s = 0;
    if (c2 > 0) s = Math.max(0, Math.min(1, (wx*vx + wy*vy)/c2));
    const cx = x1 + s*vx, cy = y1 + s*vy;
    const dx = px-cx, dy = py-cy;
    const rr = ball.r + t*0.60;
    return (dx*dx + dy*dy) <= rr*rr;
  }

  function traceMaxDistance(x, y, ux, uy){
    const step = GRID * 0.5;
    let dist = 0;
    for (let i=0; i<20000; i++){
      const nx = x + ux*(dist + step);
      const ny = y + uy*(dist + step);

      if (nx < 0 || nx >= W || ny < 0 || ny >= H) break;

      const c = pointToCell(nx, ny);
      if (!inBounds(c.cx,c.cy) || grid[idx(c.cx,c.cy)] === 1) break;

      dist += step;
    }
    return dist;
  }

  function rasterizeLineToGrid(x1,y1,x2,y2){
    const dist = Math.hypot(x2-x1, y2-y1);
    const steps = Math.max(1, Math.ceil(dist / (GRID*0.45)));
    for (let i=0;i<=steps;i++){
      const t = i/steps;
      const x = x1 + (x2-x1)*t;
      const y = y1 + (y2-y1)*t;
      const c = pointToCell(x,y);
      if (inBounds(c.cx,c.cy)) grid[idx(c.cx,c.cy)] = 1;
    }
  }

  function floodFillCapture(){
    const seen = new Uint8Array(COLS*ROWS);
    const qx = new Int32Array(COLS*ROWS);
    const qy = new Int32Array(COLS*ROWS);
    let h=0, t=0;

    function push(cx,cy){
      const k = idx(cx,cy);
      if (seen[k]) return;
      if (grid[k]===1) return;
      seen[k]=1;
      qx[t]=cx; qy[t]=cy; t++;
    }

    for (const b of balls){
      const c = pointToCell(b.x,b.y);
      if (inBounds(c.cx,c.cy)) push(c.cx,c.cy);
    }

    while (h<t){
      const cx=qx[h], cy=qy[h]; h++;
      if (cx>0) push(cx-1,cy);
      if (cx<COLS-1) push(cx+1,cy);
      if (cy>0) push(cx,cy-1);
      if (cy<ROWS-1) push(cx,cy+1);
    }

    for (let i=0;i<grid.length;i++){
      if (grid[i]===0 && !seen[i]) grid[i]=1;
    }
  }

  // --- Builder: arbitrary-angle ---
  function startBuilderAt(x,y, angle){
    if (builder) return;
    if (circleHitsSolid(x,y,2)) return;

    const c = pointToCell(x,y);
    if (!inBounds(c.cx,c.cy) || isWallCell(c.cx,c.cy)) return;

    const ux = Math.cos(angle);
    const uy = Math.sin(angle);

    const aMax = traceMaxDistance(x, y, -ux, -uy);
    const bMax = traceMaxDistance(x, y,  ux,  uy);

    builder = {
      x, y,
      ux, uy,
      aDist: 0,
      bDist: 0,
      aMax,
      bMax
    };
  }

  function builderSegments(b){
    const t = GRID;
    return [
      {x1:b.x, y1:b.y, x2:b.x - b.ux*b.aDist, y2:b.y - b.uy*b.aDist, t},
      {x1:b.x, y1:b.y, x2:b.x + b.ux*b.bDist, y2:b.y + b.uy*b.bDist, t},
    ];
  }

  function solidifyBuilder(b){
    const segs = builderSegments(b);
    for (const s of segs){
      rasterizeLineToGrid(s.x1,s.y1,s.x2,s.y2);
    }
    const cc = pointToCell(b.x,b.y);
    if (inBounds(cc.cx,cc.cy)) grid[idx(cc.cx,cc.cy)] = 1;
  }

  function updateBuilder(dt){
    if (!builder) return;

    builder.aDist = Math.min(builder.aMax, builder.aDist + GROW_SPEED_PX*dt);
    builder.bDist = Math.min(builder.bMax, builder.bDist + GROW_SPEED_PX*dt);

    const segs = builderSegments(builder);
    for (const ball of balls){
      for (const seg of segs){
        if (segmentIntersectsBall(seg, ball)){
          lives--;
          dangerTimer = 0.35;
          builder = null;
          updateUI();
          if (lives<=0) gameOver();
          return;
        }
      }
    }

    const done = (builder.aDist >= builder.aMax-0.5) && (builder.bDist >= builder.bMax-0.5);
    if (done){
      solidifyBuilder(builder);
      builder = null;
      floodFillCapture();
      updateUI();

      if (computeCaptureRatio() >= targetCapture){
        // +1 life between rounds (level complete), max 9
        lives = Math.min(MAX_LIVES, lives + 1);
        updateUI();

        paused = true;
        showOverlay('Level Complete!', `Captured ${fmtPct1(computeCaptureRatio())}.<br> +1 life! (Lives: ${lives}/${MAX_LIVES}) <br> Continue for Level ${level+1}.`);
      }
    }
  }

  // --- Simulation ---
  function moveBalls(dt){
    const sub = BALL_SUBSTEPS;
    const sdt = dt / sub;
    for (let k=0;k<sub;k++){
      for (const b of balls){
        b.x += b.vx * sdt;
        b.y += b.vy * sdt;
        resolveBallVsWalls(b);
      }
    }
  }

  // --- Cursor drawing ---
  function drawSpinningCursor(){
    if (!mouseInside) return;
    const x = mouse.x, y = mouse.y;

    const len = 18;
    const wing = 7;
    const a = aimAngle;

    const tipX = x + Math.cos(a)*len;
    const tipY = y + Math.sin(a)*len;

    ctx.fillStyle = COLORS.cursorSoft;
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI*2);
    ctx.fill();

    ctx.strokeStyle = COLORS.cursor;
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(tipX, tipY);
    ctx.stroke();

    const leftA  = a + Math.PI*0.85;
    const rightA = a - Math.PI*0.85;
    ctx.beginPath();
    ctx.moveTo(tipX, tipY);
    ctx.lineTo(tipX + Math.cos(leftA)*wing,  tipY + Math.sin(leftA)*wing);
    ctx.moveTo(tipX, tipY);
    ctx.lineTo(tipX + Math.cos(rightA)*wing, tipY + Math.sin(rightA)*wing);
    ctx.stroke();
  }

  // --- Render ---
  function draw(){
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0,0,W,H);

    ctx.strokeStyle = COLORS.grid;
    ctx.lineWidth = 1;
    for (let x=0; x<=W; x+=GRID*4){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    }
    for (let y=0; y<=H; y+=GRID*4){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
    }

    ctx.fillStyle = COLORS.wall;
    for (let y=0;y<ROWS;y++){
      for (let x=0;x<COLS;x++){
        if (grid[idx(x,y)]===1){
          ctx.fillRect(x*GRID, y*GRID, GRID, GRID);
        }
      }
    }

    if (builder){
      const segs = builderSegments(builder);
      ctx.strokeStyle = (dangerTimer>0) ? COLORS.danger : COLORS.grow;
      ctx.lineWidth = GRID;
      ctx.lineCap = 'butt';
      for (const s of segs){
        ctx.beginPath();
        ctx.moveTo(s.x1, s.y1);
        ctx.lineTo(s.x2, s.y2);
        ctx.stroke();
      }
      ctx.fillStyle = (dangerTimer>0) ? COLORS.danger : COLORS.grow;
      ctx.beginPath();
      ctx.arc(builder.x, builder.y, 4, 0, Math.PI*2);
      ctx.fill();
    }

    for (const b of balls){
      ctx.fillStyle = b.color;
      ctx.beginPath();
      ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
      ctx.fill();
    }

    drawSpinningCursor();
  }

  // --- Input ---
  function canvasToLocal(ev){
    const r = canvas.getBoundingClientRect();
    const x = (ev.clientX - r.left) * (canvas.width / r.width);
    const y = (ev.clientY - r.top) * (canvas.height / r.height);
    return {x,y};
  }

  canvas.addEventListener('mousemove', (ev) => {
    const p = canvasToLocal(ev);
    mouse.x = p.x; mouse.y = p.y;
  });
  canvas.addEventListener('mouseenter', () => { mouseInside = true; });
  canvas.addEventListener('mouseleave', () => { mouseInside = false; });

  canvas.addEventListener('click', (ev) => {
    if (paused) return;
    const p = canvasToLocal(ev);
    startBuilderAt(p.x, p.y, aimAngle);
  });

  window.addEventListener('keydown', (ev) => {
    if (ev.key.toLowerCase() === 'p') togglePause();
    if (ev.key === 'Escape' && !paused) togglePause();
  });

  // Buttons
  ui.restart.addEventListener('click', () => resetGame(true));
  ui.overlayRestart.addEventListener('click', () => resetGame(true));
  ui.pause.addEventListener('click', () => togglePause());

  ui.continueBtn.addEventListener('click', () => {
    const title = ui.overlayTitle.textContent || '';
    if (title.includes('Level Complete')) nextLevel();
    else { paused = false; hideOverlay(); }
  });

  function confirmClearScores(){
    if (confirm('Reset high scores? This cannot be undone.')) {
      clearAllScores();
      if (ui.overlayTitle.textContent === 'Game Over') {
        renderScoresOverlay(loadScores());
      }
    }
  }
  ui.overlayClearScores.addEventListener('click', confirmClearScores);

  function togglePause(){
    paused = !paused;
    if (paused) showOverlay('Paused', 'Press Continue to continue.');
    else hideOverlay();
  }

  // --- Loop ---
  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;

    if (!paused){
      dangerTimer = Math.max(0, dangerTimer - dt);
      aimAngle = (aimAngle + AIM_SPIN_SPEED*dt) % (Math.PI*2);

      moveBalls(dt);
      updateBuilder(dt);
      updateUI();
    }

    draw();
    requestAnimationFrame(tick);
  }

  // init
  // Ensure scores UI is hidden by default (only shown on Game Over)
  setScoresVisibility(false);

  resetGame(true);
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
