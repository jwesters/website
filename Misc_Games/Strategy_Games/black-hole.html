<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Black Hole</title>
  <style>
    :root{
      --bg:#0f1115;
      --panel:#171a21;
      --panel2:#1d2230;
      --text:#eef2ff;
      --muted:#a9b2c7;
      --blue:#5aa6ff;
      --pink:#ff6fb3;
      --hole:#05070c;
      --ring:rgba(255,255,255,.14);
      --shadow: 0 18px 50px rgba(0,0,0,.45);
      --radius:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background:
        radial-gradient(1100px 700px at 25% 0%, rgba(90,166,255,.16), transparent 60%),
        radial-gradient(900px 700px at 80% 35%, rgba(255,111,179,.14), transparent 55%),
        radial-gradient(900px 900px at 50% 120%, rgba(255,255,255,.06), transparent 60%),
        var(--bg);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      padding:24px;
    }
    .app{
      width:min(920px, 100%);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.10);
      border-radius: calc(var(--radius) + 6px);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    header{
      display:flex;
      gap:16px;
      align-items:center;
      justify-content:space-between;
      padding:18px 18px 14px 18px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.00));
      border-bottom:1px solid rgba(255,255,255,.08);
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:4px;
      line-height:1.1;
    }
    .title h1{
      font-size:18px;
      margin:0;
      letter-spacing:.4px;
    }
    .title .sub{
      font-size:12px;
      color:var(--muted);
      margin:0;
    }
    .controls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight:650;
      font-size:12px;
      letter-spacing:.2px;
      transition: transform .06s ease, background .2s ease, border-color .2s ease, opacity .2s ease;
      user-select:none;
    }
    button:hover{ background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.20); }
    button:active{ transform: translateY(1px); }
    button.primary{
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.05));
      border-color: rgba(255,255,255,.20);
    }
    button.danger{
      background: rgba(255,80,80,.10);
      border-color: rgba(255,80,80,.25);
    }
    button:disabled{
      cursor:not-allowed;
      opacity:.55;
    }

    main{
      display:grid;
      grid-template-columns: 1.25fr .75fr;
      gap:16px;
      padding:18px;
    }
    @media (max-width: 820px){
      main{grid-template-columns: 1fr; }
    }
    .boardWrap{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      padding:18px 14px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      min-height: 520px;
    }
    .turnBanner{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      margin-bottom:14px;
      padding:10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,.20);
      border:1px solid rgba(255,255,255,.10);
      text-align:center;
      font-weight:800;
      letter-spacing:.3px;
    }
    .dot{
      width:12px;height:12px;border-radius:50%;
      box-shadow: 0 0 0 5px rgba(255,255,255,.04);
    }
    .dot.blue{ background: var(--blue); }
    .dot.pink{ background: var(--pink); }
    .dot.draw{ background: rgba(255,255,255,.55); }

    .pyramid{
      display:flex;
      flex-direction:column;
      gap:10px;
      padding:10px 0 4px 0;
      user-select:none;
    }
    .row{
      display:flex;
      gap:10px;
      justify-content:center;
    }
    .cell{
      width:56px;height:56px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.04);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      font-size:18px;
      letter-spacing:.2px;
      cursor:pointer;
      transition: transform .08s ease, background .2s ease, border-color .2s ease, box-shadow .2s ease;
      position:relative;
      outline:none;
    }
    .cell:hover{
      transform: translateY(-1px);
      border-color: rgba(255,255,255,.26);
      background: rgba(255,255,255,.06);
      box-shadow: 0 10px 26px rgba(0,0,0,.22);
    }
    .cell:focus-visible{
      box-shadow: 0 0 0 4px rgba(90,166,255,.28);
    }
    .cell.filled{
      cursor:default;
      background: rgba(255,255,255,.05);
    }
    .cell.filled:hover{ transform:none; box-shadow:none; }
    .cell.blue{ color: var(--blue); border-color: rgba(90,166,255,.40); }
    .cell.pink{ color: var(--pink); border-color: rgba(255,111,179,.38); }
    .cell.hole{
      background: radial-gradient(circle at 35% 30%, rgba(255,255,255,.10), rgba(255,255,255,0) 50%), var(--hole);
      border-color: rgba(255,255,255,.20);
      cursor:default;
    }
    .cell.hole::after{
      content:"";
      position:absolute;
      inset:-6px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 0 0 10px rgba(0,0,0,.18) inset;
      pointer-events:none;
    }

    /* Last move highlight */
    @keyframes pulseRing {
      0%   { box-shadow: 0 0 0 0 rgba(255,255,255,.00), 0 0 0 0 rgba(255,255,255,.00); }
      35%  { box-shadow: 0 0 0 0 rgba(255,255,255,.00), 0 0 0 10px rgba(255,255,255,.07); }
      70%  { box-shadow: 0 0 0 0 rgba(255,255,255,.00), 0 0 0 18px rgba(255,255,255,.00); }
      100% { box-shadow: 0 0 0 0 rgba(255,255,255,.00), 0 0 0 0 rgba(255,255,255,.00); }
    }
    .cell.last::before{
      content:"";
      position:absolute;
      inset:-6px;
      border-radius:999px;
      border:2px solid rgba(255,255,255,.25);
      pointer-events:none;
      animation: pulseRing 1.25s ease-out infinite;
    }
    .cell.last.blue::before{ border-color: rgba(90,166,255,.60); }
    .cell.last.pink::before{ border-color: rgba(255,111,179,.58); }

    .side{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      padding:14px 14px;
    }
    .card h2{
      margin:0 0 10px 0;
      font-size:13px;
      letter-spacing:.25px;
      color:rgba(255,255,255,.88);
      text-transform:uppercase;
    }
    .scoreRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 10px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.08);
      border-radius: 14px;
      margin-top:10px;
    }
    .pill{
      display:flex;align-items:center;gap:10px;
      font-weight:850;
    }
    .pill small{
      display:block;
      font-weight:700;
      color:var(--muted);
      letter-spacing:.2px;
      margin-top:2px;
    }
    .wins{
      font-weight:950;
      font-size:18px;
    }
    .rule{
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.45;
    }
    .next{
      margin-top:10px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      padding:12px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.08);
    }
    .next .who{
      display:flex;
      gap:10px;
      align-items:center;
      font-weight:900;
    }
    .tag{
      font-weight:900;
      padding:6px 9px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-size:12px;
    }

    /* Mode toggle */
    .modeRow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .seg{
      flex:1;
      min-width:140px;
      padding:10px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .seg label{
      font-weight:850;
      font-size:12px;
      color:rgba(255,255,255,.90);
      letter-spacing:.2px;
      cursor:pointer;
      user-select:none;
      display:flex;
      align-items:center;
      gap:10px;
    }
    .seg input{ transform: translateY(1px); }

    /* Modal */
    .modalOverlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.62);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:50;
    }
    .modalOverlay.show{ display:flex; }
    .modal{
      width:min(520px, 100%);
      background: #151a26; /* fully opaque */
      border:1px solid rgba(255,255,255,.14);
      border-radius: 22px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modalHead{
      padding:16px 16px 12px 16px;
      border-bottom:1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .modalHead h3{
      margin:0;
      font-size:16px;
      letter-spacing:.2px;
    }
    .modalBody{
      padding:16px;
    }
    .bigResult{
      font-size:18px;
      font-weight:950;
      margin:0 0 12px 0;
      display:flex;
      align-items:center;
      gap:10px;
    }
    .scoreGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .scoreBox{
      padding:12px 12px;
      border-radius: 16px;
      background: rgba(0,0,0,.30);
      border:1px solid rgba(255,255,255,.10);
    }
    .scoreBox .label{
      font-size:12px;
      color:var(--muted);
      font-weight:800;
      letter-spacing:.2px;
      text-transform:uppercase;
      margin-bottom:6px;
      display:flex;
      gap:8px;
      align-items:center;
    }
    .scoreBox .val{
      font-size:22px;
      font-weight:980;
    }
    .modalFoot{
      padding:14px 16px 16px 16px;
      border-top:1px solid rgba(255,255,255,.10);
      display:flex;
      gap:10px;
      justify-content:flex-end;
      flex-wrap:wrap;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="title">
        <h1>Black Hole</h1>
        <p class="sub">Alternate placing 1–10. The last empty circle becomes the black hole. Lowest adjacent sum wins.</p>
      </div>
      <div class="controls">
        <button class="primary" id="newGameBtn">New Game</button>
        <button class="danger" id="resetTotalsBtn" title="Resets Blue wins, Pink wins, and Draws to 0">Erase Totals</button>
      </div>
    </header>

    <main>
      <section class="boardWrap">
        <div class="turnBanner" id="turnBanner">
          <span class="dot blue" id="turnDot"></span>
          <span id="turnText">Loading…</span>
        </div>

        <div class="pyramid" id="pyramid" aria-label="Black Hole board"></div>

        <div class="next" aria-live="polite">
          <div class="who">
            <span class="tag" id="nextTag">Blue</span>
            <span id="nextNumText">next number: 1</span>
          </div>
          <div style="color:var(--muted); font-weight:800; font-size:12px;">
            Moves placed: <span id="movesText">0</span> / 20
          </div>
        </div>
      </section>

      <aside class="side">
        <div class="card">
          <h2>Mode</h2>
          <div class="modeRow">
            <div class="seg">
              <label><input type="radio" name="mode" value="pvp" checked> Player vs Player</label>
            </div>
            <div class="seg">
              <label><input type="radio" name="mode" value="cpu"> Player vs CPU (Pink)</label>
            </div>
          </div>
          <p class="rule" style="margin-top:10px;">
            In CPU mode, Pink will play automatically with a short delay.
          </p>
        </div>

        <div class="card">
          <h2>Totals</h2>

          <div class="scoreRow">
            <div class="pill">
              <span class="dot blue"></span>
              <div>
                Blue
                <small>games won</small>
              </div>
            </div>
            <div class="wins" id="blueWins">0</div>
          </div>

          <div class="scoreRow">
            <div class="pill">
              <span class="dot pink"></span>
              <div>
                Pink
                <small>games won</small>
              </div>
            </div>
            <div class="wins" id="pinkWins">0</div>
          </div>

          <div class="scoreRow">
            <div class="pill">
              <span class="dot draw"></span>
              <div>
                Draws
                <small>tied games</small>
              </div>
            </div>
            <div class="wins" id="draws">0</div>
          </div>
        </div>

        <div class="card">
          <h2>How to Play</h2>
          <p class="rule">
            Each player places numbers <b>1</b> through <b>10</b> in order on their turns (click an empty circle).
            After 20 placements, the remaining circle becomes the <b>black hole</b>. Each player adds up the values
            in circles <b>adjacent</b> to the black hole (up-left, up-right, left, right, down-left, down-right).
            <b>Lowest sum wins.</b> If sums match, it’s a draw.
          </p>
        </div>
      </aside>
    </main>
  </div>

  <!-- Modal -->
  <div class="modalOverlay" id="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="modal">
      <div class="modalHead">
        <h3 id="modalTitle">Game Over</h3>
      </div>
      <div class="modalBody">
        <p class="bigResult" id="resultLine">
          <span class="dot draw"></span>
          <span>—</span>
        </p>

        <div class="scoreGrid">
          <div class="scoreBox">
            <div class="label"><span class="dot blue"></span> Blue adjacent sum</div>
            <div class="val" id="modalBlueScore">0</div>
          </div>
          <div class="scoreBox">
            <div class="label"><span class="dot pink"></span> Pink adjacent sum</div>
            <div class="val" id="modalPinkScore">0</div>
          </div>
        </div>
      </div>
      <div class="modalFoot">
        <button id="viewBoardBtn">View Board</button>
        <button class="primary" id="restartBtn">Restart</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const ROWS = 6; // 6-level pyramid
  const TOTAL_CELLS = (ROWS * (ROWS + 1)) / 2; // 21
  const PLACES_PER_PLAYER = 10;
  const TOTAL_PLACES = PLACES_PER_PLAYER * 2; // 20

  const pyramidEl = document.getElementById('pyramid');
  const newGameBtn = document.getElementById('newGameBtn');
  const resetTotalsBtn = document.getElementById('resetTotalsBtn');

  const blueWinsEl = document.getElementById('blueWins');
  const pinkWinsEl = document.getElementById('pinkWins');
  const drawsEl = document.getElementById('draws');

  const turnDot = document.getElementById('turnDot');
  const turnText = document.getElementById('turnText');
  const nextTag = document.getElementById('nextTag');
  const nextNumText = document.getElementById('nextNumText');
  const movesText = document.getElementById('movesText');

  const modalOverlay = document.getElementById('modalOverlay');
  const restartBtn = document.getElementById('restartBtn');
  const viewBoardBtn = document.getElementById('viewBoardBtn');
  const resultLine = document.getElementById('resultLine');
  const modalBlueScore = document.getElementById('modalBlueScore');
  const modalPinkScore = document.getElementById('modalPinkScore');

  const modeRadios = Array.from(document.querySelectorAll('input[name="mode"]'));

  // State
  const players = [
    { name: 'Blue', key:'blue', next: 1, wins: 0 },
    { name: 'Pink', key:'pink', next: 1, wins: 0 },
  ];
  let draws = 0;

  // Board: each cell {owner:null|'blue'|'pink', value:null|number, hole:boolean}
  let board = [];
  let coordToIndex = new Map(); // "r,c" => idx
  let indexToCoord = [];        // idx => {r,c}
  let current = 0;              // 0 blue, 1 pink
  let placed = 0;               // 0..20
  let gameOver = false;
  let lastMoveIdx = -1;

  let cpuMode = false;
  let cpuThinking = false;
  const CPU_DELAY_MS = 450;

  function keyOf(r,c){ return r + ',' + c; }
  function randInt(n){ return Math.floor(Math.random() * n); }

  function getMode(){
    const v = modeRadios.find(r => r.checked)?.value || 'pvp';
    return v;
  }

  function buildCoordMaps(){
    coordToIndex.clear();
    indexToCoord = [];
    let idx = 0;
    for(let r=0; r<ROWS; r++){
      for(let c=0; c<=r; c++){
        coordToIndex.set(keyOf(r,c), idx);
        indexToCoord[idx] = {r,c};
        idx++;
      }
    }
  }

  function neighborsOfIndex(idx){
    const {r,c} = indexToCoord[idx];
    const deltas = [
      [0,-1],[0,1],
      [-1,-1],[-1,0],
      [1,0],[1,1],
    ];
    const out = [];
    for(const [dr,dc] of deltas){
      const rr = r + dr;
      const cc = c + dc;
      if(rr < 0 || rr >= ROWS) continue;
      if(cc < 0 || cc > rr) continue;
      const nIdx = coordToIndex.get(keyOf(rr,cc));
      if(nIdx !== undefined) out.push(nIdx);
    }
    return out;
  }

  function degreeOfIndex(idx){
    return neighborsOfIndex(idx).length;
  }

  function emptyIndices(){
    const out = [];
    for(let i=0;i<board.length;i++){
      const c = board[i];
      if(!c.hole && !c.owner) out.push(i);
    }
    return out;
  }

  function initBoard(){
    cpuMode = (getMode() === 'cpu');
    board = Array.from({length: TOTAL_CELLS}, () => ({ owner:null, value:null, hole:false }));
    placed = 0;
    gameOver = false;
    cpuThinking = false;
    lastMoveIdx = -1;

    players[0].next = 1;
    players[1].next = 1;

    current = randInt(2); // random starter each game
    renderAll();

    // If CPU starts and CPU mode, let it play
    maybeCpuTurn();
  }

  function resetTotals(){
    players[0].wins = 0;
    players[1].wins = 0;
    draws = 0;
    renderTotals();
  }

  function renderTotals(){
    blueWinsEl.textContent = players[0].wins;
    pinkWinsEl.textContent = players[1].wins;
    drawsEl.textContent = draws;
  }

  function setTurnUI(){
    const p = players[current];
    turnDot.className = 'dot ' + p.key;

    if(cpuMode && p.key === 'pink'){
      turnText.textContent = `Pink's Turn (CPU)`;
    } else {
      turnText.textContent = `${p.name}'s Turn`;
    }

    nextTag.textContent = p.name;
    nextTag.style.borderColor = p.key === 'blue' ? 'rgba(90,166,255,.38)' : 'rgba(255,111,179,.36)';
    nextTag.style.color = p.key === 'blue' ? 'var(--blue)' : 'var(--pink)';
    nextNumText.textContent = `next number: ${p.next}`;
    movesText.textContent = placed;
  }

  function cellLabel(cell){
    if(cell.hole) return '';
    if(cell.value == null) return '';
    return String(cell.value);
  }

  function renderBoard(){
    pyramidEl.innerHTML = '';
    // build DOM rows
    let idx = 0;
    for(let r=0; r<ROWS; r++){
      const row = document.createElement('div');
      row.className = 'row';
      for(let c=0; c<=r; c++){
        const cell = board[idx];
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'cell';
        btn.setAttribute('aria-label', `Cell row ${r+1} col ${c+1}`);
        btn.dataset.index = String(idx);

        // Disable clicking while CPU is thinking or game over (still allow focus)
        if(cpuThinking || gameOver) btn.disabled = true;

        if(cell.hole){
          btn.classList.add('hole','filled');
          btn.title = 'Black hole';
        } else if(cell.owner){
          btn.classList.add('filled', cell.owner);
          btn.title = `${cell.owner === 'blue' ? 'Blue' : 'Pink'}: ${cell.value}`;
          if(idx === lastMoveIdx){
            btn.classList.add('last');
          }
        } else {
          btn.title = 'Empty';
        }

        btn.textContent = cellLabel(cell);
        btn.addEventListener('click', onCellClick);

        row.appendChild(btn);
        idx++;
      }
      pyramidEl.appendChild(row);
    }
  }

  function renderAll(){
    renderTotals();
    renderBoard();
    setTurnUI();
    // Disable New Game while CPU is mid-move to avoid weirdness
    newGameBtn.disabled = cpuThinking;
  }

  function placeAt(idx){
    const cell = board[idx];
    if(cell.hole || cell.owner) return false;

    const p = players[current];
    if(p.next > PLACES_PER_PLAYER) return false;

    cell.owner = p.key;
    cell.value = p.next;
    p.next++;
    placed++;
    lastMoveIdx = idx;

    return true;
  }

  function onCellClick(e){
    if(gameOver || cpuThinking) return;
    // If CPU mode and it's CPU's turn, ignore human clicks
    if(cpuMode && players[current].key === 'pink') return;

    const idx = Number(e.currentTarget.dataset.index);
    if(!placeAt(idx)) return;

    if(placed >= TOTAL_PLACES){
      finalizeGame();
    } else {
      current = 1 - current;
      renderAll();
      maybeCpuTurn();
    }
  }

  function finalizeGame(){
    // mark remaining empty cell as black hole
    const holeIdx = board.findIndex(c => !c.owner && !c.hole);
    if(holeIdx >= 0){
      board[holeIdx].hole = true;
    }

    // score neighbors
    let blueSum = 0;
    let pinkSum = 0;
    const neigh = neighborsOfIndex(holeIdx);
    for(const n of neigh){
      const c = board[n];
      if(!c.owner || c.value == null) continue;
      if(c.owner === 'blue') blueSum += c.value;
      if(c.owner === 'pink') pinkSum += c.value;
    }

    // determine winner (lowest wins)
    let resultText = '';
    let resultDotClass = 'draw';
    if(blueSum < pinkSum){
      players[0].wins++;
      resultText = 'Blue wins (lowest adjacent sum)';
      resultDotClass = 'blue';
    } else if(pinkSum < blueSum){
      players[1].wins++;
      resultText = 'Pink wins (lowest adjacent sum)';
      resultDotClass = 'pink';
    } else {
      draws++;
      resultText = 'Draw (equal adjacent sums)';
      resultDotClass = 'draw';
    }

    gameOver = true;

    // Update UI and show modal
    renderAll();
    showModal(resultText, resultDotClass, blueSum, pinkSum);
  }

  function showModal(resultText, dotClass, blueScore, pinkScore){
    modalBlueScore.textContent = blueScore;
    modalPinkScore.textContent = pinkScore;

    // Build result line
    resultLine.innerHTML = '';
    const dot = document.createElement('span');
    dot.className = 'dot ' + dotClass;
    const txt = document.createElement('span');
    txt.textContent = resultText;
    resultLine.appendChild(dot);
    resultLine.appendChild(txt);

    modalOverlay.classList.add('show');
    // focus a sensible button
    viewBoardBtn.focus();
  }

  function hideModal(){
    modalOverlay.classList.remove('show');
  }

  function maybeCpuTurn(){
    if(!cpuMode) return;
    if(gameOver) return;
    if(players[current].key !== 'pink') return;

    cpuThinking = true;
    renderAll();

    setTimeout(() => {
      cpuMove();
      cpuThinking = false;

      if(placed >= TOTAL_PLACES){
        renderAll();
        finalizeGame();
      } else {
        current = 1 - current;
        renderAll();
      }
    }, CPU_DELAY_MS);
  }

  function cpuMove(){
    const empties = emptyIndices();
    if(empties.length === 0) return;

    const cpu = players[1]; // pink
    const n = cpu.next;

    // 50/50 random vs heuristic
    const doRandom = Math.random() < 0.5;
    let choiceIdx;

    if(doRandom){
      choiceIdx = empties[randInt(empties.length)];
    } else {
      // Heuristic:
      // - high numbers prefer low-degree (edges/corners)
      // - low numbers prefer high-degree (centers)
      // Score = (high? degree : -degree) + tiny random jitter
      let bestScore = -Infinity;
      let best = empties[0];
      for(const idx of empties){
        const deg = degreeOfIndex(idx); // 2..6
        const jitter = (Math.random() - 0.5) * 0.25;
        const score = (n >= 6 ? -deg : deg) + jitter;
        if(score > bestScore){
          bestScore = score;
          best = idx;
        }
      }
      choiceIdx = best;
    }

    placeAt(choiceIdx);
  }

  // Controls
  newGameBtn.addEventListener('click', () => {
    hideModal();
    initBoard();
  });

  restartBtn.addEventListener('click', () => {
    hideModal();
    initBoard();
  });

  viewBoardBtn.addEventListener('click', () => {
    hideModal();
  });

  resetTotalsBtn.addEventListener('click', () => {
    resetTotals();
  });

  // Clicking outside modal closes (view board)
  modalOverlay.addEventListener('click', (e) => {
    if(e.target === modalOverlay) hideModal();
  });

  // ESC closes modal (view board)
  window.addEventListener('keydown', (e) => {
    if(e.key === 'Escape' && modalOverlay.classList.contains('show')) hideModal();
  });

  // If mode changes mid-game, start a fresh game to avoid odd states
  modeRadios.forEach(r => r.addEventListener('change', () => {
    initBoard();
  }));

  // Boot
  buildCoordMaps();
  initBoard();
})();
</script>
</body>
</html>
