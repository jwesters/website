<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Bomb Hunt Minesweeper</title>
<style>
  :root{
    --bg:#c0c0c0;
    --dark:#808080;
    --darker:#404040;
    --light:#ffffff;
    --shadow:#7a7a7a;
    --cell:24px;
    --gap:0px;
    --font:"Segoe UI", Tahoma, Verdana, Arial, sans-serif;
  }
  *{ box-sizing:border-box; }
  html,body{
    margin:0;
    background:#9b9b9b;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-start;
    padding:18px;
    font-family:var(--font);
    color:#000;
  }
  body{
    margin:0;
    background:#9b9b9b;
    display:flex;
    align-items:flex-start;
    justify-content:center;
    padding:18px;
    font-family:var(--font);
    color:#000;
  }
  .panel{
    background:var(--bg);
    padding:10px;
    border-top:3px solid var(--light);
    border-left:3px solid var(--light);
    border-right:3px solid var(--darker);
    border-bottom:3px solid var(--darker);
    box-shadow:0 8px 22px rgba(0,0,0,.18);
    width:fit-content;
    max-width:min(820px,96vw);
    margin:0 auto;
  }
  .select, .btn{
    background:var(--bg);
    border-top:2px solid var(--light);
    border-left:2px solid var(--light);
    border-right:2px solid var(--darker);
    border-bottom:2px solid var(--darker);
    padding:6px 10px;
    font-size:14px;
    cursor:pointer;
    user-select:none;
  }
  select.select{ padding:5px 8px; }
  .toggle{ display:flex; align-items:center; gap:6px; flex-wrap:wrap; }
  .toggle .mode{ min-width:96px; text-align:center; }

  .topbar{
    display:flex;
    gap:10px;
    align-items:center;
    justify-content:space-between;
    padding:6px 8px;
    background:var(--bg);
    border-top:2px solid var(--shadow);
    border-left:2px solid var(--shadow);
    border-right:2px solid var(--light);
    border-bottom:2px solid var(--light);
    margin-bottom:10px;
  }
  .led-wrap{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:3px;
    user-select:none;
  }
  .led-label{ font-size:11px; color:#222; letter-spacing:.2px; }
  .led{
    background:#000;
    color:#ff2b2b;
    font-family:"Courier New", Courier, monospace;
    font-weight:700;
    letter-spacing:1px;
    font-size:22px;
    line-height:1;
    padding:4px 6px 3px;
    border-top:2px solid var(--darker);
    border-left:2px solid var(--darker);
    border-right:2px solid var(--light);
    border-bottom:2px solid var(--light);
    min-width:62px;
    text-align:center;
  }

  .face{
    width:38px; height:38px;
    background:var(--bg);
    border-top:3px solid var(--light);
    border-left:3px solid var(--light);
    border-right:3px solid var(--darker);
    border-bottom:3px solid var(--darker);
    display:grid;
    place-items:center;
    cursor:pointer;
    user-select:none;
  }
  .face:active{
    border-top:3px solid var(--darker);
    border-left:3px solid var(--darker);
    border-right:3px solid var(--light);
    border-bottom:3px solid var(--light);
  }
  .face span{ font-size:22px; }

  .board-wrap{
    padding:10px;
    background:var(--bg);
    border-top:3px solid var(--shadow);
    border-left:3px solid var(--shadow);
    border-right:3px solid var(--light);
    border-bottom:3px solid var(--light);
    width:fit-content;
    max-width:100%;
    overflow:auto;
    -webkit-overflow-scrolling:touch;
  }
  .grid{
    display:grid;
    grid-template-columns:repeat(var(--cols), var(--cell));
    grid-auto-rows:var(--cell);
    gap:var(--gap);
    touch-action:manipulation;
  }
  .cell{
    width:var(--cell); height:var(--cell);
    background:var(--bg);
    border-top:2px solid var(--light);
    border-left:2px solid var(--light);
    border-right:2px solid var(--shadow);
    border-bottom:2px solid var(--shadow);
    display:grid;
    place-items:center;
    font-size:16px;
    font-weight:800;
    user-select:none;
    position:relative;
    cursor:pointer;
  }
  .cell:active{
    border-top:2px solid var(--shadow);
    border-left:2px solid var(--shadow);
    border-right:2px solid var(--light);
    border-bottom:2px solid var(--light);
  }
  .cell.revealed{
    border:1px solid #a0a0a0;
    background:#c6c6c6;
    cursor:default;
  }
  .cell.revealed:active{ border:1px solid #a0a0a0; }
  .cell.bomb-found{
    background:#c6c6c6;
  }
  .cell .flag{ font-size:16px; line-height:1; transform:translateY(-1px); }
  .cell .qmark{ font-size:16px; line-height:1; transform:translateY(-1px); }

  .n1{ color:#0000ff; }
  .n2{ color:#008000; }
  .n3{ color:#ff0000; }
  .n4{ color:#000080; }
  .n5{ color:#800000; }
  .n6{ color:#008080; }
  .n7{ color:#000000; }
  .n8{ color:#808080; }

  .footer{
    margin-top:10px;
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:flex-start;
    justify-content:space-between;
    font-size:13px;
    color:#222;
  }
  .hs{
    background:var(--bg);
    border-top:2px solid var(--shadow);
    border-left:2px solid var(--shadow);
    border-right:2px solid var(--light);
    border-bottom:2px solid var(--light);
    padding:6px 8px;
    user-select:none;
    min-width:220px;
  }
  .small{
    font-size:12px;
    color:#333;
    user-select:none;
    max-width:520px;
  }
  @media (max-width:520px){
    :root{ --cell:22px; }
    .led{ font-size:20px; min-width:58px; }
    .face{ width:36px; height:36px; }
  }

  .banner{
    width: min(820px, 96vw);
    margin: 0 auto 10px auto;
    position: relative;
    padding-top: 10px;
  }
  .banner .line{
    height: 2px;
    background: rgba(255,255,255,.75);
    width: 100%;
    margin: 0 auto 10px auto;
  }
  .banner .title{
    font-weight: 800;
    font-size: 30px;
    letter-spacing: .2px;
    color: #000;
    text-align: left;
    padding-left: 8px;
  }

</style>
</head>
<body>

  <div class="banner" aria-hidden="true">
    <div class="line"></div>
    <div class="title">Hit the Bombs</div>
  </div>

  <div class="panel" id="app">
    <div class="controls">
      <select class="select" id="difficulty">
        <option value="beginner">Beginner (9Ã—9, 10 bombs)</option>
        <option value="intermediate">Intermediate (16Ã—16, 40 bombs)</option>
        <option value="expert">Expert (30Ã—16, 99 bombs)</option>
      </select>

      <div class="toggle">
        <button class="btn mode" id="modeBtn" title="Tap to toggle. On mobile, long-press also flags.">Mode: Reveal</button>
        <button class="btn" id="resetHS" title="Reset saved best scores">Reset Best Scores</button>
      </div>
    </div>

    <div class="topbar">
      <div class="led-wrap" title="Bombs found">
        <div class="led" id="bombsFound">000</div>
        <div class="led-label" id="bombsLabel">FOUND / 010</div>
      </div>

      <div class="face" id="face" title="New game"><span id="faceIcon">ðŸ™‚</span></div>

      <div class="led-wrap" title="Clicks (safe reveals)">
        <div class="led" id="clicks">000</div>
        <div class="led-label">CLICKS</div>
      </div>
    </div>

    <div class="board-wrap">
      <div class="grid" id="grid" aria-label="Minesweeper board"></div>
    </div>

    <div class="footer">
      <div class="hs" id="bestScores"></div>
      <div class="small" id="hint">
        Goal: reveal all bombs with the fewest clicks. Clicking a bomb reveals it but does <b>not</b> add to clicks.
        Right-click flags. Long-press flags. Clicking a number can chord when flags match.
      </div>
    </div>
  </div>

<script>
(() => {
  const presets = {
    beginner: { cols: 9, rows: 9, bombs: 10 },
    intermediate: { cols: 16, rows: 16, bombs: 40 },
    expert: { cols: 30, rows: 16, bombs: 99 },
  };

  const gridEl = document.getElementById('grid');
  const bombsFoundEl = document.getElementById('bombsFound');
  const bombsLabelEl = document.getElementById('bombsLabel');
  const clicksEl = document.getElementById('clicks');
  const faceEl = document.getElementById('face');
  const faceIconEl = document.getElementById('faceIcon');
  const difficultyEl = document.getElementById('difficulty');
  const bestScoresEl = document.getElementById('bestScores');
  const modeBtn = document.getElementById('modeBtn');
  const resetHSBtn = document.getElementById('resetHS');

  let cols = 9, rows = 9, bombTotal = 10;
  let board = [];
  let gameOver = false;

  let bombsFound = 0;
  let clicks = 0;

  let touchMode = 'reveal'; // 'reveal' | 'flag'

  // ----- Sounds (simple WebAudio synth) -----
  let audioCtx = null;
  function getAudio(){
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    return audioCtx;
  }
  function beep(freq=440, dur=0.06, type='square', gain=0.06){
    const ctx = getAudio();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = type; o.frequency.value = freq; g.gain.value = gain;
    o.connect(g); g.connect(ctx.destination);
    const t = ctx.currentTime;
    o.start(t); o.stop(t + dur);
    g.gain.setValueAtTime(gain, t);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
  }
  function noiseBurst(dur=0.14, gain=0.10){
    const ctx = getAudio();
    const bufferSize = Math.floor(ctx.sampleRate * dur);
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<bufferSize;i++){
      data[i] = (Math.random()*2-1) * (1 - i/bufferSize);
    }
    const src = ctx.createBufferSource();
    const g = ctx.createGain();
    g.gain.value = gain;
    src.buffer = buffer;
    src.connect(g); g.connect(ctx.destination);
    src.start();
  }
  const SFX = {
    click(){ beep(880, 0.04, 'square', 0.05); },
    reveal(){ beep(660, 0.04, 'square', 0.05); },
    flag(){ beep(440, 0.05, 'square', 0.05); },
    unflag(){ beep(330, 0.05, 'square', 0.05); },
    chord(){ beep(990, 0.03, 'square', 0.045); },
    bomb(){ noiseBurst(0.10, 0.08); beep(220, 0.06, 'sawtooth', 0.06); },
    win(){ beep(784, 0.08, 'square', 0.06); setTimeout(()=>beep(988,0.08,'square',0.06),90); setTimeout(()=>beep(1319,0.10,'square',0.06),180); },
  };

  // ----- Helpers -----
  const idx = (x,y)=> y*cols + x;
  const inBounds = (x,y)=> x>=0 && y>=0 && x<cols && y<rows;

  function neighbors(x,y){
    const out = [];
    for (let dy=-1; dy<=1; dy++){
      for (let dx=-1; dx<=1; dx++){
        if (dx===0 && dy===0) continue;
        const nx=x+dx, ny=y+dy;
        if (inBounds(nx,ny)) out.push([nx,ny]);
      }
    }
    return out;
  }

  function pad3(n){ return Math.max(0, Math.min(999, n)).toString().padStart(3,'0'); }
  function setLED(el, value){ el.textContent = pad3(value); }

  function setFace(state){
    // ðŸ™‚ normal, ðŸ˜® pressed, ðŸ˜Ž win
    if (state === 'normal') faceIconEl.textContent = 'ðŸ™‚';
    else if (state === 'pressed') faceIconEl.textContent = 'ðŸ˜®';
    else if (state === 'win') faceIconEl.textContent = 'ðŸ˜Ž';
  }

  // ----- Best scores (fewest clicks) -----
  const HS_KEY = 'bombhunt_best_clicks_v1';
  function getHS(){
    try{
      const raw = localStorage.getItem(HS_KEY);
      return raw ? JSON.parse(raw) : {};
    }catch{ return {}; }
  }
  function setHS(obj){
    try{ localStorage.setItem(HS_KEY, JSON.stringify(obj)); }catch{}
  }
  function renderHS(){
    const hs = getHS();
    const fmt = v => (v==null ? 'â€”' : (v + ' clicks'));
    bestScoresEl.innerHTML = `
      <div><b>Best Scores (fewest clicks)</b></div>
      <div>Beginner: <b>${fmt(hs.beginner ?? null)}</b></div>
      <div>Intermediate: <b>${fmt(hs.intermediate ?? null)}</b></div>
      <div>Expert: <b>${fmt(hs.expert ?? null)}</b></div>
    `;
  }
  function maybeRecordHS(){
    const key = difficultyEl.value;
    const hs = getHS();
    const prev = hs[key];
    if (prev == null || clicks < prev){
      hs[key] = clicks;
      setHS(hs);
      renderHS();
    }
  }

  // ----- Board setup -----
  function newBoard(){
    const p = presets[difficultyEl.value];
    cols = p.cols; rows = p.rows; bombTotal = p.bombs;

    if (difficultyEl.value === 'expert' && window.innerWidth < 600){
      document.documentElement.style.setProperty('--cell','20px');
    } else {
      document.documentElement.style.setProperty('--cell','');
    }
    document.documentElement.style.setProperty('--cols', cols);

    board = [];
    for (let y=0;y<rows;y++){
      for (let x=0;x<cols;x++){
        board.push({
          x,y,
          bomb:false,
          revealed:false,
          bombRevealed:false,
          flagged:false,
          qmark:false,
          adj:0,
          el:null
        });
      }
    }

    placeBombs();
    computeAdj();

    gameOver = false;
    bombsFound = 0;
    clicks = 0;
    setLED(bombsFoundEl, 0);
    bombsLabelEl.textContent = `FOUND / ${pad3(bombTotal)}`;
    setLED(clicksEl, 0);
    setFace('normal');

    buildGrid();
    refreshAllCells();
    renderHS();
  }

  function placeBombs(){
    const indices = Array.from({length: board.length}, (_,i)=>i);
    for (let i=indices.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [indices[i], indices[j]] = [indices[j], indices[i]];
    }
    for (let m=0; m<bombTotal; m++){
      board[indices[m]].bomb = true;
    }
  }

  function computeAdj(){
    for (let i=0;i<board.length;i++){
      const c = board[i];
      if (c.bomb){ c.adj = 0; continue; }
      let count = 0;
      for (const [nx,ny] of neighbors(c.x,c.y)){
        if (board[idx(nx,ny)].bomb) count++;
      }
      c.adj = count;
    }
  }

  function buildGrid(){
    gridEl.innerHTML = '';
    const frag = document.createDocumentFragment();
    for (let i=0;i<board.length;i++){
      const c = board[i];
      const d = document.createElement('div');
      d.className = 'cell';
      d.setAttribute('role','button');
      d.dataset.i = String(i);
      c.el = d;

      d.addEventListener('mousedown', (e)=>{
        if (gameOver) return;
        if (e.button === 0) setFace('pressed');
      });
      d.addEventListener('mouseup', ()=>{
        if (gameOver) return;
        setFace('normal');
      });

      d.addEventListener('contextmenu', (e)=>{
        e.preventDefault();
        if (gameOver) return;
        onFlag(i);
      });

      d.addEventListener('click', ()=>{
        if (gameOver) return;
        if (touchMode === 'flag' && isTouchDevice()){
          onFlag(i);
        } else {
          onReveal(i);
        }
      });

      attachLongPress(d, ()=>{
        if (gameOver) return;
        onFlag(i);
      });

      frag.appendChild(d);
    }
    gridEl.appendChild(frag);
  }

  function isTouchDevice(){
    return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
  }

  function attachLongPress(el, cb){
    let pressTimer = null;
    let moved = false;

    const start = () => {
      if (gameOver) return;
      moved = false;
      pressTimer = setTimeout(() => {
        pressTimer = null;
        if (!moved) cb();
      }, 380);
    };
    const cancel = () => {
      if (pressTimer){
        clearTimeout(pressTimer);
        pressTimer = null;
      }
    };

    el.addEventListener('touchstart', start, {passive:true});
    el.addEventListener('touchend', cancel);
    el.addEventListener('touchcancel', cancel);
    el.addEventListener('touchmove', ()=>{ moved=true; cancel(); }, {passive:true});
  }

  // ----- UI refresh -----
  function refreshCell(i){
    const c = board[i];
    const el = c.el;
    if (!el) return;

    el.innerHTML = '';
    el.classList.remove('revealed','bomb-found');
    for (let k=1;k<=8;k++) el.classList.remove('n'+k);

    if (c.bombRevealed){
      el.classList.add('revealed','bomb-found');
      el.textContent = 'ðŸ’£';
      return;
    }

    if (c.revealed){
      el.classList.add('revealed');
      if (c.adj > 0){
        el.textContent = String(c.adj);
        el.classList.add('n'+c.adj);
      }
      return;
    }

    if (c.flagged){
      const s = document.createElement('span');
      s.className = 'flag';
      s.textContent = 'ðŸš©';
      el.appendChild(s);
    } else if (c.qmark){
      const s = document.createElement('span');
      s.className = 'qmark';
      s.textContent = '?';
      el.appendChild(s);
    }
  }

  function refreshAllCells(){
    for (let i=0;i<board.length;i++) refreshCell(i);
  }

  function setBombsFound(n){
    bombsFound = n;
    setLED(bombsFoundEl, bombsFound);
    bombsLabelEl.textContent = `FOUND / ${pad3(bombTotal)}`;
  }

  function incClicks(){
    clicks = Math.min(999, clicks + 1);
    setLED(clicksEl, clicks);
  }

  // ----- Gameplay -----
  function onReveal(i){
    const c = board[i];

    if (c.bombRevealed) return;

    // Clicking a bomb reveals it, but does NOT add to clicks
    if (!c.revealed && c.bomb && !c.flagged){
      c.bombRevealed = true;
      refreshCell(i);
      setBombsFound(bombsFound + 1);
      SFX.bomb();
      checkWin();
      return;
    }

    // Chord on revealed numbers
    if (c.revealed){
      if (c.adj > 0){
        const revealedAny = tryChord(i);
        if (revealedAny) incClicks();
      }
      return;
    }

    if (c.flagged) return;

    // Safe reveal counts as a click
    const revealedAny = floodReveal(i);
    if (revealedAny){
      incClicks();
      SFX.reveal();
      checkWin();
    }
  }

  function floodReveal(startIdx){
    const start = board[startIdx];
    if (start.revealed || start.flagged || start.bomb) return false;

    let revealedCount = 0;
    const stack = [startIdx];

    while (stack.length){
      const i = stack.pop();
      const c = board[i];
      if (c.revealed || c.flagged || c.bomb) continue;
      c.revealed = true;
      c.qmark = false;
      revealedCount++;
      refreshCell(i);

      if (c.adj === 0){
        for (const [nx,ny] of neighbors(c.x,c.y)){
          const ni = idx(nx,ny);
          const n = board[ni];
          if (!n.revealed && !n.flagged && !n.bomb){
            stack.push(ni);
          }
        }
      }
    }
    return revealedCount > 0;
  }

  function cycleMark(c){
    if (!c.flagged && !c.qmark){
      c.flagged = true; c.qmark = false; SFX.flag();
    } else if (c.flagged){
      c.flagged = false; c.qmark = true; SFX.unflag();
    } else {
      c.qmark = false; c.flagged = false; SFX.click();
    }
  }

  function onFlag(i){
    const c = board[i];
    if (c.revealed || c.bombRevealed) return;
    cycleMark(c);
    refreshCell(i);
  }

  function tryChord(i){
    const c = board[i];
    if (!c.revealed || c.adj <= 0) return false;

    let flagged = 0;
    const neigh = neighbors(c.x,c.y);
    for (const [nx,ny] of neigh){
      if (board[idx(nx,ny)].flagged) flagged++;
    }
    if (flagged !== c.adj) return false;

    SFX.chord();
    let revealedAny = false;

    for (const [nx,ny] of neigh){
      const ni = idx(nx,ny);
      const n = board[ni];
      if (n.revealed || n.flagged || n.bombRevealed) continue;
      if (n.bomb){
        // Keep bombs hidden unless directly clicked
        continue;
      }
      const did = floodReveal(ni);
      revealedAny = revealedAny || did;
    }
    if (revealedAny) checkWin();
    return revealedAny;
  }

  function checkWin(){
    if (gameOver) return;
    if (bombsFound >= bombTotal){
      win();
    }
  }

  function win(){
    gameOver = true;
    setFace('win');
    SFX.win();
    maybeRecordHS();

    // Reveal remaining bombs for satisfaction
    for (let i=0;i<board.length;i++){
      const c = board[i];
      if (c.bomb && !c.bombRevealed){
        c.bombRevealed = true;
        refreshCell(i);
      }
    }
    setBombsFound(bombTotal);
  }

  // ----- Mode toggle -----
  function updateModeUI(){
    modeBtn.textContent = touchMode === 'reveal' ? 'Mode: Reveal' : 'Mode: Flag';
  }
  modeBtn.addEventListener('click', ()=>{
    touchMode = (touchMode === 'reveal') ? 'flag' : 'reveal';
    updateModeUI();
    SFX.click();
  });

  // ----- Controls -----
  faceEl.addEventListener('click', ()=>{ SFX.click(); newBoard(); });
  difficultyEl.addEventListener('change', ()=>{ SFX.click(); newBoard(); });
  resetHSBtn.addEventListener('click', ()=>{
    SFX.click();
    try{ localStorage.removeItem(HS_KEY); }catch{}
    renderHS();
  });

  document.addEventListener('dragstart', (e)=>e.preventDefault());
  window.addEventListener('keydown', (e)=>{ if (e.key==='r'||e.key==='R') newBoard(); });

  updateModeUI();
  renderHS();
  newBoard();
})();
</script>
</body>
</html>
