<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Group Maker (Offline)</title>
  <style>
    :root{
      --bg:#0e1020;
      --panel:#141836;
      --panel2:#111432;
      --text:#eef1ff;
      --muted:#b8bfe6;
      --accent:#7aa2ff;
      --good:#6bffb1;
      --warn:#ffb86b;
      --bad:#ff6b6b;
      --border:rgba(255,255,255,.12);
      --shadow: 0 14px 34px rgba(0,0,0,.45);
      --radius:18px;
    }
    *{ box-sizing:border-box; }
    html, body { height:100%; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 900px at 20% -10%, rgba(122,162,255,.25), transparent 55%),
                  radial-gradient(900px 700px at 95% 20%, rgba(107,255,177,.14), transparent 55%),
                  radial-gradient(900px 700px at 30% 110%, rgba(255,107,107,.12), transparent 60%),
                  var(--bg);
      color:var(--text);
    }
    .wrap{
      max-width: 1040px;
      margin: 28px auto;
      padding: 0 16px 28px;
    }
    header{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:16px;
      margin-bottom:14px;
    }
    h1{
      margin:0;
      font-size: 22px;
      letter-spacing: .2px;
    }
    .subtitle{
      color:var(--muted);
      margin-top:6px;
      font-size: 13px;
      line-height: 1.35;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .grid{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:14px;
    }
    @media (max-width: 900px){
      .grid{ grid-template-columns: 1fr; }
    }
    .section{
      padding:14px;
      background: rgba(255,255,255,.02);
    }
    .section + .section{
      border-top:1px solid var(--border);
    }
    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .row.spread{ justify-content:space-between; }
    label{
      font-size: 13px;
      color: var(--muted);
    }
    textarea{
      width:100%;
      min-height: 320px;
      resize: vertical;
      padding: 12px 12px;
      border-radius: 14px;
      background: rgba(10,12,28,.65);
      color: var(--text);
      border:1px solid var(--border);
      outline: none;
      font-size: 14px;
      line-height: 1.35;
    }
    textarea[readonly]{
      opacity:.92;
    }
    select, input[type="text"]{
      background: rgba(10,12,28,.65);
      color: var(--text);
      border:1px solid var(--border);
      border-radius: 12px;
      padding: 10px 10px;
      font-size: 14px;
      outline:none;
    }
    .btn{
      appearance:none;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 14px;
      padding: 10px 12px;
      font-weight: 650;
      font-size: 14px;
      cursor: pointer;
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
      user-select:none;
    }
    .btn:hover{
      background: rgba(255,255,255,.10);
      border-color: rgba(255,255,255,.18);
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: rgba(122,162,255,.18);
      border-color: rgba(122,162,255,.45);
    }
    .btn.primary:hover{
      background: rgba(122,162,255,.26);
      border-color: rgba(122,162,255,.60);
    }
    .btn.good{
      background: rgba(107,255,177,.16);
      border-color: rgba(107,255,177,.42);
    }
    .btn.good:hover{
      background: rgba(107,255,177,.22);
      border-color: rgba(107,255,177,.55);
    }
    .btn.warn{
      background: rgba(255,184,107,.16);
      border-color: rgba(255,184,107,.42);
    }
    .btn.warn:hover{
      background: rgba(255,184,107,.22);
      border-color: rgba(255,184,107,.55);
    }
    .btn.bad{
      background: rgba(255,107,107,.16);
      border-color: rgba(255,107,107,.42);
    }
    .btn.bad:hover{
      background: rgba(255,107,107,.22);
      border-color: rgba(255,107,107,.55);
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      color: var(--muted);
      font-size: 13px;
      user-select:none;
    }
    .toggle{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding: 8px 10px;
      border-radius: 999px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      color: var(--muted);
      font-size: 13px;
      cursor:pointer;
      user-select:none;
    }
    .toggle input{ width:18px; height:18px; accent-color: var(--accent); }
    .msg{
      margin-top:10px;
      padding: 10px 12px;
      border-radius: 14px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
      min-height: 42px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .msg strong{ color: var(--text); }
    .msg.ok{ border-color: rgba(107,255,177,.35); background: rgba(107,255,177,.08); }
    .msg.warn{ border-color: rgba(255,184,107,.40); background: rgba(255,184,107,.08); }
    .msg.bad{ border-color: rgba(255,107,107,.35); background: rgba(255,107,107,.08); }
    .groups{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap:12px;
    }
    @media (max-width: 700px){
      .groups{ grid-template-columns: 1fr; }
    }
    .groupCard{
      border-radius: 16px;
      border:1px solid var(--border);
      background: rgba(10,12,28,.55);
      padding: 12px 12px;
    }
    .groupTitle{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .groupTitle b{ font-size: 14px; }
    .groupTitle span{
      font-size: 12px;
      color: var(--muted);
    }
    ul{
      margin:0;
      padding-left: 18px;
      color: var(--text);
    }
    li{ margin: 4px 0; }
    .footerNote{
      color: var(--muted);
      font-size: 12px;
      padding: 12px 14px;
      border-top:1px solid var(--border);
      background: rgba(255,255,255,.015);
    }
    .mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      color: var(--muted);
      word-break: break-all;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Random Group Maker</h1>
        <div class="subtitle">
          Enter up to <strong>30</strong> names (one per line). Choose a group size, then generate groups.
          Share links include the names (compressed) so everyone gets the same list.
        </div>
      </div>
      <div class="pill" id="countPill">0 names</div>
    </header>

    <div class="card">
      <div class="grid">
        <div class="section">
          <div class="row spread" style="margin-bottom:10px;">
            <label for="names">Names (one per line)</label>
            <label class="toggle" title="Lock/unlock the names list">
              <input id="lockNames" type="checkbox" />
              Lock names
            </label>
          </div>

          <textarea id="names" placeholder="Type or paste names here…&#10;Jake&#10;Scott&#10;Paul"></textarea>

          <div class="row" style="margin-top:10px;">
            <div class="row" style="gap:8px;">
              <label for="groupSize">Group size</label>
              <select id="groupSize"></select>
            </div>

            <button class="btn warn" id="shuffleBtn" type="button">Shuffle names</button>
            <button class="btn primary" id="genBtn" type="button">Generate groups</button>
            <button class="btn good" id="copyLinkBtn" type="button">Copy share link</button>
            <button class="btn bad" id="clearBtn" type="button">Clear</button>
          </div>

          <div class="msg" id="msgBox">
            <span>Ready.</span>
            <span class="mono" id="seedLabel"></span>
          </div>
        </div>

        <div class="section">
          <div class="row spread" style="margin-bottom:10px;">
            <label>Groups</label>
            <span class="mono" id="shareHint"></span>
          </div>
          <div id="groups" class="groups"></div>
        </div>
      </div>

      <div class="footerNote">
        Offline + single-file. Share links store the list (compressed), group size, and a seed in the URL hash.
      </div>
    </div>
  </div>

<script>
/* ============================
   Small utilities
============================ */
const $ = (id)=>document.getElementById(id);

function setMsg(text, kind=""){
  const box = $("msgBox");
  box.className = "msg" + (kind ? (" " + kind) : "");
  box.firstElementChild.textContent = text;
}

function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

function normName(s){
  // trim ends; keep internal spaces
  return (s ?? "").replace(/\s+/g, " ").trim();
}

function parseNames(raw){
  const lines = (raw ?? "").split(/\r?\n/);
  const cleaned = [];
  const seen = new Set();
  for(const line of lines){
    const n = normName(line);
    if(!n) continue; // ignore blank
    const key = n.toLowerCase();
    if(seen.has(key)) continue; // remove duplicates
    seen.add(key);
    cleaned.push(n);
    if(cleaned.length >= 30) break;
  }
  return cleaned;
}

function updateCountPill(n){
  $("countPill").textContent = `${n} name${n===1?"":"s"}`;
}

/* ============================
   PRNG (seeded)
============================ */
function mulberry32(seed){
  let t = seed >>> 0;
  return function(){
    t += 0x6D2B79F5;
    let x = Math.imul(t ^ (t >>> 15), 1 | t);
    x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
    return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
  };
}

function randomSeed(){
  // 32-bit unsigned
  const a = crypto && crypto.getRandomValues ? crypto.getRandomValues(new Uint32Array(1))[0] : Math.floor(Math.random()*2**32);
  return (a >>> 0);
}

function shuffleInPlace(arr, rng){
  for(let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(rng() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

/* ============================
   LZ-based compression (embedded)
   Source adapted from LZ-String (MIT)
   (Trimmed to what we need: compressToEncodedURIComponent / decompressFromEncodedURIComponent)
============================ */
const LZString = (function(){
  const f = String.fromCharCode;
  const keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";

  function getBaseValue(alphabet, character) {
    return alphabet.indexOf(character);
  }

  function compressToEncodedURIComponent(input){
    if (input == null) return "";
    return _compress(input, 6, a=>keyStrUriSafe.charAt(a));
  }

  function decompressFromEncodedURIComponent(input){
    if (input == null) return "";
    if (input === "") return null;
    input = input.replace(/ /g, "+");
    return _decompress(input.length, 32, index=>getBaseValue(keyStrUriSafe, input.charAt(index)));
  }

  function _compress(uncompressed, bitsPerChar, getCharFromInt) {
    if (uncompressed == null) return "";
    let i, value;
    const context_dictionary = {};
    const context_dictionaryToCreate = {};
    let context_c = "";
    let context_wc = "";
    let context_w = "";
    let context_enlargeIn = 2;
    let context_dictSize = 3;
    let context_numBits = 2;
    const context_data = [];
    let context_data_val = 0;
    let context_data_position = 0;

    for (i = 0; i < uncompressed.length; i += 1) {
      context_c = uncompressed.charAt(i);
      if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
        context_dictionary[context_c] = context_dictSize++;
        context_dictionaryToCreate[context_c] = true;
      }

      context_wc = context_w + context_c;
      if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
        context_w = context_wc;
      } else {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
          if (context_w.charCodeAt(0) < 256) {
            for (let j = 0; j < context_numBits; j++) {
              context_data_val = (context_data_val << 1);
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
            }
            value = context_w.charCodeAt(0);
            for (let j = 0; j < 8; j++) {
              context_data_val = (context_data_val << 1) | (value & 1);
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          } else {
            value = 1;
            for (let j = 0; j < context_numBits; j++) {
              context_data_val = (context_data_val << 1) | value;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = 0;
            }
            value = context_w.charCodeAt(0);
            for (let j = 0; j < 16; j++) {
              context_data_val = (context_data_val << 1) | (value & 1);
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          delete context_dictionaryToCreate[context_w];
        } else {
          value = context_dictionary[context_w];
          for (let j = 0; j < context_numBits; j++) {
            context_data_val = (context_data_val << 1) | (value & 1);
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        context_dictionary[context_wc] = context_dictSize++;
        context_w = String(context_c);
      }
    }

    if (context_w !== "") {
      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
        if (context_w.charCodeAt(0) < 256) {
          for (let j = 0; j < context_numBits; j++) {
            context_data_val = (context_data_val << 1);
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
          }
          value = context_w.charCodeAt(0);
          for (let j = 0; j < 8; j++) {
            context_data_val = (context_data_val << 1) | (value & 1);
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        } else {
          value = 1;
          for (let j = 0; j < context_numBits; j++) {
            context_data_val = (context_data_val << 1) | value;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = 0;
          }
          value = context_w.charCodeAt(0);
          for (let j = 0; j < 16; j++) {
            context_data_val = (context_data_val << 1) | (value & 1);
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        delete context_dictionaryToCreate[context_w];
      } else {
        value = context_dictionary[context_w];
        for (let j = 0; j < context_numBits; j++) {
          context_data_val = (context_data_val << 1) | (value & 1);
          if (context_data_position == bitsPerChar - 1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }
      }
      context_enlargeIn--;
      if (context_enlargeIn == 0) {
        context_enlargeIn = Math.pow(2, context_numBits);
        context_numBits++;
      }
    }

    value = 2;
    for (let j = 0; j < context_numBits; j++) {
      context_data_val = (context_data_val << 1) | (value & 1);
      if (context_data_position == bitsPerChar - 1) {
        context_data_position = 0;
        context_data.push(getCharFromInt(context_data_val));
        context_data_val = 0;
      } else {
        context_data_position++;
      }
      value = value >> 1;
    }

    while (true) {
      context_data_val = (context_data_val << 1);
      if (context_data_position == bitsPerChar - 1) {
        context_data.push(getCharFromInt(context_data_val));
        break;
      } else context_data_position++;
    }
    return context_data.join("");
  }

  function _decompress(length, resetValue, getNextValue) {
    const dictionary = [];
    let next;
    let enlargeIn = 4;
    let dictSize = 4;
    let numBits = 3;
    let entry = "";
    const result = [];
    let i;
    let w;
    let bits, resb, maxpower, power;
    let c;
    const data = { val: getNextValue(0), position: resetValue, index: 1 };

    for (i = 0; i < 3; i += 1) {
      dictionary[i] = i;
    }

    bits = 0;
    maxpower = Math.pow(2, 2);
    power = 1;
    while (power != maxpower) {
      resb = data.val & data.position;
      data.position >>= 1;
      if (data.position == 0) {
        data.position = resetValue;
        data.val = getNextValue(data.index++);
      }
      bits |= (resb > 0 ? 1 : 0) * power;
      power <<= 1;
    }

    switch (next = bits) {
      case 0:
        bits = 0; maxpower = Math.pow(2, 8); power = 1;
        while (power != maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }
        c = f(bits);
        break;
      case 1:
        bits = 0; maxpower = Math.pow(2, 16); power = 1;
        while (power != maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }
        c = f(bits);
        break;
      case 2:
        return "";
    }
    dictionary[3] = c;
    w = c;
    result.push(c);

    while (true) {
      if (data.index > length) return "";

      bits = 0; maxpower = Math.pow(2, numBits); power = 1;
      while (power != maxpower) {
        resb = data.val & data.position;
        data.position >>= 1;
        if (data.position == 0) {
          data.position = resetValue;
          data.val = getNextValue(data.index++);
        }
        bits |= (resb > 0 ? 1 : 0) * power;
        power <<= 1;
      }

      switch (c = bits) {
        case 0:
          bits = 0; maxpower = Math.pow(2, 8); power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          dictionary[dictSize++] = f(bits);
          c = dictSize - 1;
          enlargeIn--;
          break;
        case 1:
          bits = 0; maxpower = Math.pow(2, 16); power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          dictionary[dictSize++] = f(bits);
          c = dictSize - 1;
          enlargeIn--;
          break;
        case 2:
          return result.join("");
      }

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

      if (dictionary[c]) entry = dictionary[c];
      else {
        if (c === dictSize) entry = w + w.charAt(0);
        else return null;
      }
      result.push(entry);

      dictionary[dictSize++] = w + entry.charAt(0);
      enlargeIn--;

      w = entry;

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }
    }
  }

  return { compressToEncodedURIComponent, decompressFromEncodedURIComponent };
})();

/* ============================
   Grouping logic
============================ */
function computeGroupSizes(n, size){
  // Prefer groups of `size`, with some smaller groups if remainder.
  // Avoid single-person groups by adjusting distribution.
  if (n <= 0) return [];
  if (size < 2) size = 2;
  if (size > n) size = n;

  let full = Math.floor(n / size);
  let rem  = n % size;

  // if no full groups, just one group of n
  if (full === 0) return [n];

  // normal case
  const sizes = new Array(full).fill(size);

  if (rem === 0) return sizes;

  if (rem === 1){
    if (size === 2){
      // would create a singleton; make one group of 3 instead (one larger group)
      // Requires at least one existing group of 2.
      sizes.pop(); // remove one group of 2
      sizes.push(3);
      // remaining people: (full-1)*2 + 3 = 2*full +1 = n, OK
      return sizes;
    } else {
      // Take 1 from a full group -> makes (size-1) and leaves 2 for the remainder group.
      // Example: 10 into 3 => 3,3,2,2
      // Example: 4 into 3 => 2,2
      sizes[0] = size - 1;
      rem = 2;
    }
  }

  // rem is now 2..size-1 (or could be 2 after adjustment)
  if (rem > 0) sizes.push(rem);

  // As a final safety, if any 1 sneaks in, fix by rebalancing
  // (shouldn't happen with above rules, but just in case).
  const idx1 = sizes.indexOf(1);
  if (idx1 !== -1){
    // borrow from the largest group
    let maxIdx = 0;
    for(let i=1;i<sizes.length;i++) if(sizes[i] > sizes[maxIdx]) maxIdx = i;
    if (sizes[maxIdx] >= 3){
      sizes[maxIdx] -= 1;
      sizes[idx1] += 1;
    }
  }

  return sizes;
}

function makeGroups(names, size, seed){
  const rng = mulberry32(seed);
  const shuffled = shuffleInPlace(names.slice(), rng);
  const sizes = computeGroupSizes(shuffled.length, size);

  const groups = [];
  let idx = 0;
  for(let gi=0; gi<sizes.length; gi++){
    const take = sizes[gi];
    groups.push(shuffled.slice(idx, idx + take));
    idx += take;
  }
  return { groups, seedUsed: seed, sizes };
}

/* ============================
   UI wiring
============================ */
let lastGenerated = null; // {seed, size, names[], groups[]}
let suppressNameUpdate = false;

function rebuildGroupSizeOptions(){
  const names = parseNames($("names").value);
  updateCountPill(names.length);

  const sel = $("groupSize");
  const current = parseInt(sel.value, 10);
  sel.innerHTML = "";

  if (names.length < 2){
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = "—";
    sel.appendChild(opt);
    sel.disabled = true;
    return;
  }

  const maxSize = Math.floor(names.length / 2);
  sel.disabled = false;

  if (maxSize < 2){
    // Not enough names to form 2 groups of at least size 2, but we still allow group size 2
    // because groups-of-2 is the expected minimum, and will produce one group (or one group of 3 if 3 names).
    const opt = document.createElement("option");
    opt.value = "2";
    opt.textContent = "2";
    sel.appendChild(opt);
    sel.value = "2";
    return;
  }

  for(let s=2; s<=maxSize; s++){
    const opt = document.createElement("option");
    opt.value = String(s);
    opt.textContent = String(s);
    sel.appendChild(opt);
  }

  // restore if still valid
  if (!Number.isNaN(current) && current >= 2 && current <= maxSize){
    sel.value = String(current);
  } else {
    sel.value = "2";
  }
}

function renderGroups(groups){
  const wrap = $("groups");
  wrap.innerHTML = "";
  if (!groups || !groups.length){
    wrap.innerHTML = `<div class="mono">No groups yet.</div>`;
    return;
  }
  groups.forEach((g, i)=>{
    const card = document.createElement("div");
    card.className = "groupCard";

    const title = document.createElement("div");
    title.className = "groupTitle";
    const b = document.createElement("b");
    b.textContent = `Group ${i+1}`;
    const s = document.createElement("span");
    s.textContent = `${g.length} student${g.length===1?"":"s"}`;
    title.appendChild(b);
    title.appendChild(s);

    const ul = document.createElement("ul");
    g.forEach(name=>{
      const li = document.createElement("li");
      li.textContent = name;
      ul.appendChild(li);
    });

    card.appendChild(title);
    card.appendChild(ul);
    wrap.appendChild(card);
  });
}

function applyLock(){
  const locked = $("lockNames").checked;
  $("names").readOnly = locked;
}

function normalizeTextareaInPlace(){
  // Optional: if user wants, we can rewrite textarea as cleaned unique list.
  // We'll do it on generate/shuffle/copy link to avoid interrupting typing.
  const cleaned = parseNames($("names").value);
  suppressNameUpdate = true;
  $("names").value = cleaned.join("\n");
  suppressNameUpdate = false;
  rebuildGroupSizeOptions();
  return cleaned;
}

function doGenerate(useNewSeed=true){
  const names = normalizeTextareaInPlace();
  if (names.length < 2){
    setMsg("Please enter at least 2 names.", "bad");
    renderGroups([]);
    $("seedLabel").textContent = "";
    lastGenerated = null;
    return;
  }

  const size = parseInt($("groupSize").value, 10);
  if (!size || size < 2){
    setMsg("Pick a valid group size.", "bad");
    renderGroups([]);
    $("seedLabel").textContent = "";
    lastGenerated = null;
    return;
  }

  const seed = useNewSeed ? randomSeed() : (lastGenerated?.seed ?? randomSeed());
  const { groups, seedUsed, sizes } = makeGroups(names, size, seed);

  // Safety check: no singletons unless unavoidable
  const hasSingleton = groups.some(g => g.length === 1);
  if (hasSingleton){
    // This should be rare with our sizing rules; still show but warn.
    setMsg("Generated, but a 1-person group occurred (could be unavoidable with your settings).", "warn");
  } else {
    setMsg("Groups generated.", "ok");
  }

  $("seedLabel").textContent = `seed: ${seedUsed}`;
  $("shareHint").textContent = "";
  renderGroups(groups);
  lastGenerated = { seed: seedUsed, size, names, groups, sizes };
}

function doShuffle(){
  const names = normalizeTextareaInPlace();
  if (names.length < 2){
    setMsg("Add at least 2 names to shuffle.", "bad");
    return;
  }
  const rng = mulberry32(randomSeed());
  shuffleInPlace(names, rng);
  suppressNameUpdate = true;
  $("names").value = names.join("\n");
  suppressNameUpdate = false;
  rebuildGroupSizeOptions();
  setMsg("Names shuffled.", "ok");
}

function doClear(){
  $("names").value = "";
  $("lockNames").checked = false;
  applyLock();
  rebuildGroupSizeOptions();
  renderGroups([]);
  $("seedLabel").textContent = "";
  $("shareHint").textContent = "";
  lastGenerated = null;
  setMsg("Cleared.", "");
}

function buildShareHash(names, size, seed){
  const payload = JSON.stringify({ n: names, g: size, s: seed });
  const d = LZString.compressToEncodedURIComponent(payload);
  return `#d=${d}`;
}

function parseShareHash(){
  const h = location.hash || "";
  const m = h.match(/#d=([^&]+)/);
  if (!m) return null;
  try{
    const json = LZString.decompressFromEncodedURIComponent(m[1]);
    if (!json) return null;
    const obj = JSON.parse(json);
    if (!obj || !Array.isArray(obj.n)) return null;
    return {
      names: obj.n.map(normName).filter(Boolean),
      size: parseInt(obj.g, 10),
      seed: (obj.s >>> 0)
    };
  }catch(e){
    return null;
  }
}

async function copyShareLink(){
  // Ensure we have a consistent generated result tied to the link:
  // generate with a new seed using cleaned names and current size,
  // then copy link that re-creates it exactly.
  const names = normalizeTextareaInPlace();
  if (names.length < 2){
    setMsg("Please enter at least 2 names first.", "bad");
    return;
  }
  const size = parseInt($("groupSize").value, 10);
  if (!size || size < 2){
    setMsg("Pick a valid group size first.", "bad");
    return;
  }
  const seed = randomSeed();
  const { groups, seedUsed } = makeGroups(names, size, seed);

  // Render to match link
  renderGroups(groups);
  $("seedLabel").textContent = `seed: ${seedUsed}`;
  setMsg("Share link copied.", "ok");
  lastGenerated = { seed: seedUsed, size, names, groups };

  const hash = buildShareHash(names, size, seedUsed);
  const url = location.href.split("#")[0] + hash;

  try{
    await navigator.clipboard.writeText(url);
    $("shareHint").textContent = "Link copied.";
  }catch(e){
    // fallback
    const ta = document.createElement("textarea");
    ta.value = url;
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    document.body.appendChild(ta);
    ta.select();
    try{ document.execCommand("copy"); $("shareHint").textContent = "Link copied."; }
    catch(_){ $("shareHint").textContent = "Could not auto-copy. (Clipboard blocked)"; }
    document.body.removeChild(ta);
  }
}

/* ============================
   Init
============================ */
function init(){
  $("names").addEventListener("input", ()=>{
    if (suppressNameUpdate) return;
    rebuildGroupSizeOptions();
    // If user edits after generating, clear seed label hint (but keep groups until they choose to regen).
    $("seedLabel").textContent = "";
    $("shareHint").textContent = "";
  });

  $("lockNames").addEventListener("change", applyLock);
  $("shuffleBtn").addEventListener("click", doShuffle);
  $("genBtn").addEventListener("click", ()=>doGenerate(true));
  $("copyLinkBtn").addEventListener("click", copyShareLink);
  $("clearBtn").addEventListener("click", doClear);

  rebuildGroupSizeOptions();
  renderGroups([]);

  // Load from share hash if present
  const shared = parseShareHash();
  if (shared){
    // populate
    const deduped = [];
    const seen = new Set();
    for(const nm of shared.names){
      const n = normName(nm);
      if(!n) continue;
      const k = n.toLowerCase();
      if(seen.has(k)) continue;
      seen.add(k);
      deduped.push(n);
      if(deduped.length >= 30) break;
    }
    suppressNameUpdate = true;
    $("names").value = deduped.join("\n");
    suppressNameUpdate = false;
    rebuildGroupSizeOptions();

    const maxSize = Math.max(2, Math.floor(deduped.length / 2));
    let size = shared.size;
    if (!Number.isFinite(size) || size < 2) size = 2;
    if (deduped.length >= 2){
      // enforce allowed range (2..maxSize), with special case if maxSize < 2 handled by rebuildGroupSizeOptions
      if (Math.floor(deduped.length / 2) >= 2){
        size = clamp(size, 2, maxSize);
      } else {
        size = 2;
      }
      $("groupSize").value = String(size);
      const { groups, seedUsed } = makeGroups(deduped, size, shared.seed >>> 0);
      renderGroups(groups);
      $("seedLabel").textContent = `seed: ${seedUsed}`;
      setMsg("Loaded from share link.", "ok");
      $("shareHint").textContent = "";
      lastGenerated = { seed: seedUsed, size, names: deduped, groups };
    }
  } else {
    setMsg("Ready.", "");
  }

  applyLock();
}

init();
</script>
</body>
</html>
