<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Math Equations — Fill the Numbers</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background:#f6f7fb; color:#111; }
    .wrap { max-width: 920px; margin: 0 auto; padding: 24px; }
    h1 { margin: 0 0 8px; }
    .muted { color:#555; }
    .card { background:#fff; border:1px solid #e7e7ee; border-radius:14px; padding:18px; box-shadow:0 2px 10px rgba(0,0,0,0.04); }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .btn { border:0; border-radius:12px; padding:12px 16px; font-size:16px; cursor:pointer; background:#111; color:#fff; }
    .btn.secondary { background:#e9e9f2; color:#111; }
    .btn:active { transform: translateY(1px); }
    .grid { margin-top: 14px; display:grid; gap: 10px; }
    .eq {
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding: 12px; border-radius:12px; border:1px solid #ededf5; background:#fafafe;
    }
    .eq-left { display:flex; gap:10px; align-items:center; flex-wrap:wrap; font-size:22px; }
    .blank {
      width: 92px; font-size: 20px; padding: 10px 12px;
      border-radius:10px; border: 2px solid #d8d8e6; background:#fff; outline:none;
      text-align:center;
    }
    .blank:focus { border-color:#111; box-shadow:0 0 0 3px rgba(0,0,0,0.08); }
    .op { font-weight: 800; }
    .ans { font-weight: 800; }
    .tag { font-size:13px; padding:6px 10px; border-radius:999px; border:1px solid #ddd; background:#fff; }
    .tag.ok { border-color:#bfe5c6; background:#eefaf1; }
    .tag.no { border-color:#f0bcbc; background:#fff0f0; }
    .bank { margin-top: 14px; display:flex; gap:10px; flex-wrap:wrap; }
    .numBtn {
      min-width: 58px;
      border-radius: 12px;
      border: 1px solid #d9d9e7;
      background:#fff;
      padding: 10px 12px;
      font-size: 18px;
      cursor: pointer;
    }
    .numBtn.used { opacity:0.35; cursor:not-allowed; }
    .numBtn.selected { outline: 3px solid rgba(0,0,0,0.12); border-color:#111; }
    hr { border:none; border-top:1px solid #eee; margin:16px 0; }
    .score { font-weight: 800; font-size: 18px; margin-left:auto; }
    .rules { line-height:1.35; }
    .small { font-size: 13px; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; padding: 3px 6px; border: 1px solid #ddd; border-bottom-width: 2px; border-radius: 6px; background:#fff; }
    .modeTag { font-size: 13px; padding: 6px 10px; border-radius: 999px; border: 1px solid #ddd; background:#fff; }

    /* Mode menu alignment */
    .modeGrid {
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 12px;
      margin-top: 12px;
      align-items: stretch;
    }
    .modeCard {
      border:1px solid #e7e7ee;
      border-radius:14px;
      padding:14px;
      background:#fafafe;
      display:flex;
      flex-direction:column;
      gap:10px;
      height:100%;
    }
    .modeTitle { font-weight: 800; font-size: 18px; text-align:center; }
    .modeDesc { color:#555; font-size: 14px; line-height:1.35; text-align:center; }
    .modeCard .btn { width:100%; margin-top:auto; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1><u><b>Math Equations</b></u></h1>

    <!-- MODE SELECT -->
    <div class="card" id="modeScreen" style="margin-top:14px;">
      <div class="muted rules">
        Choose a mode. You’ll fill in the blanks using the number bank.<br>
        You may use each number <b>only once</b>.<br>
        There will be exactly: <b>1 addition</b>, <b>1 subtraction</b>, <b>1 multiplication</b>, <b>1 division</b>, and <b>1 random</b> (one of those four).<br>
        <b>Division will always be a whole number.</b>
      </div>

      <div class="modeGrid">
        <div class="modeCard">
          <div class="modeTitle">Normal Mode</div>
          <div class="modeDesc">Numbers <b>1–10</b>, each used once.</div>
          <button class="btn" data-pick="normal">Start Normal</button>
        </div>
        <div class="modeCard">
          <div class="modeTitle">Negative Mode</div>
          <div class="modeDesc">Numbers <b>-5..-1</b> and <b>1..5</b> (no 0), each used once.</div>
          <button class="btn" data-pick="negative">Start Negative</button>
        </div>
      </div>
    </div>

    <!-- GAME -->
    <div class="card" id="gameScreen" style="margin-top:14px; display:none;">
      <div class="row">
        <button class="btn" id="checkBtn">Check</button>
        <button class="btn secondary" id="clearBtn">Clear All</button>
        <button class="btn secondary" id="newBtn">New Puzzle</button>
        <button class="btn secondary" id="changeModeBtn">Change Mode</button>
        <div class="score" id="scoreText">Solved: 0 / 5</div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div class="muted rules" id="rulesText"></div>
        <div class="score"><span class="modeTag" id="modeTag"></span></div>
      </div>

      <div class="grid" id="equations"></div>

      <hr />

      <div class="small muted" id="bankHint">
        Number Bank (click a number, then click a blank — or just type):
        <span class="kbd">Backspace</span> clears a blank
      </div>
      <div class="bank" id="bank"></div>

      <div id="message" class="muted" style="margin-top:12px;"></div>
    </div>
  </div>

  <script>
    const modeScreen = document.getElementById("modeScreen");
    const gameScreen = document.getElementById("gameScreen");

    const eqEl = document.getElementById("equations");
    const bankEl = document.getElementById("bank");
    const scoreText = document.getElementById("scoreText");
    const msgEl = document.getElementById("message");
    const rulesText = document.getElementById("rulesText");
    const modeTag = document.getElementById("modeTag");

    let puzzle = null; // { mode, pool[], equations[], used:Set<number>, selected:number|null }

    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function opSymbol(op) {
      if (op === "add") return "+";
      if (op === "subtract") return "−";
      if (op === "multiply") return "×";
      return "÷";
    }

    function getPoolForMode(mode) {
      if (mode === "normal") return Array.from({length: 10}, (_, i) => i + 1);
      return [-5,-4,-3,-2,-1, 1,2,3,4,5]; // negative (no 0)
    }

    function modeLabel(mode) {
      if (mode === "normal") return "Normal Mode (1–10)";
      return "Negative Mode (-5..-1, 1..5)";
    }

    function sanitizeInputValue(raw) {
      raw = raw.replace(/[^\d-]/g, "");
      if (raw.includes("-")) raw = raw.replace(/(?!^)-/g, "");
      return raw;
    }

    function evaluateEquation(op, a, b) {
      if (op === "add") return a + b;
      if (op === "subtract") return a - b;
      if (op === "multiply") return a * b;
      if (b === 0) return NaN;
      return a / b;
    }

    function isExactDivision(a, b) {
      if (b === 0) return false;
      return Number.isInteger(a / b);
    }

    function pickPair(arr) {
      const i = Math.floor(Math.random() * arr.length);
      let j = Math.floor(Math.random() * (arr.length - 1));
      if (j >= i) j++;
      const a = arr[i], b = arr[j];
      const hi = Math.max(i, j), lo = Math.min(i, j);
      arr.splice(hi, 1);
      arr.splice(lo, 1);
      return [a, b];
    }

    function generatePuzzle(mode) {
      const poolBase = getPoolForMode(mode);

      // Brute-force a bit to guarantee we can create one whole-number division
      for (let attempt = 0; attempt < 4000; attempt++) {
        const working = shuffleArray(poolBase.slice());

        // Division pair: must be exact in one direction
        let divA, divB, divAns;
        let foundDiv = false;
        for (let i = 0; i < working.length && !foundDiv; i++) {
          for (let j = i + 1; j < working.length && !foundDiv; j++) {
            const x = working[i], y = working[j];
            if (isExactDivision(x, y)) { divA = x; divB = y; divAns = x / y; foundDiv = true; break; }
            if (isExactDivision(y, x)) { divA = y; divB = x; divAns = y / x; foundDiv = true; break; }
          }
        }
        if (!foundDiv) continue;

        // remove chosen division numbers
        working.splice(working.indexOf(divA), 1);
        working.splice(working.indexOf(divB), 1);

        // Multiply
        const [mA, mB] = pickPair(working);
        const mAns = mA * mB;

        // Subtract (non-negative in normal mode; free in negative mode)
        let [sA, sB] = pickPair(working);
        if (mode === "normal" && sB > sA) [sA, sB] = [sB, sA];
        const sAns = sA - sB;

        // Add
        const [aA, aB] = pickPair(working);
        const aAns = aA + aB;

        // Random op uses last two numbers
        const [x, y] = working;
        const randOp = ["add","subtract","multiply","divide"][Math.floor(Math.random()*4)];
        let rA, rB, rAns, rOp = randOp;

        if (rOp === "add") {
          rA = x; rB = y; rAns = x + y;
        } else if (rOp === "multiply") {
          rA = x; rB = y; rAns = x * y;
        } else if (rOp === "subtract") {
          if (mode === "normal") { rA = Math.max(x,y); rB = Math.min(x,y); }
          else { rA = x; rB = y; }
          rAns = rA - rB;
        } else {
          // division must be exact; if not possible, switch to add (keeps "random op" idea)
          if (isExactDivision(x, y)) { rA = x; rB = y; rAns = x / y; }
          else if (isExactDivision(y, x)) { rA = y; rB = x; rAns = y / x; }
          else { rOp = "add"; rA = x; rB = y; rAns = x + y; }
        }

        const equations = [
          { id: crypto.randomUUID(), op: "divide",   a: divA, b: divB, answer: divAns },
          { id: crypto.randomUUID(), op: "multiply", a: mA,   b: mB,   answer: mAns },
          { id: crypto.randomUUID(), op: "subtract", a: sA,   b: sB,   answer: sAns },
          { id: crypto.randomUUID(), op: "add",      a: aA,   b: aB,   answer: aAns },
          { id: crypto.randomUUID(), op: rOp,        a: rA,   b: rB,   answer: rAns, isRandom: true },
        ];

        shuffleArray(equations);
        return { mode, pool: poolBase.slice(), equations, used: new Set(), selected: null };
      }

      // ultra-rare fallback: try normal
      return { mode: "normal", pool: getPoolForMode("normal"), equations: [], used: new Set(), selected: null };
    }

    function updateRulesUI() {
      const mode = puzzle.mode;
      let rangeText = "";
      if (mode === "normal") rangeText = "Fill in the blanks using the numbers <b>1–10</b>.";
      else rangeText = "Fill in the blanks using the numbers <b>-5..-1</b> and <b>1..5</b> (no 0).";

      rulesText.innerHTML =
        `${rangeText}<br>
         You may use each number <b>only once</b>.<br>
         There will be exactly: <b>1 addition</b>, <b>1 subtraction</b>, <b>1 multiplication</b>, <b>1 division</b>, and <b>1 random</b> (one of those four).<br>
         <b>Division will always be a whole number.</b>`;

      modeTag.textContent = modeLabel(mode);
    }

    function updateBankUI() {
      const btns = [...bankEl.querySelectorAll("button")];
      btns.forEach(btn => {
        const n = Number(btn.dataset.n);
        btn.classList.toggle("used", puzzle.used.has(n));
        btn.disabled = puzzle.used.has(n);
        btn.classList.toggle("selected", puzzle.selected === n);
      });
    }

    function currentBlankId() {
      const active = document.activeElement;
      if (active && active.classList && active.classList.contains("blank")) return active.id;
      return null;
    }

    function recomputeUsedFromInputs() {
      puzzle.used.clear();
      const allowed = new Set(getPoolForMode(puzzle.mode));
      const inputs = [...eqEl.querySelectorAll("input.blank")];
      for (const inp of inputs) {
        const val = inp.value.trim();
        if (!val || val === "-") continue;
        const n = Number(val);
        if (Number.isInteger(n) && allowed.has(n)) puzzle.used.add(n);
      }
    }

    function render() {
      eqEl.innerHTML = "";
      bankEl.innerHTML = "";
      msgEl.textContent = "";
      scoreText.textContent = "Solved: 0 / 5";
      updateRulesUI();

      // Equations
      puzzle.equations.forEach((eq, idx) => {
        const row = document.createElement("div");
        row.className = "eq";
        const sym = opSymbol(eq.op);

        row.innerHTML = `
          <div class="eq-left">
            <span><b>${idx + 1}.</b></span>
            <input class="blank" inputmode="text" maxlength="3" id="a-${eq.id}" aria-label="First number for equation ${idx+1}">
            <span class="op">${sym}</span>
            <input class="blank" inputmode="text" maxlength="3" id="b-${eq.id}" aria-label="Second number for equation ${idx+1}">
            <span>=</span>
            <span class="ans">${eq.answer}</span>
            ${eq.isRandom ? `<span class="tag" title="This line is the random operation">Random</span>` : ``}
          </div>
          <div class="tag" id="tag-${eq.id}">Not checked</div>
        `;
        eqEl.appendChild(row);

        const aInp = row.querySelector(`#a-${CSS.escape(eq.id)}`);
        const bInp = row.querySelector(`#b-${CSS.escape(eq.id)}`);

        for (const inp of [aInp, bInp]) {
          inp.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              const blanks = [...eqEl.querySelectorAll("input.blank")];
              const i = blanks.indexOf(inp);
              (blanks[i + 1] || blanks[0]).focus();
            }
          });

          inp.addEventListener("input", () => {
            inp.value = sanitizeInputValue(inp.value);
            recomputeUsedFromInputs();
            updateBankUI();
          });
        }
      });

      // Bank
      const pool = getPoolForMode(puzzle.mode);
      pool.forEach((n) => {
        const b = document.createElement("button");
        b.className = "numBtn";
        b.textContent = n;
        b.dataset.n = String(n);

        b.addEventListener("click", () => {
          if (puzzle.used.has(n)) return;
          puzzle.selected = (puzzle.selected === n) ? null : n;
          updateBankUI();

          const id = currentBlankId();
          if (id && puzzle.selected !== null) {
            const inp = document.getElementById(id);
            inp.value = String(puzzle.selected);
            puzzle.selected = null;
            recomputeUsedFromInputs();
            updateBankUI();
          }
        });

        bankEl.appendChild(b);
      });

      // Click blank to place selected number
      eqEl.addEventListener("click", (e) => {
        const target = e.target;
        if (!(target instanceof HTMLInputElement)) return;
        if (!target.classList.contains("blank")) return;
        if (puzzle.selected === null) return;

        target.value = String(puzzle.selected);
        puzzle.selected = null;
        recomputeUsedFromInputs();
        updateBankUI();
      });

      updateBankUI();
      eqEl.querySelector("input.blank")?.focus();
    }

    function check() {
      recomputeUsedFromInputs();
      updateBankUI();

      const allowed = new Set(getPoolForMode(puzzle.mode));
      const blanks = [...eqEl.querySelectorAll("input.blank")];
      const vals = blanks.map(i => i.value.trim());

      const nums = [];
      for (const v of vals) {
        if (!v || v === "-") {
          msgEl.textContent = "Fill in all blanks first.";
          msgEl.style.color = "#b00020";
          return;
        }
        const n = Number(v);
        if (!Number.isInteger(n) || !allowed.has(n)) {
          msgEl.textContent = "Only use numbers from the current number bank.";
          msgEl.style.color = "#b00020";
          return;
        }
        nums.push(n);
      }
      const set = new Set(nums);
      if (set.size !== nums.length) {
        msgEl.textContent = "Each number can only be used once. Fix duplicates.";
        msgEl.style.color = "#b00020";
        return;
      }

      let solved = 0;
      for (const eq of puzzle.equations) {
        const a = Number(document.getElementById(`a-${eq.id}`).value);
        const b = Number(document.getElementById(`b-${eq.id}`).value);
        const tag = document.getElementById(`tag-${eq.id}`);

        const res = evaluateEquation(eq.op, a, b);
        const ok = (Number.isFinite(res) && res === eq.answer);

        if (ok) {
          solved++;
          tag.className = "tag ok";
          tag.textContent = "Correct ✓";
        } else {
          tag.className = "tag no";
          tag.textContent = "Not correct";
        }
      }

      scoreText.textContent = `Solved: ${solved} / ${puzzle.equations.length}`;
      if (solved === puzzle.equations.length) {
        msgEl.textContent = "✅ Perfect! All equations are correct.";
        msgEl.style.color = "#0b6b2a";
      } else {
        msgEl.textContent = "Keep going — fix the ones marked ‘Not correct’.";
        msgEl.style.color = "#444";
      }
    }

    function clearAll() {
      const inputs = [...eqEl.querySelectorAll("input.blank")];
      inputs.forEach(i => i.value = "");
      puzzle.selected = null;
      puzzle.used.clear();

      puzzle.equations.forEach(eq => {
        const tag = document.getElementById(`tag-${eq.id}`);
        if (tag) {
          tag.className = "tag";
          tag.textContent = "Not checked";
        }
      });

      updateBankUI();
      scoreText.textContent = `Solved: 0 / ${puzzle.equations.length}`;
      msgEl.textContent = "";
      inputs[0]?.focus();
    }

    function newPuzzle() {
      puzzle = generatePuzzle(puzzle.mode);
      render();
    }

    function startMode(mode) {
      puzzle = generatePuzzle(mode);
      modeScreen.style.display = "none";
      gameScreen.style.display = "block";
      render();
    }

    function backToModeSelect() {
      puzzle = null;
      eqEl.innerHTML = "";
      bankEl.innerHTML = "";
      msgEl.textContent = "";
      modeScreen.style.display = "block";
      gameScreen.style.display = "none";
    }

    document.getElementById("checkBtn").addEventListener("click", check);
    document.getElementById("clearBtn").addEventListener("click", clearAll);
    document.getElementById("newBtn").addEventListener("click", newPuzzle);
    document.getElementById("changeModeBtn").addEventListener("click", backToModeSelect);

    modeScreen.addEventListener("click", (e) => {
      const btn = e.target.closest("button[data-pick]");
      if (!btn) return;
      startMode(btn.dataset.pick);
    });
  </script>
</body>
</html>
